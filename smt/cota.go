// Generated by Molecule 0.7.2
// Generated by Moleculec-Go 0.1.8

package compact_nft

import (
	"bytes"
	"encoding/binary"
	"errors"
	"strconv"
	"strings"
)

type Number uint32

const HeaderSizeUint uint32 = 4

// Byte is the primitive type
type Byte [1]byte

func NewByte(b byte) Byte {
	return Byte([1]byte{b})
}
func ByteDefault() Byte {
	return Byte([1]byte{0})
}
func ByteFromSliceUnchecked(slice []byte) *Byte {
	b := new(Byte)
	b[0] = slice[0]
	return b
}
func (b *Byte) AsSlice() []byte {
	return b[:]
}
func ByteFromSlice(slice []byte, _compatible bool) (*Byte, error) {
	if len(slice) != 1 {
		return nil, errors.New("TotalSizeNotMatch")
	}
	b := new(Byte)
	b[0] = slice[0]
	return b, nil
}
func unpackNumber(b []byte) Number {
	bytesBuffer := bytes.NewBuffer(b)
	var x Number
	binary.Read(bytesBuffer, binary.LittleEndian, &x)
	return x
}
func packNumber(num Number) []byte {
	b := make([]byte, 4)
	binary.LittleEndian.PutUint32(b, uint32(num))
	return b
}

type Byte32Builder struct {
	inner [32]Byte
}

func NewByte32Builder() *Byte32Builder {
	return &Byte32Builder{inner: [32]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *Byte32Builder) Build() Byte32 {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Byte32{inner: b.Bytes()}
}

func (s *Byte32Builder) Set(v [32]Byte) *Byte32Builder {
	s.inner = v
	return s
}

func (s *Byte32Builder) Nth0(v Byte) *Byte32Builder {
	s.inner[0] = v
	return s
}

func (s *Byte32Builder) Nth1(v Byte) *Byte32Builder {
	s.inner[1] = v
	return s
}

func (s *Byte32Builder) Nth2(v Byte) *Byte32Builder {
	s.inner[2] = v
	return s
}

func (s *Byte32Builder) Nth3(v Byte) *Byte32Builder {
	s.inner[3] = v
	return s
}

func (s *Byte32Builder) Nth4(v Byte) *Byte32Builder {
	s.inner[4] = v
	return s
}

func (s *Byte32Builder) Nth5(v Byte) *Byte32Builder {
	s.inner[5] = v
	return s
}

func (s *Byte32Builder) Nth6(v Byte) *Byte32Builder {
	s.inner[6] = v
	return s
}

func (s *Byte32Builder) Nth7(v Byte) *Byte32Builder {
	s.inner[7] = v
	return s
}

func (s *Byte32Builder) Nth8(v Byte) *Byte32Builder {
	s.inner[8] = v
	return s
}

func (s *Byte32Builder) Nth9(v Byte) *Byte32Builder {
	s.inner[9] = v
	return s
}

func (s *Byte32Builder) Nth10(v Byte) *Byte32Builder {
	s.inner[10] = v
	return s
}

func (s *Byte32Builder) Nth11(v Byte) *Byte32Builder {
	s.inner[11] = v
	return s
}

func (s *Byte32Builder) Nth12(v Byte) *Byte32Builder {
	s.inner[12] = v
	return s
}

func (s *Byte32Builder) Nth13(v Byte) *Byte32Builder {
	s.inner[13] = v
	return s
}

func (s *Byte32Builder) Nth14(v Byte) *Byte32Builder {
	s.inner[14] = v
	return s
}

func (s *Byte32Builder) Nth15(v Byte) *Byte32Builder {
	s.inner[15] = v
	return s
}

func (s *Byte32Builder) Nth16(v Byte) *Byte32Builder {
	s.inner[16] = v
	return s
}

func (s *Byte32Builder) Nth17(v Byte) *Byte32Builder {
	s.inner[17] = v
	return s
}

func (s *Byte32Builder) Nth18(v Byte) *Byte32Builder {
	s.inner[18] = v
	return s
}

func (s *Byte32Builder) Nth19(v Byte) *Byte32Builder {
	s.inner[19] = v
	return s
}

func (s *Byte32Builder) Nth20(v Byte) *Byte32Builder {
	s.inner[20] = v
	return s
}

func (s *Byte32Builder) Nth21(v Byte) *Byte32Builder {
	s.inner[21] = v
	return s
}

func (s *Byte32Builder) Nth22(v Byte) *Byte32Builder {
	s.inner[22] = v
	return s
}

func (s *Byte32Builder) Nth23(v Byte) *Byte32Builder {
	s.inner[23] = v
	return s
}

func (s *Byte32Builder) Nth24(v Byte) *Byte32Builder {
	s.inner[24] = v
	return s
}

func (s *Byte32Builder) Nth25(v Byte) *Byte32Builder {
	s.inner[25] = v
	return s
}

func (s *Byte32Builder) Nth26(v Byte) *Byte32Builder {
	s.inner[26] = v
	return s
}

func (s *Byte32Builder) Nth27(v Byte) *Byte32Builder {
	s.inner[27] = v
	return s
}

func (s *Byte32Builder) Nth28(v Byte) *Byte32Builder {
	s.inner[28] = v
	return s
}

func (s *Byte32Builder) Nth29(v Byte) *Byte32Builder {
	s.inner[29] = v
	return s
}

func (s *Byte32Builder) Nth30(v Byte) *Byte32Builder {
	s.inner[30] = v
	return s
}

func (s *Byte32Builder) Nth31(v Byte) *Byte32Builder {
	s.inner[31] = v
	return s
}

type Byte32 struct {
	inner []byte
}

func Byte32FromSliceUnchecked(slice []byte) *Byte32 {
	return &Byte32{inner: slice}
}
func (s *Byte32) AsSlice() []byte {
	return s.inner
}

func Byte32Default() Byte32 {
	return *Byte32FromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func Byte32FromSlice(slice []byte, _compatible bool) (*Byte32, error) {
	sliceLen := len(slice)
	if sliceLen != 32 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Byte32", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(32)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Byte32{inner: slice}, nil
}

func (s *Byte32) RawData() []byte {
	return s.inner
}

func (s *Byte32) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Byte32) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Byte32) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Byte32) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Byte32) Nth4() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *Byte32) Nth5() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *Byte32) Nth6() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *Byte32) Nth7() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *Byte32) Nth8() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *Byte32) Nth9() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *Byte32) Nth10() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *Byte32) Nth11() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *Byte32) Nth12() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *Byte32) Nth13() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *Byte32) Nth14() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *Byte32) Nth15() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *Byte32) Nth16() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[16:17])
	return ret
}

func (s *Byte32) Nth17() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[17:18])
	return ret
}

func (s *Byte32) Nth18() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[18:19])
	return ret
}

func (s *Byte32) Nth19() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[19:20])
	return ret
}

func (s *Byte32) Nth20() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[20:21])
	return ret
}

func (s *Byte32) Nth21() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[21:22])
	return ret
}

func (s *Byte32) Nth22() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[22:23])
	return ret
}

func (s *Byte32) Nth23() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[23:24])
	return ret
}

func (s *Byte32) Nth24() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[24:25])
	return ret
}

func (s *Byte32) Nth25() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[25:26])
	return ret
}

func (s *Byte32) Nth26() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[26:27])
	return ret
}

func (s *Byte32) Nth27() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[27:28])
	return ret
}

func (s *Byte32) Nth28() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[28:29])
	return ret
}

func (s *Byte32) Nth29() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[29:30])
	return ret
}

func (s *Byte32) Nth30() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[30:31])
	return ret
}

func (s *Byte32) Nth31() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[31:32])
	return ret
}

func (s *Byte32) AsBuilder() Byte32Builder {
	t := NewByte32Builder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	t.Nth4(*s.Nth4())
	t.Nth5(*s.Nth5())
	t.Nth6(*s.Nth6())
	t.Nth7(*s.Nth7())
	t.Nth8(*s.Nth8())
	t.Nth9(*s.Nth9())
	t.Nth10(*s.Nth10())
	t.Nth11(*s.Nth11())
	t.Nth12(*s.Nth12())
	t.Nth13(*s.Nth13())
	t.Nth14(*s.Nth14())
	t.Nth15(*s.Nth15())
	t.Nth16(*s.Nth16())
	t.Nth17(*s.Nth17())
	t.Nth18(*s.Nth18())
	t.Nth19(*s.Nth19())
	t.Nth20(*s.Nth20())
	t.Nth21(*s.Nth21())
	t.Nth22(*s.Nth22())
	t.Nth23(*s.Nth23())
	t.Nth24(*s.Nth24())
	t.Nth25(*s.Nth25())
	t.Nth26(*s.Nth26())
	t.Nth27(*s.Nth27())
	t.Nth28(*s.Nth28())
	t.Nth29(*s.Nth29())
	t.Nth30(*s.Nth30())
	t.Nth31(*s.Nth31())
	return *t
}

type Uint32Builder struct {
	inner [4]Byte
}

func NewUint32Builder() *Uint32Builder {
	return &Uint32Builder{inner: [4]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *Uint32Builder) Build() Uint32 {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Uint32{inner: b.Bytes()}
}

func (s *Uint32Builder) Set(v [4]Byte) *Uint32Builder {
	s.inner = v
	return s
}

func (s *Uint32Builder) Nth0(v Byte) *Uint32Builder {
	s.inner[0] = v
	return s
}

func (s *Uint32Builder) Nth1(v Byte) *Uint32Builder {
	s.inner[1] = v
	return s
}

func (s *Uint32Builder) Nth2(v Byte) *Uint32Builder {
	s.inner[2] = v
	return s
}

func (s *Uint32Builder) Nth3(v Byte) *Uint32Builder {
	s.inner[3] = v
	return s
}

type Uint32 struct {
	inner []byte
}

func Uint32FromSliceUnchecked(slice []byte) *Uint32 {
	return &Uint32{inner: slice}
}
func (s *Uint32) AsSlice() []byte {
	return s.inner
}

func Uint32Default() Uint32 {
	return *Uint32FromSliceUnchecked([]byte{0, 0, 0, 0})
}

func Uint32FromSlice(slice []byte, _compatible bool) (*Uint32, error) {
	sliceLen := len(slice)
	if sliceLen != 4 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint32", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(4)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Uint32{inner: slice}, nil
}

func (s *Uint32) RawData() []byte {
	return s.inner
}

func (s *Uint32) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Uint32) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Uint32) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Uint32) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Uint32) AsBuilder() Uint32Builder {
	t := NewUint32Builder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	return *t
}

type BytesBuilder struct {
	inner []Byte
}

func (s *BytesBuilder) Build() Bytes {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := Bytes{inner: b.Bytes()}

	return sb
}

func (s *BytesBuilder) Set(v []Byte) *BytesBuilder {
	s.inner = v
	return s
}
func (s *BytesBuilder) Push(v Byte) *BytesBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *BytesBuilder) Extend(iter []Byte) *BytesBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewBytesBuilder() *BytesBuilder {
	return &BytesBuilder{[]Byte{}}
}

type Bytes struct {
	inner []byte
}

func BytesFromSliceUnchecked(slice []byte) *Bytes {
	return &Bytes{inner: slice}
}
func (s *Bytes) AsSlice() []byte {
	return s.inner
}

func BytesDefault() Bytes {
	return *BytesFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func BytesFromSlice(slice []byte, _compatible bool) (*Bytes, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Bytes", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "Bytes", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &Bytes{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(1*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Bytes", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &Bytes{inner: slice}, nil
}

func (s *Bytes) TotalSize() uint {
	return uint(HeaderSizeUint) + 1*s.ItemCount()
}
func (s *Bytes) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *Bytes) Len() uint {
	return s.ItemCount()
}
func (s *Bytes) IsEmpty() bool {
	return s.Len() == 0
}

// if *Byte is nil, index is out of bounds
func (s *Bytes) Get(index uint) *Byte {
	var re *Byte
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 1*index
		end := start + 1
		re = ByteFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *Bytes) RawData() []byte {
	return s.inner[HeaderSizeUint:]
}

func (s *Bytes) AsBuilder() BytesBuilder {
	size := s.ItemCount()
	t := NewBytesBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type IssuerIdBuilder struct {
	inner [20]Byte
}

func NewIssuerIdBuilder() *IssuerIdBuilder {
	return &IssuerIdBuilder{inner: [20]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *IssuerIdBuilder) Build() IssuerId {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return IssuerId{inner: b.Bytes()}
}

func (s *IssuerIdBuilder) Set(v [20]Byte) *IssuerIdBuilder {
	s.inner = v
	return s
}

func (s *IssuerIdBuilder) Nth0(v Byte) *IssuerIdBuilder {
	s.inner[0] = v
	return s
}

func (s *IssuerIdBuilder) Nth1(v Byte) *IssuerIdBuilder {
	s.inner[1] = v
	return s
}

func (s *IssuerIdBuilder) Nth2(v Byte) *IssuerIdBuilder {
	s.inner[2] = v
	return s
}

func (s *IssuerIdBuilder) Nth3(v Byte) *IssuerIdBuilder {
	s.inner[3] = v
	return s
}

func (s *IssuerIdBuilder) Nth4(v Byte) *IssuerIdBuilder {
	s.inner[4] = v
	return s
}

func (s *IssuerIdBuilder) Nth5(v Byte) *IssuerIdBuilder {
	s.inner[5] = v
	return s
}

func (s *IssuerIdBuilder) Nth6(v Byte) *IssuerIdBuilder {
	s.inner[6] = v
	return s
}

func (s *IssuerIdBuilder) Nth7(v Byte) *IssuerIdBuilder {
	s.inner[7] = v
	return s
}

func (s *IssuerIdBuilder) Nth8(v Byte) *IssuerIdBuilder {
	s.inner[8] = v
	return s
}

func (s *IssuerIdBuilder) Nth9(v Byte) *IssuerIdBuilder {
	s.inner[9] = v
	return s
}

func (s *IssuerIdBuilder) Nth10(v Byte) *IssuerIdBuilder {
	s.inner[10] = v
	return s
}

func (s *IssuerIdBuilder) Nth11(v Byte) *IssuerIdBuilder {
	s.inner[11] = v
	return s
}

func (s *IssuerIdBuilder) Nth12(v Byte) *IssuerIdBuilder {
	s.inner[12] = v
	return s
}

func (s *IssuerIdBuilder) Nth13(v Byte) *IssuerIdBuilder {
	s.inner[13] = v
	return s
}

func (s *IssuerIdBuilder) Nth14(v Byte) *IssuerIdBuilder {
	s.inner[14] = v
	return s
}

func (s *IssuerIdBuilder) Nth15(v Byte) *IssuerIdBuilder {
	s.inner[15] = v
	return s
}

func (s *IssuerIdBuilder) Nth16(v Byte) *IssuerIdBuilder {
	s.inner[16] = v
	return s
}

func (s *IssuerIdBuilder) Nth17(v Byte) *IssuerIdBuilder {
	s.inner[17] = v
	return s
}

func (s *IssuerIdBuilder) Nth18(v Byte) *IssuerIdBuilder {
	s.inner[18] = v
	return s
}

func (s *IssuerIdBuilder) Nth19(v Byte) *IssuerIdBuilder {
	s.inner[19] = v
	return s
}

type IssuerId struct {
	inner []byte
}

func IssuerIdFromSliceUnchecked(slice []byte) *IssuerId {
	return &IssuerId{inner: slice}
}
func (s *IssuerId) AsSlice() []byte {
	return s.inner
}

func IssuerIdDefault() IssuerId {
	return *IssuerIdFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func IssuerIdFromSlice(slice []byte, _compatible bool) (*IssuerId, error) {
	sliceLen := len(slice)
	if sliceLen != 20 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "IssuerId", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(20)}, " ")
		return nil, errors.New(errMsg)
	}
	return &IssuerId{inner: slice}, nil
}

func (s *IssuerId) RawData() []byte {
	return s.inner
}

func (s *IssuerId) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *IssuerId) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *IssuerId) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *IssuerId) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *IssuerId) Nth4() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *IssuerId) Nth5() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *IssuerId) Nth6() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *IssuerId) Nth7() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *IssuerId) Nth8() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *IssuerId) Nth9() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *IssuerId) Nth10() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *IssuerId) Nth11() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *IssuerId) Nth12() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *IssuerId) Nth13() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *IssuerId) Nth14() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *IssuerId) Nth15() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *IssuerId) Nth16() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[16:17])
	return ret
}

func (s *IssuerId) Nth17() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[17:18])
	return ret
}

func (s *IssuerId) Nth18() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[18:19])
	return ret
}

func (s *IssuerId) Nth19() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[19:20])
	return ret
}

func (s *IssuerId) AsBuilder() IssuerIdBuilder {
	t := NewIssuerIdBuilder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	t.Nth4(*s.Nth4())
	t.Nth5(*s.Nth5())
	t.Nth6(*s.Nth6())
	t.Nth7(*s.Nth7())
	t.Nth8(*s.Nth8())
	t.Nth9(*s.Nth9())
	t.Nth10(*s.Nth10())
	t.Nth11(*s.Nth11())
	t.Nth12(*s.Nth12())
	t.Nth13(*s.Nth13())
	t.Nth14(*s.Nth14())
	t.Nth15(*s.Nth15())
	t.Nth16(*s.Nth16())
	t.Nth17(*s.Nth17())
	t.Nth18(*s.Nth18())
	t.Nth19(*s.Nth19())
	return *t
}

type CharacteristicBuilder struct {
	inner [8]Byte
}

func NewCharacteristicBuilder() *CharacteristicBuilder {
	return &CharacteristicBuilder{inner: [8]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *CharacteristicBuilder) Build() Characteristic {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Characteristic{inner: b.Bytes()}
}

func (s *CharacteristicBuilder) Set(v [8]Byte) *CharacteristicBuilder {
	s.inner = v
	return s
}

func (s *CharacteristicBuilder) Nth0(v Byte) *CharacteristicBuilder {
	s.inner[0] = v
	return s
}

func (s *CharacteristicBuilder) Nth1(v Byte) *CharacteristicBuilder {
	s.inner[1] = v
	return s
}

func (s *CharacteristicBuilder) Nth2(v Byte) *CharacteristicBuilder {
	s.inner[2] = v
	return s
}

func (s *CharacteristicBuilder) Nth3(v Byte) *CharacteristicBuilder {
	s.inner[3] = v
	return s
}

func (s *CharacteristicBuilder) Nth4(v Byte) *CharacteristicBuilder {
	s.inner[4] = v
	return s
}

func (s *CharacteristicBuilder) Nth5(v Byte) *CharacteristicBuilder {
	s.inner[5] = v
	return s
}

func (s *CharacteristicBuilder) Nth6(v Byte) *CharacteristicBuilder {
	s.inner[6] = v
	return s
}

func (s *CharacteristicBuilder) Nth7(v Byte) *CharacteristicBuilder {
	s.inner[7] = v
	return s
}

type Characteristic struct {
	inner []byte
}

func CharacteristicFromSliceUnchecked(slice []byte) *Characteristic {
	return &Characteristic{inner: slice}
}
func (s *Characteristic) AsSlice() []byte {
	return s.inner
}

func CharacteristicDefault() Characteristic {
	return *CharacteristicFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0})
}

func CharacteristicFromSlice(slice []byte, _compatible bool) (*Characteristic, error) {
	sliceLen := len(slice)
	if sliceLen != 8 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Characteristic", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(8)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Characteristic{inner: slice}, nil
}

func (s *Characteristic) RawData() []byte {
	return s.inner
}

func (s *Characteristic) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Characteristic) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Characteristic) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Characteristic) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Characteristic) Nth4() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *Characteristic) Nth5() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *Characteristic) Nth6() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *Characteristic) Nth7() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *Characteristic) AsBuilder() CharacteristicBuilder {
	t := NewCharacteristicBuilder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	t.Nth4(*s.Nth4())
	t.Nth5(*s.Nth5())
	t.Nth6(*s.Nth6())
	t.Nth7(*s.Nth7())
	return *t
}

type OutPointBytesBuilder struct {
	inner [24]Byte
}

func NewOutPointBytesBuilder() *OutPointBytesBuilder {
	return &OutPointBytesBuilder{inner: [24]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *OutPointBytesBuilder) Build() OutPointBytes {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return OutPointBytes{inner: b.Bytes()}
}

func (s *OutPointBytesBuilder) Set(v [24]Byte) *OutPointBytesBuilder {
	s.inner = v
	return s
}

func (s *OutPointBytesBuilder) Nth0(v Byte) *OutPointBytesBuilder {
	s.inner[0] = v
	return s
}

func (s *OutPointBytesBuilder) Nth1(v Byte) *OutPointBytesBuilder {
	s.inner[1] = v
	return s
}

func (s *OutPointBytesBuilder) Nth2(v Byte) *OutPointBytesBuilder {
	s.inner[2] = v
	return s
}

func (s *OutPointBytesBuilder) Nth3(v Byte) *OutPointBytesBuilder {
	s.inner[3] = v
	return s
}

func (s *OutPointBytesBuilder) Nth4(v Byte) *OutPointBytesBuilder {
	s.inner[4] = v
	return s
}

func (s *OutPointBytesBuilder) Nth5(v Byte) *OutPointBytesBuilder {
	s.inner[5] = v
	return s
}

func (s *OutPointBytesBuilder) Nth6(v Byte) *OutPointBytesBuilder {
	s.inner[6] = v
	return s
}

func (s *OutPointBytesBuilder) Nth7(v Byte) *OutPointBytesBuilder {
	s.inner[7] = v
	return s
}

func (s *OutPointBytesBuilder) Nth8(v Byte) *OutPointBytesBuilder {
	s.inner[8] = v
	return s
}

func (s *OutPointBytesBuilder) Nth9(v Byte) *OutPointBytesBuilder {
	s.inner[9] = v
	return s
}

func (s *OutPointBytesBuilder) Nth10(v Byte) *OutPointBytesBuilder {
	s.inner[10] = v
	return s
}

func (s *OutPointBytesBuilder) Nth11(v Byte) *OutPointBytesBuilder {
	s.inner[11] = v
	return s
}

func (s *OutPointBytesBuilder) Nth12(v Byte) *OutPointBytesBuilder {
	s.inner[12] = v
	return s
}

func (s *OutPointBytesBuilder) Nth13(v Byte) *OutPointBytesBuilder {
	s.inner[13] = v
	return s
}

func (s *OutPointBytesBuilder) Nth14(v Byte) *OutPointBytesBuilder {
	s.inner[14] = v
	return s
}

func (s *OutPointBytesBuilder) Nth15(v Byte) *OutPointBytesBuilder {
	s.inner[15] = v
	return s
}

func (s *OutPointBytesBuilder) Nth16(v Byte) *OutPointBytesBuilder {
	s.inner[16] = v
	return s
}

func (s *OutPointBytesBuilder) Nth17(v Byte) *OutPointBytesBuilder {
	s.inner[17] = v
	return s
}

func (s *OutPointBytesBuilder) Nth18(v Byte) *OutPointBytesBuilder {
	s.inner[18] = v
	return s
}

func (s *OutPointBytesBuilder) Nth19(v Byte) *OutPointBytesBuilder {
	s.inner[19] = v
	return s
}

func (s *OutPointBytesBuilder) Nth20(v Byte) *OutPointBytesBuilder {
	s.inner[20] = v
	return s
}

func (s *OutPointBytesBuilder) Nth21(v Byte) *OutPointBytesBuilder {
	s.inner[21] = v
	return s
}

func (s *OutPointBytesBuilder) Nth22(v Byte) *OutPointBytesBuilder {
	s.inner[22] = v
	return s
}

func (s *OutPointBytesBuilder) Nth23(v Byte) *OutPointBytesBuilder {
	s.inner[23] = v
	return s
}

type OutPointBytes struct {
	inner []byte
}

func OutPointBytesFromSliceUnchecked(slice []byte) *OutPointBytes {
	return &OutPointBytes{inner: slice}
}
func (s *OutPointBytes) AsSlice() []byte {
	return s.inner
}

func OutPointBytesDefault() OutPointBytes {
	return *OutPointBytesFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func OutPointBytesFromSlice(slice []byte, _compatible bool) (*OutPointBytes, error) {
	sliceLen := len(slice)
	if sliceLen != 24 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "OutPointBytes", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(24)}, " ")
		return nil, errors.New(errMsg)
	}
	return &OutPointBytes{inner: slice}, nil
}

func (s *OutPointBytes) RawData() []byte {
	return s.inner
}

func (s *OutPointBytes) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *OutPointBytes) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *OutPointBytes) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *OutPointBytes) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *OutPointBytes) Nth4() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *OutPointBytes) Nth5() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *OutPointBytes) Nth6() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *OutPointBytes) Nth7() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *OutPointBytes) Nth8() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *OutPointBytes) Nth9() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *OutPointBytes) Nth10() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *OutPointBytes) Nth11() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *OutPointBytes) Nth12() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *OutPointBytes) Nth13() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *OutPointBytes) Nth14() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *OutPointBytes) Nth15() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *OutPointBytes) Nth16() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[16:17])
	return ret
}

func (s *OutPointBytes) Nth17() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[17:18])
	return ret
}

func (s *OutPointBytes) Nth18() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[18:19])
	return ret
}

func (s *OutPointBytes) Nth19() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[19:20])
	return ret
}

func (s *OutPointBytes) Nth20() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[20:21])
	return ret
}

func (s *OutPointBytes) Nth21() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[21:22])
	return ret
}

func (s *OutPointBytes) Nth22() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[22:23])
	return ret
}

func (s *OutPointBytes) Nth23() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[23:24])
	return ret
}

func (s *OutPointBytes) AsBuilder() OutPointBytesBuilder {
	t := NewOutPointBytesBuilder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	t.Nth4(*s.Nth4())
	t.Nth5(*s.Nth5())
	t.Nth6(*s.Nth6())
	t.Nth7(*s.Nth7())
	t.Nth8(*s.Nth8())
	t.Nth9(*s.Nth9())
	t.Nth10(*s.Nth10())
	t.Nth11(*s.Nth11())
	t.Nth12(*s.Nth12())
	t.Nth13(*s.Nth13())
	t.Nth14(*s.Nth14())
	t.Nth15(*s.Nth15())
	t.Nth16(*s.Nth16())
	t.Nth17(*s.Nth17())
	t.Nth18(*s.Nth18())
	t.Nth19(*s.Nth19())
	t.Nth20(*s.Nth20())
	t.Nth21(*s.Nth21())
	t.Nth22(*s.Nth22())
	t.Nth23(*s.Nth23())
	return *t
}

type LockHashBuilder struct {
	inner [20]Byte
}

func NewLockHashBuilder() *LockHashBuilder {
	return &LockHashBuilder{inner: [20]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *LockHashBuilder) Build() LockHash {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return LockHash{inner: b.Bytes()}
}

func (s *LockHashBuilder) Set(v [20]Byte) *LockHashBuilder {
	s.inner = v
	return s
}

func (s *LockHashBuilder) Nth0(v Byte) *LockHashBuilder {
	s.inner[0] = v
	return s
}

func (s *LockHashBuilder) Nth1(v Byte) *LockHashBuilder {
	s.inner[1] = v
	return s
}

func (s *LockHashBuilder) Nth2(v Byte) *LockHashBuilder {
	s.inner[2] = v
	return s
}

func (s *LockHashBuilder) Nth3(v Byte) *LockHashBuilder {
	s.inner[3] = v
	return s
}

func (s *LockHashBuilder) Nth4(v Byte) *LockHashBuilder {
	s.inner[4] = v
	return s
}

func (s *LockHashBuilder) Nth5(v Byte) *LockHashBuilder {
	s.inner[5] = v
	return s
}

func (s *LockHashBuilder) Nth6(v Byte) *LockHashBuilder {
	s.inner[6] = v
	return s
}

func (s *LockHashBuilder) Nth7(v Byte) *LockHashBuilder {
	s.inner[7] = v
	return s
}

func (s *LockHashBuilder) Nth8(v Byte) *LockHashBuilder {
	s.inner[8] = v
	return s
}

func (s *LockHashBuilder) Nth9(v Byte) *LockHashBuilder {
	s.inner[9] = v
	return s
}

func (s *LockHashBuilder) Nth10(v Byte) *LockHashBuilder {
	s.inner[10] = v
	return s
}

func (s *LockHashBuilder) Nth11(v Byte) *LockHashBuilder {
	s.inner[11] = v
	return s
}

func (s *LockHashBuilder) Nth12(v Byte) *LockHashBuilder {
	s.inner[12] = v
	return s
}

func (s *LockHashBuilder) Nth13(v Byte) *LockHashBuilder {
	s.inner[13] = v
	return s
}

func (s *LockHashBuilder) Nth14(v Byte) *LockHashBuilder {
	s.inner[14] = v
	return s
}

func (s *LockHashBuilder) Nth15(v Byte) *LockHashBuilder {
	s.inner[15] = v
	return s
}

func (s *LockHashBuilder) Nth16(v Byte) *LockHashBuilder {
	s.inner[16] = v
	return s
}

func (s *LockHashBuilder) Nth17(v Byte) *LockHashBuilder {
	s.inner[17] = v
	return s
}

func (s *LockHashBuilder) Nth18(v Byte) *LockHashBuilder {
	s.inner[18] = v
	return s
}

func (s *LockHashBuilder) Nth19(v Byte) *LockHashBuilder {
	s.inner[19] = v
	return s
}

type LockHash struct {
	inner []byte
}

func LockHashFromSliceUnchecked(slice []byte) *LockHash {
	return &LockHash{inner: slice}
}
func (s *LockHash) AsSlice() []byte {
	return s.inner
}

func LockHashDefault() LockHash {
	return *LockHashFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func LockHashFromSlice(slice []byte, _compatible bool) (*LockHash, error) {
	sliceLen := len(slice)
	if sliceLen != 20 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "LockHash", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(20)}, " ")
		return nil, errors.New(errMsg)
	}
	return &LockHash{inner: slice}, nil
}

func (s *LockHash) RawData() []byte {
	return s.inner
}

func (s *LockHash) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *LockHash) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *LockHash) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *LockHash) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *LockHash) Nth4() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *LockHash) Nth5() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *LockHash) Nth6() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *LockHash) Nth7() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *LockHash) Nth8() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *LockHash) Nth9() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *LockHash) Nth10() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *LockHash) Nth11() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *LockHash) Nth12() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *LockHash) Nth13() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *LockHash) Nth14() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *LockHash) Nth15() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *LockHash) Nth16() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[16:17])
	return ret
}

func (s *LockHash) Nth17() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[17:18])
	return ret
}

func (s *LockHash) Nth18() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[18:19])
	return ret
}

func (s *LockHash) Nth19() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[19:20])
	return ret
}

func (s *LockHash) AsBuilder() LockHashBuilder {
	t := NewLockHashBuilder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	t.Nth4(*s.Nth4())
	t.Nth5(*s.Nth5())
	t.Nth6(*s.Nth6())
	t.Nth7(*s.Nth7())
	t.Nth8(*s.Nth8())
	t.Nth9(*s.Nth9())
	t.Nth10(*s.Nth10())
	t.Nth11(*s.Nth11())
	t.Nth12(*s.Nth12())
	t.Nth13(*s.Nth13())
	t.Nth14(*s.Nth14())
	t.Nth15(*s.Nth15())
	t.Nth16(*s.Nth16())
	t.Nth17(*s.Nth17())
	t.Nth18(*s.Nth18())
	t.Nth19(*s.Nth19())
	return *t
}

type CompactNFTIdBuilder struct {
	issuerId IssuerId
	classId  Uint32
	tokenId  Uint32
}

func (s *CompactNFTIdBuilder) Build() CompactNFTId {
	b := new(bytes.Buffer)
	b.Write(s.issuerId.AsSlice())
	b.Write(s.classId.AsSlice())
	b.Write(s.tokenId.AsSlice())
	return CompactNFTId{inner: b.Bytes()}
}

func (s *CompactNFTIdBuilder) IssuerId(v IssuerId) *CompactNFTIdBuilder {
	s.issuerId = v
	return s
}

func (s *CompactNFTIdBuilder) ClassId(v Uint32) *CompactNFTIdBuilder {
	s.classId = v
	return s
}

func (s *CompactNFTIdBuilder) TokenId(v Uint32) *CompactNFTIdBuilder {
	s.tokenId = v
	return s
}

func NewCompactNFTIdBuilder() *CompactNFTIdBuilder {
	return &CompactNFTIdBuilder{issuerId: IssuerIdDefault(), classId: Uint32Default(), tokenId: Uint32Default()}
}

type CompactNFTId struct {
	inner []byte
}

func CompactNFTIdFromSliceUnchecked(slice []byte) *CompactNFTId {
	return &CompactNFTId{inner: slice}
}
func (s *CompactNFTId) AsSlice() []byte {
	return s.inner
}

func CompactNFTIdDefault() CompactNFTId {
	return *CompactNFTIdFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func CompactNFTIdFromSlice(slice []byte, _compatible bool) (*CompactNFTId, error) {
	sliceLen := len(slice)
	if sliceLen != 28 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CompactNFTId", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(28)}, " ")
		return nil, errors.New(errMsg)
	}
	return &CompactNFTId{inner: slice}, nil
}

func (s *CompactNFTId) IssuerId() *IssuerId {
	ret := IssuerIdFromSliceUnchecked(s.inner[0:20])
	return ret
}

func (s *CompactNFTId) ClassId() *Uint32 {
	ret := Uint32FromSliceUnchecked(s.inner[20:24])
	return ret
}

func (s *CompactNFTId) TokenId() *Uint32 {
	ret := Uint32FromSliceUnchecked(s.inner[24:28])
	return ret
}

func (s *CompactNFTId) AsBuilder() CompactNFTIdBuilder {
	ret := NewCompactNFTIdBuilder().IssuerId(*s.IssuerId()).ClassId(*s.ClassId()).TokenId(*s.TokenId())
	return *ret
}

type CompactNFTInfoBuilder struct {
	characteristic Characteristic
	configure      Byte
	state          Byte
}

func (s *CompactNFTInfoBuilder) Build() CompactNFTInfo {
	b := new(bytes.Buffer)
	b.Write(s.characteristic.AsSlice())
	b.Write(s.configure.AsSlice())
	b.Write(s.state.AsSlice())
	return CompactNFTInfo{inner: b.Bytes()}
}

func (s *CompactNFTInfoBuilder) Characteristic(v Characteristic) *CompactNFTInfoBuilder {
	s.characteristic = v
	return s
}

func (s *CompactNFTInfoBuilder) Configure(v Byte) *CompactNFTInfoBuilder {
	s.configure = v
	return s
}

func (s *CompactNFTInfoBuilder) State(v Byte) *CompactNFTInfoBuilder {
	s.state = v
	return s
}

func NewCompactNFTInfoBuilder() *CompactNFTInfoBuilder {
	return &CompactNFTInfoBuilder{characteristic: CharacteristicDefault(), configure: ByteDefault(), state: ByteDefault()}
}

type CompactNFTInfo struct {
	inner []byte
}

func CompactNFTInfoFromSliceUnchecked(slice []byte) *CompactNFTInfo {
	return &CompactNFTInfo{inner: slice}
}
func (s *CompactNFTInfo) AsSlice() []byte {
	return s.inner
}

func CompactNFTInfoDefault() CompactNFTInfo {
	return *CompactNFTInfoFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func CompactNFTInfoFromSlice(slice []byte, _compatible bool) (*CompactNFTInfo, error) {
	sliceLen := len(slice)
	if sliceLen != 10 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CompactNFTInfo", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(10)}, " ")
		return nil, errors.New(errMsg)
	}
	return &CompactNFTInfo{inner: slice}, nil
}

func (s *CompactNFTInfo) Characteristic() *Characteristic {
	ret := CharacteristicFromSliceUnchecked(s.inner[0:8])
	return ret
}

func (s *CompactNFTInfo) Configure() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *CompactNFTInfo) State() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *CompactNFTInfo) AsBuilder() CompactNFTInfoBuilder {
	ret := NewCompactNFTInfoBuilder().Characteristic(*s.Characteristic()).Configure(*s.Configure()).State(*s.State())
	return *ret
}

type KVPairBuilder struct {
	k Byte32
	v Byte32
}

func (s *KVPairBuilder) Build() KVPair {
	b := new(bytes.Buffer)
	b.Write(s.k.AsSlice())
	b.Write(s.v.AsSlice())
	return KVPair{inner: b.Bytes()}
}

func (s *KVPairBuilder) K(v Byte32) *KVPairBuilder {
	s.k = v
	return s
}

func (s *KVPairBuilder) V(v Byte32) *KVPairBuilder {
	s.v = v
	return s
}

func NewKVPairBuilder() *KVPairBuilder {
	return &KVPairBuilder{k: Byte32Default(), v: Byte32Default()}
}

type KVPair struct {
	inner []byte
}

func KVPairFromSliceUnchecked(slice []byte) *KVPair {
	return &KVPair{inner: slice}
}
func (s *KVPair) AsSlice() []byte {
	return s.inner
}

func KVPairDefault() KVPair {
	return *KVPairFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func KVPairFromSlice(slice []byte, _compatible bool) (*KVPair, error) {
	sliceLen := len(slice)
	if sliceLen != 64 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "KVPair", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(64)}, " ")
		return nil, errors.New(errMsg)
	}
	return &KVPair{inner: slice}, nil
}

func (s *KVPair) K() *Byte32 {
	ret := Byte32FromSliceUnchecked(s.inner[0:32])
	return ret
}

func (s *KVPair) V() *Byte32 {
	ret := Byte32FromSliceUnchecked(s.inner[32:64])
	return ret
}

func (s *KVPair) AsBuilder() KVPairBuilder {
	ret := NewKVPairBuilder().K(*s.K()).V(*s.V())
	return *ret
}

type KVPairVecBuilder struct {
	inner []KVPair
}

func (s *KVPairVecBuilder) Build() KVPairVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := KVPairVec{inner: b.Bytes()}

	return sb
}

func (s *KVPairVecBuilder) Set(v []KVPair) *KVPairVecBuilder {
	s.inner = v
	return s
}
func (s *KVPairVecBuilder) Push(v KVPair) *KVPairVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *KVPairVecBuilder) Extend(iter []KVPair) *KVPairVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewKVPairVecBuilder() *KVPairVecBuilder {
	return &KVPairVecBuilder{[]KVPair{}}
}

type KVPairVec struct {
	inner []byte
}

func KVPairVecFromSliceUnchecked(slice []byte) *KVPairVec {
	return &KVPairVec{inner: slice}
}
func (s *KVPairVec) AsSlice() []byte {
	return s.inner
}

func KVPairVecDefault() KVPairVec {
	return *KVPairVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func KVPairVecFromSlice(slice []byte, _compatible bool) (*KVPairVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "KVPairVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "KVPairVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &KVPairVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(64*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "KVPairVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &KVPairVec{inner: slice}, nil
}

func (s *KVPairVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 64*s.ItemCount()
}
func (s *KVPairVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *KVPairVec) Len() uint {
	return s.ItemCount()
}
func (s *KVPairVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *KVPair is nil, index is out of bounds
func (s *KVPairVec) Get(index uint) *KVPair {
	var re *KVPair
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 64*index
		end := start + 64
		re = KVPairFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *KVPairVec) AsBuilder() KVPairVecBuilder {
	size := s.ItemCount()
	t := NewKVPairVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type CompactNFTRegistryEntriesBuilder struct {
	kvState KVPairVec
	kvProof Bytes
}

func (s *CompactNFTRegistryEntriesBuilder) Build() CompactNFTRegistryEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.kvState.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.kvProof.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.kvState.AsSlice())
	b.Write(s.kvProof.AsSlice())
	return CompactNFTRegistryEntries{inner: b.Bytes()}
}

func (s *CompactNFTRegistryEntriesBuilder) KvState(v KVPairVec) *CompactNFTRegistryEntriesBuilder {
	s.kvState = v
	return s
}

func (s *CompactNFTRegistryEntriesBuilder) KvProof(v Bytes) *CompactNFTRegistryEntriesBuilder {
	s.kvProof = v
	return s
}

func NewCompactNFTRegistryEntriesBuilder() *CompactNFTRegistryEntriesBuilder {
	return &CompactNFTRegistryEntriesBuilder{kvState: KVPairVecDefault(), kvProof: BytesDefault()}
}

type CompactNFTRegistryEntries struct {
	inner []byte
}

func CompactNFTRegistryEntriesFromSliceUnchecked(slice []byte) *CompactNFTRegistryEntries {
	return &CompactNFTRegistryEntries{inner: slice}
}
func (s *CompactNFTRegistryEntries) AsSlice() []byte {
	return s.inner
}

func CompactNFTRegistryEntriesDefault() CompactNFTRegistryEntries {
	return *CompactNFTRegistryEntriesFromSliceUnchecked([]byte{20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func CompactNFTRegistryEntriesFromSlice(slice []byte, compatible bool) (*CompactNFTRegistryEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "CompactNFTRegistryEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CompactNFTRegistryEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
		return &CompactNFTRegistryEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CompactNFTRegistryEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "CompactNFTRegistryEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "CompactNFTRegistryEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = KVPairVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &CompactNFTRegistryEntries{inner: slice}, nil
}

func (s *CompactNFTRegistryEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *CompactNFTRegistryEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *CompactNFTRegistryEntries) Len() uint {
	return s.FieldCount()
}
func (s *CompactNFTRegistryEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *CompactNFTRegistryEntries) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *CompactNFTRegistryEntries) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *CompactNFTRegistryEntries) KvState() *KVPairVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return KVPairVecFromSliceUnchecked(s.inner[start:end])
}

func (s *CompactNFTRegistryEntries) KvProof() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *CompactNFTRegistryEntries) AsBuilder() CompactNFTRegistryEntriesBuilder {
	ret := NewCompactNFTRegistryEntriesBuilder().KvState(*s.KvState()).KvProof(*s.KvProof())
	return *ret
}

type MintCompactNFTKeyVecBuilder struct {
	inner []CompactNFTId
}

func (s *MintCompactNFTKeyVecBuilder) Build() MintCompactNFTKeyVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := MintCompactNFTKeyVec{inner: b.Bytes()}

	return sb
}

func (s *MintCompactNFTKeyVecBuilder) Set(v []CompactNFTId) *MintCompactNFTKeyVecBuilder {
	s.inner = v
	return s
}
func (s *MintCompactNFTKeyVecBuilder) Push(v CompactNFTId) *MintCompactNFTKeyVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *MintCompactNFTKeyVecBuilder) Extend(iter []CompactNFTId) *MintCompactNFTKeyVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewMintCompactNFTKeyVecBuilder() *MintCompactNFTKeyVecBuilder {
	return &MintCompactNFTKeyVecBuilder{[]CompactNFTId{}}
}

type MintCompactNFTKeyVec struct {
	inner []byte
}

func MintCompactNFTKeyVecFromSliceUnchecked(slice []byte) *MintCompactNFTKeyVec {
	return &MintCompactNFTKeyVec{inner: slice}
}
func (s *MintCompactNFTKeyVec) AsSlice() []byte {
	return s.inner
}

func MintCompactNFTKeyVecDefault() MintCompactNFTKeyVec {
	return *MintCompactNFTKeyVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func MintCompactNFTKeyVecFromSlice(slice []byte, _compatible bool) (*MintCompactNFTKeyVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "MintCompactNFTKeyVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "MintCompactNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &MintCompactNFTKeyVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(28*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "MintCompactNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &MintCompactNFTKeyVec{inner: slice}, nil
}

func (s *MintCompactNFTKeyVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 28*s.ItemCount()
}
func (s *MintCompactNFTKeyVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *MintCompactNFTKeyVec) Len() uint {
	return s.ItemCount()
}
func (s *MintCompactNFTKeyVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *CompactNFTId is nil, index is out of bounds
func (s *MintCompactNFTKeyVec) Get(index uint) *CompactNFTId {
	var re *CompactNFTId
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 28*index
		end := start + 28
		re = CompactNFTIdFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *MintCompactNFTKeyVec) AsBuilder() MintCompactNFTKeyVecBuilder {
	size := s.ItemCount()
	t := NewMintCompactNFTKeyVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type MintCompactNFTValueBuilder struct {
	nftInfo      CompactNFTInfo
	receiverLock Bytes
}

func (s *MintCompactNFTValueBuilder) Build() MintCompactNFTValue {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.nftInfo.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.receiverLock.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.nftInfo.AsSlice())
	b.Write(s.receiverLock.AsSlice())
	return MintCompactNFTValue{inner: b.Bytes()}
}

func (s *MintCompactNFTValueBuilder) NftInfo(v CompactNFTInfo) *MintCompactNFTValueBuilder {
	s.nftInfo = v
	return s
}

func (s *MintCompactNFTValueBuilder) ReceiverLock(v Bytes) *MintCompactNFTValueBuilder {
	s.receiverLock = v
	return s
}

func NewMintCompactNFTValueBuilder() *MintCompactNFTValueBuilder {
	return &MintCompactNFTValueBuilder{nftInfo: CompactNFTInfoDefault(), receiverLock: BytesDefault()}
}

type MintCompactNFTValue struct {
	inner []byte
}

func MintCompactNFTValueFromSliceUnchecked(slice []byte) *MintCompactNFTValue {
	return &MintCompactNFTValue{inner: slice}
}
func (s *MintCompactNFTValue) AsSlice() []byte {
	return s.inner
}

func MintCompactNFTValueDefault() MintCompactNFTValue {
	return *MintCompactNFTValueFromSliceUnchecked([]byte{26, 0, 0, 0, 12, 0, 0, 0, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func MintCompactNFTValueFromSlice(slice []byte, compatible bool) (*MintCompactNFTValue, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "MintCompactNFTValue", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "MintCompactNFTValue", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
		return &MintCompactNFTValue{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "MintCompactNFTValue", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "MintCompactNFTValue", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "MintCompactNFTValue", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = CompactNFTInfoFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &MintCompactNFTValue{inner: slice}, nil
}

func (s *MintCompactNFTValue) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *MintCompactNFTValue) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *MintCompactNFTValue) Len() uint {
	return s.FieldCount()
}
func (s *MintCompactNFTValue) IsEmpty() bool {
	return s.Len() == 0
}
func (s *MintCompactNFTValue) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *MintCompactNFTValue) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *MintCompactNFTValue) NftInfo() *CompactNFTInfo {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return CompactNFTInfoFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCompactNFTValue) ReceiverLock() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *MintCompactNFTValue) AsBuilder() MintCompactNFTValueBuilder {
	ret := NewMintCompactNFTValueBuilder().NftInfo(*s.NftInfo()).ReceiverLock(*s.ReceiverLock())
	return *ret
}

type MintCompactNFTValueVecBuilder struct {
	inner []MintCompactNFTValue
}

func (s *MintCompactNFTValueVecBuilder) Build() MintCompactNFTValueVec {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return MintCompactNFTValueVec{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return MintCompactNFTValueVec{inner: b.Bytes()}
}

func (s *MintCompactNFTValueVecBuilder) Set(v []MintCompactNFTValue) *MintCompactNFTValueVecBuilder {
	s.inner = v
	return s
}
func (s *MintCompactNFTValueVecBuilder) Push(v MintCompactNFTValue) *MintCompactNFTValueVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *MintCompactNFTValueVecBuilder) Extend(iter []MintCompactNFTValue) *MintCompactNFTValueVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewMintCompactNFTValueVecBuilder() *MintCompactNFTValueVecBuilder {
	return &MintCompactNFTValueVecBuilder{[]MintCompactNFTValue{}}
}

type MintCompactNFTValueVec struct {
	inner []byte
}

func MintCompactNFTValueVecFromSliceUnchecked(slice []byte) *MintCompactNFTValueVec {
	return &MintCompactNFTValueVec{inner: slice}
}
func (s *MintCompactNFTValueVec) AsSlice() []byte {
	return s.inner
}

func MintCompactNFTValueVecDefault() MintCompactNFTValueVec {
	return *MintCompactNFTValueVecFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func MintCompactNFTValueVecFromSlice(slice []byte, compatible bool) (*MintCompactNFTValueVec, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "MintCompactNFTValueVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "MintCompactNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &MintCompactNFTValueVec{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "MintCompactNFTValueVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "MintCompactNFTValueVec", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "MintCompactNFTValueVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "MintCompactNFTValueVec"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := MintCompactNFTValueFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &MintCompactNFTValueVec{inner: slice}, nil
}

func (s *MintCompactNFTValueVec) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *MintCompactNFTValueVec) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *MintCompactNFTValueVec) Len() uint {
	return s.ItemCount()
}
func (s *MintCompactNFTValueVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *MintCompactNFTValue is nil, index is out of bounds
func (s *MintCompactNFTValueVec) Get(index uint) *MintCompactNFTValue {
	var b *MintCompactNFTValue
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = MintCompactNFTValueFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = MintCompactNFTValueFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *MintCompactNFTValueVec) AsBuilder() MintCompactNFTValueVecBuilder {
	size := s.ItemCount()
	t := NewMintCompactNFTValueVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type MintCompactNFTEntriesBuilder struct {
	nftKeys   MintCompactNFTKeyVec
	nftValues MintCompactNFTValueVec
	proof     Bytes
}

func (s *MintCompactNFTEntriesBuilder) Build() MintCompactNFTEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.nftKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.nftValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.nftKeys.AsSlice())
	b.Write(s.nftValues.AsSlice())
	b.Write(s.proof.AsSlice())
	return MintCompactNFTEntries{inner: b.Bytes()}
}

func (s *MintCompactNFTEntriesBuilder) NftKeys(v MintCompactNFTKeyVec) *MintCompactNFTEntriesBuilder {
	s.nftKeys = v
	return s
}

func (s *MintCompactNFTEntriesBuilder) NftValues(v MintCompactNFTValueVec) *MintCompactNFTEntriesBuilder {
	s.nftValues = v
	return s
}

func (s *MintCompactNFTEntriesBuilder) Proof(v Bytes) *MintCompactNFTEntriesBuilder {
	s.proof = v
	return s
}

func NewMintCompactNFTEntriesBuilder() *MintCompactNFTEntriesBuilder {
	return &MintCompactNFTEntriesBuilder{nftKeys: MintCompactNFTKeyVecDefault(), nftValues: MintCompactNFTValueVecDefault(), proof: BytesDefault()}
}

type MintCompactNFTEntries struct {
	inner []byte
}

func MintCompactNFTEntriesFromSliceUnchecked(slice []byte) *MintCompactNFTEntries {
	return &MintCompactNFTEntries{inner: slice}
}
func (s *MintCompactNFTEntries) AsSlice() []byte {
	return s.inner
}

func MintCompactNFTEntriesDefault() MintCompactNFTEntries {
	return *MintCompactNFTEntriesFromSliceUnchecked([]byte{28, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0})
}

func MintCompactNFTEntriesFromSlice(slice []byte, compatible bool) (*MintCompactNFTEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "MintCompactNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "MintCompactNFTEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 3 == 0 {
		return &MintCompactNFTEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "MintCompactNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "MintCompactNFTEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "MintCompactNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = MintCompactNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = MintCompactNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &MintCompactNFTEntries{inner: slice}, nil
}

func (s *MintCompactNFTEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *MintCompactNFTEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *MintCompactNFTEntries) Len() uint {
	return s.FieldCount()
}
func (s *MintCompactNFTEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *MintCompactNFTEntries) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *MintCompactNFTEntries) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *MintCompactNFTEntries) NftKeys() *MintCompactNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return MintCompactNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCompactNFTEntries) NftValues() *MintCompactNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return MintCompactNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCompactNFTEntries) Proof() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *MintCompactNFTEntries) AsBuilder() MintCompactNFTEntriesBuilder {
	ret := NewMintCompactNFTEntriesBuilder().NftKeys(*s.NftKeys()).NftValues(*s.NftValues()).Proof(*s.Proof())
	return *ret
}

type CompactNFTKeyBuilder struct {
	smtType Byte
	nftId   CompactNFTId
}

func (s *CompactNFTKeyBuilder) Build() CompactNFTKey {
	b := new(bytes.Buffer)
	b.Write(s.smtType.AsSlice())
	b.Write(s.nftId.AsSlice())
	return CompactNFTKey{inner: b.Bytes()}
}

func (s *CompactNFTKeyBuilder) SmtType(v Byte) *CompactNFTKeyBuilder {
	s.smtType = v
	return s
}

func (s *CompactNFTKeyBuilder) NftId(v CompactNFTId) *CompactNFTKeyBuilder {
	s.nftId = v
	return s
}

func NewCompactNFTKeyBuilder() *CompactNFTKeyBuilder {
	return &CompactNFTKeyBuilder{smtType: ByteDefault(), nftId: CompactNFTIdDefault()}
}

type CompactNFTKey struct {
	inner []byte
}

func CompactNFTKeyFromSliceUnchecked(slice []byte) *CompactNFTKey {
	return &CompactNFTKey{inner: slice}
}
func (s *CompactNFTKey) AsSlice() []byte {
	return s.inner
}

func CompactNFTKeyDefault() CompactNFTKey {
	return *CompactNFTKeyFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func CompactNFTKeyFromSlice(slice []byte, _compatible bool) (*CompactNFTKey, error) {
	sliceLen := len(slice)
	if sliceLen != 29 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CompactNFTKey", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(29)}, " ")
		return nil, errors.New(errMsg)
	}
	return &CompactNFTKey{inner: slice}, nil
}

func (s *CompactNFTKey) SmtType() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *CompactNFTKey) NftId() *CompactNFTId {
	ret := CompactNFTIdFromSliceUnchecked(s.inner[1:29])
	return ret
}

func (s *CompactNFTKey) AsBuilder() CompactNFTKeyBuilder {
	ret := NewCompactNFTKeyBuilder().SmtType(*s.SmtType()).NftId(*s.NftId())
	return *ret
}

type CompactNFTKeyVecBuilder struct {
	inner []CompactNFTKey
}

func (s *CompactNFTKeyVecBuilder) Build() CompactNFTKeyVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := CompactNFTKeyVec{inner: b.Bytes()}

	return sb
}

func (s *CompactNFTKeyVecBuilder) Set(v []CompactNFTKey) *CompactNFTKeyVecBuilder {
	s.inner = v
	return s
}
func (s *CompactNFTKeyVecBuilder) Push(v CompactNFTKey) *CompactNFTKeyVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *CompactNFTKeyVecBuilder) Extend(iter []CompactNFTKey) *CompactNFTKeyVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewCompactNFTKeyVecBuilder() *CompactNFTKeyVecBuilder {
	return &CompactNFTKeyVecBuilder{[]CompactNFTKey{}}
}

type CompactNFTKeyVec struct {
	inner []byte
}

func CompactNFTKeyVecFromSliceUnchecked(slice []byte) *CompactNFTKeyVec {
	return &CompactNFTKeyVec{inner: slice}
}
func (s *CompactNFTKeyVec) AsSlice() []byte {
	return s.inner
}

func CompactNFTKeyVecDefault() CompactNFTKeyVec {
	return *CompactNFTKeyVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func CompactNFTKeyVecFromSlice(slice []byte, _compatible bool) (*CompactNFTKeyVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "CompactNFTKeyVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "CompactNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &CompactNFTKeyVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(29*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CompactNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &CompactNFTKeyVec{inner: slice}, nil
}

func (s *CompactNFTKeyVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 29*s.ItemCount()
}
func (s *CompactNFTKeyVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *CompactNFTKeyVec) Len() uint {
	return s.ItemCount()
}
func (s *CompactNFTKeyVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *CompactNFTKey is nil, index is out of bounds
func (s *CompactNFTKeyVec) Get(index uint) *CompactNFTKey {
	var re *CompactNFTKey
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 29*index
		end := start + 29
		re = CompactNFTKeyFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *CompactNFTKeyVec) AsBuilder() CompactNFTKeyVecBuilder {
	size := s.ItemCount()
	t := NewCompactNFTKeyVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type ClaimedCompactNFTKeyBuilder struct {
	nftKey   CompactNFTKey
	outPoint OutPointBytes
}

func (s *ClaimedCompactNFTKeyBuilder) Build() ClaimedCompactNFTKey {
	b := new(bytes.Buffer)
	b.Write(s.nftKey.AsSlice())
	b.Write(s.outPoint.AsSlice())
	return ClaimedCompactNFTKey{inner: b.Bytes()}
}

func (s *ClaimedCompactNFTKeyBuilder) NftKey(v CompactNFTKey) *ClaimedCompactNFTKeyBuilder {
	s.nftKey = v
	return s
}

func (s *ClaimedCompactNFTKeyBuilder) OutPoint(v OutPointBytes) *ClaimedCompactNFTKeyBuilder {
	s.outPoint = v
	return s
}

func NewClaimedCompactNFTKeyBuilder() *ClaimedCompactNFTKeyBuilder {
	return &ClaimedCompactNFTKeyBuilder{nftKey: CompactNFTKeyDefault(), outPoint: OutPointBytesDefault()}
}

type ClaimedCompactNFTKey struct {
	inner []byte
}

func ClaimedCompactNFTKeyFromSliceUnchecked(slice []byte) *ClaimedCompactNFTKey {
	return &ClaimedCompactNFTKey{inner: slice}
}
func (s *ClaimedCompactNFTKey) AsSlice() []byte {
	return s.inner
}

func ClaimedCompactNFTKeyDefault() ClaimedCompactNFTKey {
	return *ClaimedCompactNFTKeyFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ClaimedCompactNFTKeyFromSlice(slice []byte, _compatible bool) (*ClaimedCompactNFTKey, error) {
	sliceLen := len(slice)
	if sliceLen != 53 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimedCompactNFTKey", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(53)}, " ")
		return nil, errors.New(errMsg)
	}
	return &ClaimedCompactNFTKey{inner: slice}, nil
}

func (s *ClaimedCompactNFTKey) NftKey() *CompactNFTKey {
	ret := CompactNFTKeyFromSliceUnchecked(s.inner[0:29])
	return ret
}

func (s *ClaimedCompactNFTKey) OutPoint() *OutPointBytes {
	ret := OutPointBytesFromSliceUnchecked(s.inner[29:53])
	return ret
}

func (s *ClaimedCompactNFTKey) AsBuilder() ClaimedCompactNFTKeyBuilder {
	ret := NewClaimedCompactNFTKeyBuilder().NftKey(*s.NftKey()).OutPoint(*s.OutPoint())
	return *ret
}

type ClaimedCompactNFTKeyVecBuilder struct {
	inner []ClaimedCompactNFTKey
}

func (s *ClaimedCompactNFTKeyVecBuilder) Build() ClaimedCompactNFTKeyVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := ClaimedCompactNFTKeyVec{inner: b.Bytes()}

	return sb
}

func (s *ClaimedCompactNFTKeyVecBuilder) Set(v []ClaimedCompactNFTKey) *ClaimedCompactNFTKeyVecBuilder {
	s.inner = v
	return s
}
func (s *ClaimedCompactNFTKeyVecBuilder) Push(v ClaimedCompactNFTKey) *ClaimedCompactNFTKeyVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *ClaimedCompactNFTKeyVecBuilder) Extend(iter []ClaimedCompactNFTKey) *ClaimedCompactNFTKeyVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewClaimedCompactNFTKeyVecBuilder() *ClaimedCompactNFTKeyVecBuilder {
	return &ClaimedCompactNFTKeyVecBuilder{[]ClaimedCompactNFTKey{}}
}

type ClaimedCompactNFTKeyVec struct {
	inner []byte
}

func ClaimedCompactNFTKeyVecFromSliceUnchecked(slice []byte) *ClaimedCompactNFTKeyVec {
	return &ClaimedCompactNFTKeyVec{inner: slice}
}
func (s *ClaimedCompactNFTKeyVec) AsSlice() []byte {
	return s.inner
}

func ClaimedCompactNFTKeyVecDefault() ClaimedCompactNFTKeyVec {
	return *ClaimedCompactNFTKeyVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func ClaimedCompactNFTKeyVecFromSlice(slice []byte, _compatible bool) (*ClaimedCompactNFTKeyVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimedCompactNFTKeyVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimedCompactNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &ClaimedCompactNFTKeyVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(53*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimedCompactNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &ClaimedCompactNFTKeyVec{inner: slice}, nil
}

func (s *ClaimedCompactNFTKeyVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 53*s.ItemCount()
}
func (s *ClaimedCompactNFTKeyVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *ClaimedCompactNFTKeyVec) Len() uint {
	return s.ItemCount()
}
func (s *ClaimedCompactNFTKeyVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *ClaimedCompactNFTKey is nil, index is out of bounds
func (s *ClaimedCompactNFTKeyVec) Get(index uint) *ClaimedCompactNFTKey {
	var re *ClaimedCompactNFTKey
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 53*index
		end := start + 53
		re = ClaimedCompactNFTKeyFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *ClaimedCompactNFTKeyVec) AsBuilder() ClaimedCompactNFTKeyVecBuilder {
	size := s.ItemCount()
	t := NewClaimedCompactNFTKeyVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type OwnedCompactNFTValueVecBuilder struct {
	inner []CompactNFTInfo
}

func (s *OwnedCompactNFTValueVecBuilder) Build() OwnedCompactNFTValueVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := OwnedCompactNFTValueVec{inner: b.Bytes()}

	return sb
}

func (s *OwnedCompactNFTValueVecBuilder) Set(v []CompactNFTInfo) *OwnedCompactNFTValueVecBuilder {
	s.inner = v
	return s
}
func (s *OwnedCompactNFTValueVecBuilder) Push(v CompactNFTInfo) *OwnedCompactNFTValueVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *OwnedCompactNFTValueVecBuilder) Extend(iter []CompactNFTInfo) *OwnedCompactNFTValueVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewOwnedCompactNFTValueVecBuilder() *OwnedCompactNFTValueVecBuilder {
	return &OwnedCompactNFTValueVecBuilder{[]CompactNFTInfo{}}
}

type OwnedCompactNFTValueVec struct {
	inner []byte
}

func OwnedCompactNFTValueVecFromSliceUnchecked(slice []byte) *OwnedCompactNFTValueVec {
	return &OwnedCompactNFTValueVec{inner: slice}
}
func (s *OwnedCompactNFTValueVec) AsSlice() []byte {
	return s.inner
}

func OwnedCompactNFTValueVecDefault() OwnedCompactNFTValueVec {
	return *OwnedCompactNFTValueVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func OwnedCompactNFTValueVecFromSlice(slice []byte, _compatible bool) (*OwnedCompactNFTValueVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "OwnedCompactNFTValueVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "OwnedCompactNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &OwnedCompactNFTValueVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(10*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "OwnedCompactNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &OwnedCompactNFTValueVec{inner: slice}, nil
}

func (s *OwnedCompactNFTValueVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 10*s.ItemCount()
}
func (s *OwnedCompactNFTValueVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *OwnedCompactNFTValueVec) Len() uint {
	return s.ItemCount()
}
func (s *OwnedCompactNFTValueVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *CompactNFTInfo is nil, index is out of bounds
func (s *OwnedCompactNFTValueVec) Get(index uint) *CompactNFTInfo {
	var re *CompactNFTInfo
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 10*index
		end := start + 10
		re = CompactNFTInfoFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *OwnedCompactNFTValueVec) AsBuilder() OwnedCompactNFTValueVecBuilder {
	size := s.ItemCount()
	t := NewOwnedCompactNFTValueVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type ClaimedCommpactNFTValueVecBuilder struct {
	inner []Byte32
}

func (s *ClaimedCommpactNFTValueVecBuilder) Build() ClaimedCommpactNFTValueVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := ClaimedCommpactNFTValueVec{inner: b.Bytes()}

	return sb
}

func (s *ClaimedCommpactNFTValueVecBuilder) Set(v []Byte32) *ClaimedCommpactNFTValueVecBuilder {
	s.inner = v
	return s
}
func (s *ClaimedCommpactNFTValueVecBuilder) Push(v Byte32) *ClaimedCommpactNFTValueVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *ClaimedCommpactNFTValueVecBuilder) Extend(iter []Byte32) *ClaimedCommpactNFTValueVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewClaimedCommpactNFTValueVecBuilder() *ClaimedCommpactNFTValueVecBuilder {
	return &ClaimedCommpactNFTValueVecBuilder{[]Byte32{}}
}

type ClaimedCommpactNFTValueVec struct {
	inner []byte
}

func ClaimedCommpactNFTValueVecFromSliceUnchecked(slice []byte) *ClaimedCommpactNFTValueVec {
	return &ClaimedCommpactNFTValueVec{inner: slice}
}
func (s *ClaimedCommpactNFTValueVec) AsSlice() []byte {
	return s.inner
}

func ClaimedCommpactNFTValueVecDefault() ClaimedCommpactNFTValueVec {
	return *ClaimedCommpactNFTValueVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func ClaimedCommpactNFTValueVecFromSlice(slice []byte, _compatible bool) (*ClaimedCommpactNFTValueVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimedCommpactNFTValueVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimedCommpactNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &ClaimedCommpactNFTValueVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(32*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimedCommpactNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &ClaimedCommpactNFTValueVec{inner: slice}, nil
}

func (s *ClaimedCommpactNFTValueVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 32*s.ItemCount()
}
func (s *ClaimedCommpactNFTValueVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *ClaimedCommpactNFTValueVec) Len() uint {
	return s.ItemCount()
}
func (s *ClaimedCommpactNFTValueVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *Byte32 is nil, index is out of bounds
func (s *ClaimedCommpactNFTValueVec) Get(index uint) *Byte32 {
	var re *Byte32
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 32*index
		end := start + 32
		re = Byte32FromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *ClaimedCommpactNFTValueVec) AsBuilder() ClaimedCommpactNFTValueVecBuilder {
	size := s.ItemCount()
	t := NewClaimedCommpactNFTValueVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type WithdrawCompactNFTValueBuilder struct {
	nftInfo  CompactNFTInfo
	to       LockHash
	outPoint OutPointBytes
}

func (s *WithdrawCompactNFTValueBuilder) Build() WithdrawCompactNFTValue {
	b := new(bytes.Buffer)
	b.Write(s.nftInfo.AsSlice())
	b.Write(s.to.AsSlice())
	b.Write(s.outPoint.AsSlice())
	return WithdrawCompactNFTValue{inner: b.Bytes()}
}

func (s *WithdrawCompactNFTValueBuilder) NftInfo(v CompactNFTInfo) *WithdrawCompactNFTValueBuilder {
	s.nftInfo = v
	return s
}

func (s *WithdrawCompactNFTValueBuilder) To(v LockHash) *WithdrawCompactNFTValueBuilder {
	s.to = v
	return s
}

func (s *WithdrawCompactNFTValueBuilder) OutPoint(v OutPointBytes) *WithdrawCompactNFTValueBuilder {
	s.outPoint = v
	return s
}

func NewWithdrawCompactNFTValueBuilder() *WithdrawCompactNFTValueBuilder {
	return &WithdrawCompactNFTValueBuilder{nftInfo: CompactNFTInfoDefault(), to: LockHashDefault(), outPoint: OutPointBytesDefault()}
}

type WithdrawCompactNFTValue struct {
	inner []byte
}

func WithdrawCompactNFTValueFromSliceUnchecked(slice []byte) *WithdrawCompactNFTValue {
	return &WithdrawCompactNFTValue{inner: slice}
}
func (s *WithdrawCompactNFTValue) AsSlice() []byte {
	return s.inner
}

func WithdrawCompactNFTValueDefault() WithdrawCompactNFTValue {
	return *WithdrawCompactNFTValueFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func WithdrawCompactNFTValueFromSlice(slice []byte, _compatible bool) (*WithdrawCompactNFTValue, error) {
	sliceLen := len(slice)
	if sliceLen != 54 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawCompactNFTValue", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(54)}, " ")
		return nil, errors.New(errMsg)
	}
	return &WithdrawCompactNFTValue{inner: slice}, nil
}

func (s *WithdrawCompactNFTValue) NftInfo() *CompactNFTInfo {
	ret := CompactNFTInfoFromSliceUnchecked(s.inner[0:10])
	return ret
}

func (s *WithdrawCompactNFTValue) To() *LockHash {
	ret := LockHashFromSliceUnchecked(s.inner[10:30])
	return ret
}

func (s *WithdrawCompactNFTValue) OutPoint() *OutPointBytes {
	ret := OutPointBytesFromSliceUnchecked(s.inner[30:54])
	return ret
}

func (s *WithdrawCompactNFTValue) AsBuilder() WithdrawCompactNFTValueBuilder {
	ret := NewWithdrawCompactNFTValueBuilder().NftInfo(*s.NftInfo()).To(*s.To()).OutPoint(*s.OutPoint())
	return *ret
}

type WithdrawCompactNFTValueVecBuilder struct {
	inner []WithdrawCompactNFTValue
}

func (s *WithdrawCompactNFTValueVecBuilder) Build() WithdrawCompactNFTValueVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := WithdrawCompactNFTValueVec{inner: b.Bytes()}

	return sb
}

func (s *WithdrawCompactNFTValueVecBuilder) Set(v []WithdrawCompactNFTValue) *WithdrawCompactNFTValueVecBuilder {
	s.inner = v
	return s
}
func (s *WithdrawCompactNFTValueVecBuilder) Push(v WithdrawCompactNFTValue) *WithdrawCompactNFTValueVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *WithdrawCompactNFTValueVecBuilder) Extend(iter []WithdrawCompactNFTValue) *WithdrawCompactNFTValueVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewWithdrawCompactNFTValueVecBuilder() *WithdrawCompactNFTValueVecBuilder {
	return &WithdrawCompactNFTValueVecBuilder{[]WithdrawCompactNFTValue{}}
}

type WithdrawCompactNFTValueVec struct {
	inner []byte
}

func WithdrawCompactNFTValueVecFromSliceUnchecked(slice []byte) *WithdrawCompactNFTValueVec {
	return &WithdrawCompactNFTValueVec{inner: slice}
}
func (s *WithdrawCompactNFTValueVec) AsSlice() []byte {
	return s.inner
}

func WithdrawCompactNFTValueVecDefault() WithdrawCompactNFTValueVec {
	return *WithdrawCompactNFTValueVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func WithdrawCompactNFTValueVecFromSlice(slice []byte, _compatible bool) (*WithdrawCompactNFTValueVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawCompactNFTValueVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawCompactNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &WithdrawCompactNFTValueVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(54*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawCompactNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &WithdrawCompactNFTValueVec{inner: slice}, nil
}

func (s *WithdrawCompactNFTValueVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 54*s.ItemCount()
}
func (s *WithdrawCompactNFTValueVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *WithdrawCompactNFTValueVec) Len() uint {
	return s.ItemCount()
}
func (s *WithdrawCompactNFTValueVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *WithdrawCompactNFTValue is nil, index is out of bounds
func (s *WithdrawCompactNFTValueVec) Get(index uint) *WithdrawCompactNFTValue {
	var re *WithdrawCompactNFTValue
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 54*index
		end := start + 54
		re = WithdrawCompactNFTValueFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *WithdrawCompactNFTValueVec) AsBuilder() WithdrawCompactNFTValueVecBuilder {
	size := s.ItemCount()
	t := NewWithdrawCompactNFTValueVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type ClaimMintCompactNFTEntriesBuilder struct {
	ownedNftKeys     CompactNFTKeyVec
	ownedNftValues   OwnedCompactNFTValueVec
	claimedNftKeys   ClaimedCompactNFTKeyVec
	claimedNftValues ClaimedCommpactNFTValueVec
	proof            Bytes
	mintProof        Bytes
}

func (s *ClaimMintCompactNFTEntriesBuilder) Build() ClaimMintCompactNFTEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (6 + 1)
	offsets := make([]uint32, 0, 6)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.ownedNftKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.ownedNftValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claimedNftKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claimedNftValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.mintProof.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.ownedNftKeys.AsSlice())
	b.Write(s.ownedNftValues.AsSlice())
	b.Write(s.claimedNftKeys.AsSlice())
	b.Write(s.claimedNftValues.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.mintProof.AsSlice())
	return ClaimMintCompactNFTEntries{inner: b.Bytes()}
}

func (s *ClaimMintCompactNFTEntriesBuilder) OwnedNftKeys(v CompactNFTKeyVec) *ClaimMintCompactNFTEntriesBuilder {
	s.ownedNftKeys = v
	return s
}

func (s *ClaimMintCompactNFTEntriesBuilder) OwnedNftValues(v OwnedCompactNFTValueVec) *ClaimMintCompactNFTEntriesBuilder {
	s.ownedNftValues = v
	return s
}

func (s *ClaimMintCompactNFTEntriesBuilder) ClaimedNftKeys(v ClaimedCompactNFTKeyVec) *ClaimMintCompactNFTEntriesBuilder {
	s.claimedNftKeys = v
	return s
}

func (s *ClaimMintCompactNFTEntriesBuilder) ClaimedNftValues(v ClaimedCommpactNFTValueVec) *ClaimMintCompactNFTEntriesBuilder {
	s.claimedNftValues = v
	return s
}

func (s *ClaimMintCompactNFTEntriesBuilder) Proof(v Bytes) *ClaimMintCompactNFTEntriesBuilder {
	s.proof = v
	return s
}

func (s *ClaimMintCompactNFTEntriesBuilder) MintProof(v Bytes) *ClaimMintCompactNFTEntriesBuilder {
	s.mintProof = v
	return s
}

func NewClaimMintCompactNFTEntriesBuilder() *ClaimMintCompactNFTEntriesBuilder {
	return &ClaimMintCompactNFTEntriesBuilder{ownedNftKeys: CompactNFTKeyVecDefault(), ownedNftValues: OwnedCompactNFTValueVecDefault(), claimedNftKeys: ClaimedCompactNFTKeyVecDefault(), claimedNftValues: ClaimedCommpactNFTValueVecDefault(), proof: BytesDefault(), mintProof: BytesDefault()}
}

type ClaimMintCompactNFTEntries struct {
	inner []byte
}

func ClaimMintCompactNFTEntriesFromSliceUnchecked(slice []byte) *ClaimMintCompactNFTEntries {
	return &ClaimMintCompactNFTEntries{inner: slice}
}
func (s *ClaimMintCompactNFTEntries) AsSlice() []byte {
	return s.inner
}

func ClaimMintCompactNFTEntriesDefault() ClaimMintCompactNFTEntries {
	return *ClaimMintCompactNFTEntriesFromSliceUnchecked([]byte{52, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ClaimMintCompactNFTEntriesFromSlice(slice []byte, compatible bool) (*ClaimMintCompactNFTEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimMintCompactNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimMintCompactNFTEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 6 == 0 {
		return &ClaimMintCompactNFTEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimMintCompactNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ClaimMintCompactNFTEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimMintCompactNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 6 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 6 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = CompactNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = OwnedCompactNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimedCompactNFTKeyVecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimedCommpactNFTValueVecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	return &ClaimMintCompactNFTEntries{inner: slice}, nil
}

func (s *ClaimMintCompactNFTEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ClaimMintCompactNFTEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ClaimMintCompactNFTEntries) Len() uint {
	return s.FieldCount()
}
func (s *ClaimMintCompactNFTEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ClaimMintCompactNFTEntries) CountExtraFields() uint {
	return s.FieldCount() - 6
}

func (s *ClaimMintCompactNFTEntries) HasExtraFields() bool {
	return 6 != s.FieldCount()
}

func (s *ClaimMintCompactNFTEntries) OwnedNftKeys() *CompactNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return CompactNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimMintCompactNFTEntries) OwnedNftValues() *OwnedCompactNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return OwnedCompactNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimMintCompactNFTEntries) ClaimedNftKeys() *ClaimedCompactNFTKeyVec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return ClaimedCompactNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimMintCompactNFTEntries) ClaimedNftValues() *ClaimedCommpactNFTValueVec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return ClaimedCommpactNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimMintCompactNFTEntries) Proof() *Bytes {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimMintCompactNFTEntries) MintProof() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[24:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[28:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ClaimMintCompactNFTEntries) AsBuilder() ClaimMintCompactNFTEntriesBuilder {
	ret := NewClaimMintCompactNFTEntriesBuilder().OwnedNftKeys(*s.OwnedNftKeys()).OwnedNftValues(*s.OwnedNftValues()).ClaimedNftKeys(*s.ClaimedNftKeys()).ClaimedNftValues(*s.ClaimedNftValues()).Proof(*s.Proof()).MintProof(*s.MintProof())
	return *ret
}

type WithdrawTransferCompactNFTEntriesBuilder struct {
	ownedNftKeys        CompactNFTKeyVec
	ownedNftValues      OwnedCompactNFTValueVec
	withdrawalNftKeys   CompactNFTKeyVec
	withdrawalNftValues WithdrawCompactNFTValueVec
	proof               Bytes
}

func (s *WithdrawTransferCompactNFTEntriesBuilder) Build() WithdrawTransferCompactNFTEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (5 + 1)
	offsets := make([]uint32, 0, 5)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.ownedNftKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.ownedNftValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawalNftKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawalNftValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.ownedNftKeys.AsSlice())
	b.Write(s.ownedNftValues.AsSlice())
	b.Write(s.withdrawalNftKeys.AsSlice())
	b.Write(s.withdrawalNftValues.AsSlice())
	b.Write(s.proof.AsSlice())
	return WithdrawTransferCompactNFTEntries{inner: b.Bytes()}
}

func (s *WithdrawTransferCompactNFTEntriesBuilder) OwnedNftKeys(v CompactNFTKeyVec) *WithdrawTransferCompactNFTEntriesBuilder {
	s.ownedNftKeys = v
	return s
}

func (s *WithdrawTransferCompactNFTEntriesBuilder) OwnedNftValues(v OwnedCompactNFTValueVec) *WithdrawTransferCompactNFTEntriesBuilder {
	s.ownedNftValues = v
	return s
}

func (s *WithdrawTransferCompactNFTEntriesBuilder) WithdrawalNftKeys(v CompactNFTKeyVec) *WithdrawTransferCompactNFTEntriesBuilder {
	s.withdrawalNftKeys = v
	return s
}

func (s *WithdrawTransferCompactNFTEntriesBuilder) WithdrawalNftValues(v WithdrawCompactNFTValueVec) *WithdrawTransferCompactNFTEntriesBuilder {
	s.withdrawalNftValues = v
	return s
}

func (s *WithdrawTransferCompactNFTEntriesBuilder) Proof(v Bytes) *WithdrawTransferCompactNFTEntriesBuilder {
	s.proof = v
	return s
}

func NewWithdrawTransferCompactNFTEntriesBuilder() *WithdrawTransferCompactNFTEntriesBuilder {
	return &WithdrawTransferCompactNFTEntriesBuilder{ownedNftKeys: CompactNFTKeyVecDefault(), ownedNftValues: OwnedCompactNFTValueVecDefault(), withdrawalNftKeys: CompactNFTKeyVecDefault(), withdrawalNftValues: WithdrawCompactNFTValueVecDefault(), proof: BytesDefault()}
}

type WithdrawTransferCompactNFTEntries struct {
	inner []byte
}

func WithdrawTransferCompactNFTEntriesFromSliceUnchecked(slice []byte) *WithdrawTransferCompactNFTEntries {
	return &WithdrawTransferCompactNFTEntries{inner: slice}
}
func (s *WithdrawTransferCompactNFTEntries) AsSlice() []byte {
	return s.inner
}

func WithdrawTransferCompactNFTEntriesDefault() WithdrawTransferCompactNFTEntries {
	return *WithdrawTransferCompactNFTEntriesFromSliceUnchecked([]byte{44, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func WithdrawTransferCompactNFTEntriesFromSlice(slice []byte, compatible bool) (*WithdrawTransferCompactNFTEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawTransferCompactNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawTransferCompactNFTEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 5 == 0 {
		return &WithdrawTransferCompactNFTEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawTransferCompactNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "WithdrawTransferCompactNFTEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawTransferCompactNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 5 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 5 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = CompactNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = OwnedCompactNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = CompactNFTKeyVecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawCompactNFTValueVecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	return &WithdrawTransferCompactNFTEntries{inner: slice}, nil
}

func (s *WithdrawTransferCompactNFTEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *WithdrawTransferCompactNFTEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *WithdrawTransferCompactNFTEntries) Len() uint {
	return s.FieldCount()
}
func (s *WithdrawTransferCompactNFTEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *WithdrawTransferCompactNFTEntries) CountExtraFields() uint {
	return s.FieldCount() - 5
}

func (s *WithdrawTransferCompactNFTEntries) HasExtraFields() bool {
	return 5 != s.FieldCount()
}

func (s *WithdrawTransferCompactNFTEntries) OwnedNftKeys() *CompactNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return CompactNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawTransferCompactNFTEntries) OwnedNftValues() *OwnedCompactNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return OwnedCompactNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawTransferCompactNFTEntries) WithdrawalNftKeys() *CompactNFTKeyVec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return CompactNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawTransferCompactNFTEntries) WithdrawalNftValues() *WithdrawCompactNFTValueVec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return WithdrawCompactNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawTransferCompactNFTEntries) Proof() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[20:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[24:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *WithdrawTransferCompactNFTEntries) AsBuilder() WithdrawTransferCompactNFTEntriesBuilder {
	ret := NewWithdrawTransferCompactNFTEntriesBuilder().OwnedNftKeys(*s.OwnedNftKeys()).OwnedNftValues(*s.OwnedNftValues()).WithdrawalNftKeys(*s.WithdrawalNftKeys()).WithdrawalNftValues(*s.WithdrawalNftValues()).Proof(*s.Proof())
	return *ret
}

type ClaimTransferCompactNFTEntriesBuilder struct {
	ownedNftKeys     CompactNFTKeyVec
	ownedNftValues   OwnedCompactNFTValueVec
	claimedNftKeys   ClaimedCompactNFTKeyVec
	claimedNftValues ClaimedCommpactNFTValueVec
	proof            Bytes
	withdrawalProof  Bytes
}

func (s *ClaimTransferCompactNFTEntriesBuilder) Build() ClaimTransferCompactNFTEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (6 + 1)
	offsets := make([]uint32, 0, 6)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.ownedNftKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.ownedNftValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claimedNftKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claimedNftValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawalProof.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.ownedNftKeys.AsSlice())
	b.Write(s.ownedNftValues.AsSlice())
	b.Write(s.claimedNftKeys.AsSlice())
	b.Write(s.claimedNftValues.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.withdrawalProof.AsSlice())
	return ClaimTransferCompactNFTEntries{inner: b.Bytes()}
}

func (s *ClaimTransferCompactNFTEntriesBuilder) OwnedNftKeys(v CompactNFTKeyVec) *ClaimTransferCompactNFTEntriesBuilder {
	s.ownedNftKeys = v
	return s
}

func (s *ClaimTransferCompactNFTEntriesBuilder) OwnedNftValues(v OwnedCompactNFTValueVec) *ClaimTransferCompactNFTEntriesBuilder {
	s.ownedNftValues = v
	return s
}

func (s *ClaimTransferCompactNFTEntriesBuilder) ClaimedNftKeys(v ClaimedCompactNFTKeyVec) *ClaimTransferCompactNFTEntriesBuilder {
	s.claimedNftKeys = v
	return s
}

func (s *ClaimTransferCompactNFTEntriesBuilder) ClaimedNftValues(v ClaimedCommpactNFTValueVec) *ClaimTransferCompactNFTEntriesBuilder {
	s.claimedNftValues = v
	return s
}

func (s *ClaimTransferCompactNFTEntriesBuilder) Proof(v Bytes) *ClaimTransferCompactNFTEntriesBuilder {
	s.proof = v
	return s
}

func (s *ClaimTransferCompactNFTEntriesBuilder) WithdrawalProof(v Bytes) *ClaimTransferCompactNFTEntriesBuilder {
	s.withdrawalProof = v
	return s
}

func NewClaimTransferCompactNFTEntriesBuilder() *ClaimTransferCompactNFTEntriesBuilder {
	return &ClaimTransferCompactNFTEntriesBuilder{ownedNftKeys: CompactNFTKeyVecDefault(), ownedNftValues: OwnedCompactNFTValueVecDefault(), claimedNftKeys: ClaimedCompactNFTKeyVecDefault(), claimedNftValues: ClaimedCommpactNFTValueVecDefault(), proof: BytesDefault(), withdrawalProof: BytesDefault()}
}

type ClaimTransferCompactNFTEntries struct {
	inner []byte
}

func ClaimTransferCompactNFTEntriesFromSliceUnchecked(slice []byte) *ClaimTransferCompactNFTEntries {
	return &ClaimTransferCompactNFTEntries{inner: slice}
}
func (s *ClaimTransferCompactNFTEntries) AsSlice() []byte {
	return s.inner
}

func ClaimTransferCompactNFTEntriesDefault() ClaimTransferCompactNFTEntries {
	return *ClaimTransferCompactNFTEntriesFromSliceUnchecked([]byte{52, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ClaimTransferCompactNFTEntriesFromSlice(slice []byte, compatible bool) (*ClaimTransferCompactNFTEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimTransferCompactNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimTransferCompactNFTEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 6 == 0 {
		return &ClaimTransferCompactNFTEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimTransferCompactNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ClaimTransferCompactNFTEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimTransferCompactNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 6 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 6 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = CompactNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = OwnedCompactNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimedCompactNFTKeyVecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimedCommpactNFTValueVecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	return &ClaimTransferCompactNFTEntries{inner: slice}, nil
}

func (s *ClaimTransferCompactNFTEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ClaimTransferCompactNFTEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ClaimTransferCompactNFTEntries) Len() uint {
	return s.FieldCount()
}
func (s *ClaimTransferCompactNFTEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ClaimTransferCompactNFTEntries) CountExtraFields() uint {
	return s.FieldCount() - 6
}

func (s *ClaimTransferCompactNFTEntries) HasExtraFields() bool {
	return 6 != s.FieldCount()
}

func (s *ClaimTransferCompactNFTEntries) OwnedNftKeys() *CompactNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return CompactNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimTransferCompactNFTEntries) OwnedNftValues() *OwnedCompactNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return OwnedCompactNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimTransferCompactNFTEntries) ClaimedNftKeys() *ClaimedCompactNFTKeyVec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return ClaimedCompactNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimTransferCompactNFTEntries) ClaimedNftValues() *ClaimedCommpactNFTValueVec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return ClaimedCommpactNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimTransferCompactNFTEntries) Proof() *Bytes {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimTransferCompactNFTEntries) WithdrawalProof() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[24:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[28:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ClaimTransferCompactNFTEntries) AsBuilder() ClaimTransferCompactNFTEntriesBuilder {
	ret := NewClaimTransferCompactNFTEntriesBuilder().OwnedNftKeys(*s.OwnedNftKeys()).OwnedNftValues(*s.OwnedNftValues()).ClaimedNftKeys(*s.ClaimedNftKeys()).ClaimedNftValues(*s.ClaimedNftValues()).Proof(*s.Proof()).WithdrawalProof(*s.WithdrawalProof())
	return *ret
}

type UpdateCompactNFTEntriesBuilder struct {
	ownedNftKeys CompactNFTKeyVec
	oldNftValues OwnedCompactNFTValueVec
	newNftValues OwnedCompactNFTValueVec
	proof        Bytes
}

func (s *UpdateCompactNFTEntriesBuilder) Build() UpdateCompactNFTEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (4 + 1)
	offsets := make([]uint32, 0, 4)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.ownedNftKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.oldNftValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.newNftValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.ownedNftKeys.AsSlice())
	b.Write(s.oldNftValues.AsSlice())
	b.Write(s.newNftValues.AsSlice())
	b.Write(s.proof.AsSlice())
	return UpdateCompactNFTEntries{inner: b.Bytes()}
}

func (s *UpdateCompactNFTEntriesBuilder) OwnedNftKeys(v CompactNFTKeyVec) *UpdateCompactNFTEntriesBuilder {
	s.ownedNftKeys = v
	return s
}

func (s *UpdateCompactNFTEntriesBuilder) OldNftValues(v OwnedCompactNFTValueVec) *UpdateCompactNFTEntriesBuilder {
	s.oldNftValues = v
	return s
}

func (s *UpdateCompactNFTEntriesBuilder) NewNftValues(v OwnedCompactNFTValueVec) *UpdateCompactNFTEntriesBuilder {
	s.newNftValues = v
	return s
}

func (s *UpdateCompactNFTEntriesBuilder) Proof(v Bytes) *UpdateCompactNFTEntriesBuilder {
	s.proof = v
	return s
}

func NewUpdateCompactNFTEntriesBuilder() *UpdateCompactNFTEntriesBuilder {
	return &UpdateCompactNFTEntriesBuilder{ownedNftKeys: CompactNFTKeyVecDefault(), oldNftValues: OwnedCompactNFTValueVecDefault(), newNftValues: OwnedCompactNFTValueVecDefault(), proof: BytesDefault()}
}

type UpdateCompactNFTEntries struct {
	inner []byte
}

func UpdateCompactNFTEntriesFromSliceUnchecked(slice []byte) *UpdateCompactNFTEntries {
	return &UpdateCompactNFTEntries{inner: slice}
}
func (s *UpdateCompactNFTEntries) AsSlice() []byte {
	return s.inner
}

func UpdateCompactNFTEntriesDefault() UpdateCompactNFTEntries {
	return *UpdateCompactNFTEntriesFromSliceUnchecked([]byte{36, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func UpdateCompactNFTEntriesFromSlice(slice []byte, compatible bool) (*UpdateCompactNFTEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "UpdateCompactNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "UpdateCompactNFTEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 4 == 0 {
		return &UpdateCompactNFTEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "UpdateCompactNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "UpdateCompactNFTEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "UpdateCompactNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 4 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 4 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = CompactNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = OwnedCompactNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = OwnedCompactNFTValueVecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	return &UpdateCompactNFTEntries{inner: slice}, nil
}

func (s *UpdateCompactNFTEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *UpdateCompactNFTEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *UpdateCompactNFTEntries) Len() uint {
	return s.FieldCount()
}
func (s *UpdateCompactNFTEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *UpdateCompactNFTEntries) CountExtraFields() uint {
	return s.FieldCount() - 4
}

func (s *UpdateCompactNFTEntries) HasExtraFields() bool {
	return 4 != s.FieldCount()
}

func (s *UpdateCompactNFTEntries) OwnedNftKeys() *CompactNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return CompactNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *UpdateCompactNFTEntries) OldNftValues() *OwnedCompactNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return OwnedCompactNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *UpdateCompactNFTEntries) NewNftValues() *OwnedCompactNFTValueVec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return OwnedCompactNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *UpdateCompactNFTEntries) Proof() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[16:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[20:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *UpdateCompactNFTEntries) AsBuilder() UpdateCompactNFTEntriesBuilder {
	ret := NewUpdateCompactNFTEntriesBuilder().OwnedNftKeys(*s.OwnedNftKeys()).OldNftValues(*s.OldNftValues()).NewNftValues(*s.NewNftValues()).Proof(*s.Proof())
	return *ret
}
