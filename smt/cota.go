// Generated by Molecule 0.7.2
// Generated by Moleculec-Go 0.1.8

package smt

import (
	"bytes"
	"encoding/binary"
	"errors"
	"strconv"
	"strings"
)

type Number uint32

const HeaderSizeUint uint32 = 4

// Byte is the primitive type
type Byte [1]byte

func NewByte(b byte) Byte {
	return Byte([1]byte{b})
}
func ByteDefault() Byte {
	return Byte([1]byte{0})
}
func ByteFromSliceUnchecked(slice []byte) *Byte {
	b := new(Byte)
	b[0] = slice[0]
	return b
}
func (b *Byte) AsSlice() []byte {
	return b[:]
}
func ByteFromSlice(slice []byte, _compatible bool) (*Byte, error) {
	if len(slice) != 1 {
		return nil, errors.New("TotalSizeNotMatch")
	}
	b := new(Byte)
	b[0] = slice[0]
	return b, nil
}
func unpackNumber(b []byte) Number {
	bytesBuffer := bytes.NewBuffer(b)
	var x Number
	binary.Read(bytesBuffer, binary.LittleEndian, &x)
	return x
}
func packNumber(num Number) []byte {
	b := make([]byte, 4)
	binary.LittleEndian.PutUint32(b, uint32(num))
	return b
}

type Byte32Builder struct {
	inner [32]Byte
}

func NewByte32Builder() *Byte32Builder {
	return &Byte32Builder{inner: [32]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *Byte32Builder) Build() Byte32 {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Byte32{inner: b.Bytes()}
}

func (s *Byte32Builder) Set(v [32]Byte) *Byte32Builder {
	s.inner = v
	return s
}

func (s *Byte32Builder) Nth0(v Byte) *Byte32Builder {
	s.inner[0] = v
	return s
}

func (s *Byte32Builder) Nth1(v Byte) *Byte32Builder {
	s.inner[1] = v
	return s
}

func (s *Byte32Builder) Nth2(v Byte) *Byte32Builder {
	s.inner[2] = v
	return s
}

func (s *Byte32Builder) Nth3(v Byte) *Byte32Builder {
	s.inner[3] = v
	return s
}

func (s *Byte32Builder) Nth4(v Byte) *Byte32Builder {
	s.inner[4] = v
	return s
}

func (s *Byte32Builder) Nth5(v Byte) *Byte32Builder {
	s.inner[5] = v
	return s
}

func (s *Byte32Builder) Nth6(v Byte) *Byte32Builder {
	s.inner[6] = v
	return s
}

func (s *Byte32Builder) Nth7(v Byte) *Byte32Builder {
	s.inner[7] = v
	return s
}

func (s *Byte32Builder) Nth8(v Byte) *Byte32Builder {
	s.inner[8] = v
	return s
}

func (s *Byte32Builder) Nth9(v Byte) *Byte32Builder {
	s.inner[9] = v
	return s
}

func (s *Byte32Builder) Nth10(v Byte) *Byte32Builder {
	s.inner[10] = v
	return s
}

func (s *Byte32Builder) Nth11(v Byte) *Byte32Builder {
	s.inner[11] = v
	return s
}

func (s *Byte32Builder) Nth12(v Byte) *Byte32Builder {
	s.inner[12] = v
	return s
}

func (s *Byte32Builder) Nth13(v Byte) *Byte32Builder {
	s.inner[13] = v
	return s
}

func (s *Byte32Builder) Nth14(v Byte) *Byte32Builder {
	s.inner[14] = v
	return s
}

func (s *Byte32Builder) Nth15(v Byte) *Byte32Builder {
	s.inner[15] = v
	return s
}

func (s *Byte32Builder) Nth16(v Byte) *Byte32Builder {
	s.inner[16] = v
	return s
}

func (s *Byte32Builder) Nth17(v Byte) *Byte32Builder {
	s.inner[17] = v
	return s
}

func (s *Byte32Builder) Nth18(v Byte) *Byte32Builder {
	s.inner[18] = v
	return s
}

func (s *Byte32Builder) Nth19(v Byte) *Byte32Builder {
	s.inner[19] = v
	return s
}

func (s *Byte32Builder) Nth20(v Byte) *Byte32Builder {
	s.inner[20] = v
	return s
}

func (s *Byte32Builder) Nth21(v Byte) *Byte32Builder {
	s.inner[21] = v
	return s
}

func (s *Byte32Builder) Nth22(v Byte) *Byte32Builder {
	s.inner[22] = v
	return s
}

func (s *Byte32Builder) Nth23(v Byte) *Byte32Builder {
	s.inner[23] = v
	return s
}

func (s *Byte32Builder) Nth24(v Byte) *Byte32Builder {
	s.inner[24] = v
	return s
}

func (s *Byte32Builder) Nth25(v Byte) *Byte32Builder {
	s.inner[25] = v
	return s
}

func (s *Byte32Builder) Nth26(v Byte) *Byte32Builder {
	s.inner[26] = v
	return s
}

func (s *Byte32Builder) Nth27(v Byte) *Byte32Builder {
	s.inner[27] = v
	return s
}

func (s *Byte32Builder) Nth28(v Byte) *Byte32Builder {
	s.inner[28] = v
	return s
}

func (s *Byte32Builder) Nth29(v Byte) *Byte32Builder {
	s.inner[29] = v
	return s
}

func (s *Byte32Builder) Nth30(v Byte) *Byte32Builder {
	s.inner[30] = v
	return s
}

func (s *Byte32Builder) Nth31(v Byte) *Byte32Builder {
	s.inner[31] = v
	return s
}

type Byte32 struct {
	inner []byte
}

func Byte32FromSliceUnchecked(slice []byte) *Byte32 {
	return &Byte32{inner: slice}
}
func (s *Byte32) AsSlice() []byte {
	return s.inner
}

func Byte32Default() Byte32 {
	return *Byte32FromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func Byte32FromSlice(slice []byte, _compatible bool) (*Byte32, error) {
	sliceLen := len(slice)
	if sliceLen != 32 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Byte32", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(32)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Byte32{inner: slice}, nil
}

func (s *Byte32) RawData() []byte {
	return s.inner
}

func (s *Byte32) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Byte32) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Byte32) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Byte32) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Byte32) Nth4() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *Byte32) Nth5() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *Byte32) Nth6() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *Byte32) Nth7() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *Byte32) Nth8() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *Byte32) Nth9() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *Byte32) Nth10() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *Byte32) Nth11() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *Byte32) Nth12() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *Byte32) Nth13() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *Byte32) Nth14() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *Byte32) Nth15() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *Byte32) Nth16() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[16:17])
	return ret
}

func (s *Byte32) Nth17() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[17:18])
	return ret
}

func (s *Byte32) Nth18() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[18:19])
	return ret
}

func (s *Byte32) Nth19() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[19:20])
	return ret
}

func (s *Byte32) Nth20() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[20:21])
	return ret
}

func (s *Byte32) Nth21() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[21:22])
	return ret
}

func (s *Byte32) Nth22() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[22:23])
	return ret
}

func (s *Byte32) Nth23() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[23:24])
	return ret
}

func (s *Byte32) Nth24() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[24:25])
	return ret
}

func (s *Byte32) Nth25() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[25:26])
	return ret
}

func (s *Byte32) Nth26() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[26:27])
	return ret
}

func (s *Byte32) Nth27() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[27:28])
	return ret
}

func (s *Byte32) Nth28() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[28:29])
	return ret
}

func (s *Byte32) Nth29() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[29:30])
	return ret
}

func (s *Byte32) Nth30() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[30:31])
	return ret
}

func (s *Byte32) Nth31() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[31:32])
	return ret
}

func (s *Byte32) AsBuilder() Byte32Builder {
	t := NewByte32Builder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	t.Nth4(*s.Nth4())
	t.Nth5(*s.Nth5())
	t.Nth6(*s.Nth6())
	t.Nth7(*s.Nth7())
	t.Nth8(*s.Nth8())
	t.Nth9(*s.Nth9())
	t.Nth10(*s.Nth10())
	t.Nth11(*s.Nth11())
	t.Nth12(*s.Nth12())
	t.Nth13(*s.Nth13())
	t.Nth14(*s.Nth14())
	t.Nth15(*s.Nth15())
	t.Nth16(*s.Nth16())
	t.Nth17(*s.Nth17())
	t.Nth18(*s.Nth18())
	t.Nth19(*s.Nth19())
	t.Nth20(*s.Nth20())
	t.Nth21(*s.Nth21())
	t.Nth22(*s.Nth22())
	t.Nth23(*s.Nth23())
	t.Nth24(*s.Nth24())
	t.Nth25(*s.Nth25())
	t.Nth26(*s.Nth26())
	t.Nth27(*s.Nth27())
	t.Nth28(*s.Nth28())
	t.Nth29(*s.Nth29())
	t.Nth30(*s.Nth30())
	t.Nth31(*s.Nth31())
	return *t
}

type Uint16Builder struct {
	inner [2]Byte
}

func NewUint16Builder() *Uint16Builder {
	return &Uint16Builder{inner: [2]Byte{ByteDefault(), ByteDefault()}}
}

func (s *Uint16Builder) Build() Uint16 {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Uint16{inner: b.Bytes()}
}

func (s *Uint16Builder) Set(v [2]Byte) *Uint16Builder {
	s.inner = v
	return s
}

func (s *Uint16Builder) Nth0(v Byte) *Uint16Builder {
	s.inner[0] = v
	return s
}

func (s *Uint16Builder) Nth1(v Byte) *Uint16Builder {
	s.inner[1] = v
	return s
}

type Uint16 struct {
	inner []byte
}

func Uint16FromSliceUnchecked(slice []byte) *Uint16 {
	return &Uint16{inner: slice}
}
func (s *Uint16) AsSlice() []byte {
	return s.inner
}

func Uint16Default() Uint16 {
	return *Uint16FromSliceUnchecked([]byte{0, 0})
}

func Uint16FromSlice(slice []byte, _compatible bool) (*Uint16, error) {
	sliceLen := len(slice)
	if sliceLen != 2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint16", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(2)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Uint16{inner: slice}, nil
}

func (s *Uint16) RawData() []byte {
	return s.inner
}

func (s *Uint16) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Uint16) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Uint16) AsBuilder() Uint16Builder {
	t := NewUint16Builder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	return *t
}

type Uint32Builder struct {
	inner [4]Byte
}

func NewUint32Builder() *Uint32Builder {
	return &Uint32Builder{inner: [4]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *Uint32Builder) Build() Uint32 {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Uint32{inner: b.Bytes()}
}

func (s *Uint32Builder) Set(v [4]Byte) *Uint32Builder {
	s.inner = v
	return s
}

func (s *Uint32Builder) Nth0(v Byte) *Uint32Builder {
	s.inner[0] = v
	return s
}

func (s *Uint32Builder) Nth1(v Byte) *Uint32Builder {
	s.inner[1] = v
	return s
}

func (s *Uint32Builder) Nth2(v Byte) *Uint32Builder {
	s.inner[2] = v
	return s
}

func (s *Uint32Builder) Nth3(v Byte) *Uint32Builder {
	s.inner[3] = v
	return s
}

type Uint32 struct {
	inner []byte
}

func Uint32FromSliceUnchecked(slice []byte) *Uint32 {
	return &Uint32{inner: slice}
}
func (s *Uint32) AsSlice() []byte {
	return s.inner
}

func Uint32Default() Uint32 {
	return *Uint32FromSliceUnchecked([]byte{0, 0, 0, 0})
}

func Uint32FromSlice(slice []byte, _compatible bool) (*Uint32, error) {
	sliceLen := len(slice)
	if sliceLen != 4 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint32", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(4)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Uint32{inner: slice}, nil
}

func (s *Uint32) RawData() []byte {
	return s.inner
}

func (s *Uint32) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Uint32) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Uint32) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Uint32) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Uint32) AsBuilder() Uint32Builder {
	t := NewUint32Builder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	return *t
}

type BytesBuilder struct {
	inner []Byte
}

func (s *BytesBuilder) Build() Bytes {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := Bytes{inner: b.Bytes()}

	return sb
}

func (s *BytesBuilder) Set(v []Byte) *BytesBuilder {
	s.inner = v
	return s
}
func (s *BytesBuilder) Push(v Byte) *BytesBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *BytesBuilder) Extend(iter []Byte) *BytesBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewBytesBuilder() *BytesBuilder {
	return &BytesBuilder{[]Byte{}}
}

type Bytes struct {
	inner []byte
}

func BytesFromSliceUnchecked(slice []byte) *Bytes {
	return &Bytes{inner: slice}
}
func (s *Bytes) AsSlice() []byte {
	return s.inner
}

func BytesDefault() Bytes {
	return *BytesFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func BytesFromSlice(slice []byte, _compatible bool) (*Bytes, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Bytes", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "Bytes", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &Bytes{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(1*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Bytes", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &Bytes{inner: slice}, nil
}

func (s *Bytes) TotalSize() uint {
	return uint(HeaderSizeUint) + 1*s.ItemCount()
}
func (s *Bytes) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *Bytes) Len() uint {
	return s.ItemCount()
}
func (s *Bytes) IsEmpty() bool {
	return s.Len() == 0
}

// if *Byte is nil, index is out of bounds
func (s *Bytes) Get(index uint) *Byte {
	var re *Byte
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 1*index
		end := start + 1
		re = ByteFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *Bytes) RawData() []byte {
	return s.inner[HeaderSizeUint:]
}

func (s *Bytes) AsBuilder() BytesBuilder {
	size := s.ItemCount()
	t := NewBytesBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type CotaIdBuilder struct {
	inner [20]Byte
}

func NewCotaIdBuilder() *CotaIdBuilder {
	return &CotaIdBuilder{inner: [20]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *CotaIdBuilder) Build() CotaId {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return CotaId{inner: b.Bytes()}
}

func (s *CotaIdBuilder) Set(v [20]Byte) *CotaIdBuilder {
	s.inner = v
	return s
}

func (s *CotaIdBuilder) Nth0(v Byte) *CotaIdBuilder {
	s.inner[0] = v
	return s
}

func (s *CotaIdBuilder) Nth1(v Byte) *CotaIdBuilder {
	s.inner[1] = v
	return s
}

func (s *CotaIdBuilder) Nth2(v Byte) *CotaIdBuilder {
	s.inner[2] = v
	return s
}

func (s *CotaIdBuilder) Nth3(v Byte) *CotaIdBuilder {
	s.inner[3] = v
	return s
}

func (s *CotaIdBuilder) Nth4(v Byte) *CotaIdBuilder {
	s.inner[4] = v
	return s
}

func (s *CotaIdBuilder) Nth5(v Byte) *CotaIdBuilder {
	s.inner[5] = v
	return s
}

func (s *CotaIdBuilder) Nth6(v Byte) *CotaIdBuilder {
	s.inner[6] = v
	return s
}

func (s *CotaIdBuilder) Nth7(v Byte) *CotaIdBuilder {
	s.inner[7] = v
	return s
}

func (s *CotaIdBuilder) Nth8(v Byte) *CotaIdBuilder {
	s.inner[8] = v
	return s
}

func (s *CotaIdBuilder) Nth9(v Byte) *CotaIdBuilder {
	s.inner[9] = v
	return s
}

func (s *CotaIdBuilder) Nth10(v Byte) *CotaIdBuilder {
	s.inner[10] = v
	return s
}

func (s *CotaIdBuilder) Nth11(v Byte) *CotaIdBuilder {
	s.inner[11] = v
	return s
}

func (s *CotaIdBuilder) Nth12(v Byte) *CotaIdBuilder {
	s.inner[12] = v
	return s
}

func (s *CotaIdBuilder) Nth13(v Byte) *CotaIdBuilder {
	s.inner[13] = v
	return s
}

func (s *CotaIdBuilder) Nth14(v Byte) *CotaIdBuilder {
	s.inner[14] = v
	return s
}

func (s *CotaIdBuilder) Nth15(v Byte) *CotaIdBuilder {
	s.inner[15] = v
	return s
}

func (s *CotaIdBuilder) Nth16(v Byte) *CotaIdBuilder {
	s.inner[16] = v
	return s
}

func (s *CotaIdBuilder) Nth17(v Byte) *CotaIdBuilder {
	s.inner[17] = v
	return s
}

func (s *CotaIdBuilder) Nth18(v Byte) *CotaIdBuilder {
	s.inner[18] = v
	return s
}

func (s *CotaIdBuilder) Nth19(v Byte) *CotaIdBuilder {
	s.inner[19] = v
	return s
}

type CotaId struct {
	inner []byte
}

func CotaIdFromSliceUnchecked(slice []byte) *CotaId {
	return &CotaId{inner: slice}
}
func (s *CotaId) AsSlice() []byte {
	return s.inner
}

func CotaIdDefault() CotaId {
	return *CotaIdFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func CotaIdFromSlice(slice []byte, _compatible bool) (*CotaId, error) {
	sliceLen := len(slice)
	if sliceLen != 20 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CotaId", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(20)}, " ")
		return nil, errors.New(errMsg)
	}
	return &CotaId{inner: slice}, nil
}

func (s *CotaId) RawData() []byte {
	return s.inner
}

func (s *CotaId) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *CotaId) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *CotaId) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *CotaId) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *CotaId) Nth4() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *CotaId) Nth5() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *CotaId) Nth6() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *CotaId) Nth7() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *CotaId) Nth8() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *CotaId) Nth9() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *CotaId) Nth10() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *CotaId) Nth11() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *CotaId) Nth12() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *CotaId) Nth13() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *CotaId) Nth14() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *CotaId) Nth15() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *CotaId) Nth16() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[16:17])
	return ret
}

func (s *CotaId) Nth17() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[17:18])
	return ret
}

func (s *CotaId) Nth18() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[18:19])
	return ret
}

func (s *CotaId) Nth19() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[19:20])
	return ret
}

func (s *CotaId) AsBuilder() CotaIdBuilder {
	t := NewCotaIdBuilder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	t.Nth4(*s.Nth4())
	t.Nth5(*s.Nth5())
	t.Nth6(*s.Nth6())
	t.Nth7(*s.Nth7())
	t.Nth8(*s.Nth8())
	t.Nth9(*s.Nth9())
	t.Nth10(*s.Nth10())
	t.Nth11(*s.Nth11())
	t.Nth12(*s.Nth12())
	t.Nth13(*s.Nth13())
	t.Nth14(*s.Nth14())
	t.Nth15(*s.Nth15())
	t.Nth16(*s.Nth16())
	t.Nth17(*s.Nth17())
	t.Nth18(*s.Nth18())
	t.Nth19(*s.Nth19())
	return *t
}

type CharacteristicBuilder struct {
	inner [20]Byte
}

func NewCharacteristicBuilder() *CharacteristicBuilder {
	return &CharacteristicBuilder{inner: [20]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *CharacteristicBuilder) Build() Characteristic {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Characteristic{inner: b.Bytes()}
}

func (s *CharacteristicBuilder) Set(v [20]Byte) *CharacteristicBuilder {
	s.inner = v
	return s
}

func (s *CharacteristicBuilder) Nth0(v Byte) *CharacteristicBuilder {
	s.inner[0] = v
	return s
}

func (s *CharacteristicBuilder) Nth1(v Byte) *CharacteristicBuilder {
	s.inner[1] = v
	return s
}

func (s *CharacteristicBuilder) Nth2(v Byte) *CharacteristicBuilder {
	s.inner[2] = v
	return s
}

func (s *CharacteristicBuilder) Nth3(v Byte) *CharacteristicBuilder {
	s.inner[3] = v
	return s
}

func (s *CharacteristicBuilder) Nth4(v Byte) *CharacteristicBuilder {
	s.inner[4] = v
	return s
}

func (s *CharacteristicBuilder) Nth5(v Byte) *CharacteristicBuilder {
	s.inner[5] = v
	return s
}

func (s *CharacteristicBuilder) Nth6(v Byte) *CharacteristicBuilder {
	s.inner[6] = v
	return s
}

func (s *CharacteristicBuilder) Nth7(v Byte) *CharacteristicBuilder {
	s.inner[7] = v
	return s
}

func (s *CharacteristicBuilder) Nth8(v Byte) *CharacteristicBuilder {
	s.inner[8] = v
	return s
}

func (s *CharacteristicBuilder) Nth9(v Byte) *CharacteristicBuilder {
	s.inner[9] = v
	return s
}

func (s *CharacteristicBuilder) Nth10(v Byte) *CharacteristicBuilder {
	s.inner[10] = v
	return s
}

func (s *CharacteristicBuilder) Nth11(v Byte) *CharacteristicBuilder {
	s.inner[11] = v
	return s
}

func (s *CharacteristicBuilder) Nth12(v Byte) *CharacteristicBuilder {
	s.inner[12] = v
	return s
}

func (s *CharacteristicBuilder) Nth13(v Byte) *CharacteristicBuilder {
	s.inner[13] = v
	return s
}

func (s *CharacteristicBuilder) Nth14(v Byte) *CharacteristicBuilder {
	s.inner[14] = v
	return s
}

func (s *CharacteristicBuilder) Nth15(v Byte) *CharacteristicBuilder {
	s.inner[15] = v
	return s
}

func (s *CharacteristicBuilder) Nth16(v Byte) *CharacteristicBuilder {
	s.inner[16] = v
	return s
}

func (s *CharacteristicBuilder) Nth17(v Byte) *CharacteristicBuilder {
	s.inner[17] = v
	return s
}

func (s *CharacteristicBuilder) Nth18(v Byte) *CharacteristicBuilder {
	s.inner[18] = v
	return s
}

func (s *CharacteristicBuilder) Nth19(v Byte) *CharacteristicBuilder {
	s.inner[19] = v
	return s
}

type Characteristic struct {
	inner []byte
}

func CharacteristicFromSliceUnchecked(slice []byte) *Characteristic {
	return &Characteristic{inner: slice}
}
func (s *Characteristic) AsSlice() []byte {
	return s.inner
}

func CharacteristicDefault() Characteristic {
	return *CharacteristicFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func CharacteristicFromSlice(slice []byte, _compatible bool) (*Characteristic, error) {
	sliceLen := len(slice)
	if sliceLen != 20 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Characteristic", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(20)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Characteristic{inner: slice}, nil
}

func (s *Characteristic) RawData() []byte {
	return s.inner
}

func (s *Characteristic) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Characteristic) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Characteristic) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Characteristic) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Characteristic) Nth4() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *Characteristic) Nth5() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *Characteristic) Nth6() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *Characteristic) Nth7() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *Characteristic) Nth8() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *Characteristic) Nth9() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *Characteristic) Nth10() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *Characteristic) Nth11() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *Characteristic) Nth12() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *Characteristic) Nth13() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *Characteristic) Nth14() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *Characteristic) Nth15() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *Characteristic) Nth16() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[16:17])
	return ret
}

func (s *Characteristic) Nth17() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[17:18])
	return ret
}

func (s *Characteristic) Nth18() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[18:19])
	return ret
}

func (s *Characteristic) Nth19() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[19:20])
	return ret
}

func (s *Characteristic) AsBuilder() CharacteristicBuilder {
	t := NewCharacteristicBuilder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	t.Nth4(*s.Nth4())
	t.Nth5(*s.Nth5())
	t.Nth6(*s.Nth6())
	t.Nth7(*s.Nth7())
	t.Nth8(*s.Nth8())
	t.Nth9(*s.Nth9())
	t.Nth10(*s.Nth10())
	t.Nth11(*s.Nth11())
	t.Nth12(*s.Nth12())
	t.Nth13(*s.Nth13())
	t.Nth14(*s.Nth14())
	t.Nth15(*s.Nth15())
	t.Nth16(*s.Nth16())
	t.Nth17(*s.Nth17())
	t.Nth18(*s.Nth18())
	t.Nth19(*s.Nth19())
	return *t
}

type OutPointSliceBuilder struct {
	inner [24]Byte
}

func NewOutPointSliceBuilder() *OutPointSliceBuilder {
	return &OutPointSliceBuilder{inner: [24]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *OutPointSliceBuilder) Build() OutPointSlice {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return OutPointSlice{inner: b.Bytes()}
}

func (s *OutPointSliceBuilder) Set(v [24]Byte) *OutPointSliceBuilder {
	s.inner = v
	return s
}

func (s *OutPointSliceBuilder) Nth0(v Byte) *OutPointSliceBuilder {
	s.inner[0] = v
	return s
}

func (s *OutPointSliceBuilder) Nth1(v Byte) *OutPointSliceBuilder {
	s.inner[1] = v
	return s
}

func (s *OutPointSliceBuilder) Nth2(v Byte) *OutPointSliceBuilder {
	s.inner[2] = v
	return s
}

func (s *OutPointSliceBuilder) Nth3(v Byte) *OutPointSliceBuilder {
	s.inner[3] = v
	return s
}

func (s *OutPointSliceBuilder) Nth4(v Byte) *OutPointSliceBuilder {
	s.inner[4] = v
	return s
}

func (s *OutPointSliceBuilder) Nth5(v Byte) *OutPointSliceBuilder {
	s.inner[5] = v
	return s
}

func (s *OutPointSliceBuilder) Nth6(v Byte) *OutPointSliceBuilder {
	s.inner[6] = v
	return s
}

func (s *OutPointSliceBuilder) Nth7(v Byte) *OutPointSliceBuilder {
	s.inner[7] = v
	return s
}

func (s *OutPointSliceBuilder) Nth8(v Byte) *OutPointSliceBuilder {
	s.inner[8] = v
	return s
}

func (s *OutPointSliceBuilder) Nth9(v Byte) *OutPointSliceBuilder {
	s.inner[9] = v
	return s
}

func (s *OutPointSliceBuilder) Nth10(v Byte) *OutPointSliceBuilder {
	s.inner[10] = v
	return s
}

func (s *OutPointSliceBuilder) Nth11(v Byte) *OutPointSliceBuilder {
	s.inner[11] = v
	return s
}

func (s *OutPointSliceBuilder) Nth12(v Byte) *OutPointSliceBuilder {
	s.inner[12] = v
	return s
}

func (s *OutPointSliceBuilder) Nth13(v Byte) *OutPointSliceBuilder {
	s.inner[13] = v
	return s
}

func (s *OutPointSliceBuilder) Nth14(v Byte) *OutPointSliceBuilder {
	s.inner[14] = v
	return s
}

func (s *OutPointSliceBuilder) Nth15(v Byte) *OutPointSliceBuilder {
	s.inner[15] = v
	return s
}

func (s *OutPointSliceBuilder) Nth16(v Byte) *OutPointSliceBuilder {
	s.inner[16] = v
	return s
}

func (s *OutPointSliceBuilder) Nth17(v Byte) *OutPointSliceBuilder {
	s.inner[17] = v
	return s
}

func (s *OutPointSliceBuilder) Nth18(v Byte) *OutPointSliceBuilder {
	s.inner[18] = v
	return s
}

func (s *OutPointSliceBuilder) Nth19(v Byte) *OutPointSliceBuilder {
	s.inner[19] = v
	return s
}

func (s *OutPointSliceBuilder) Nth20(v Byte) *OutPointSliceBuilder {
	s.inner[20] = v
	return s
}

func (s *OutPointSliceBuilder) Nth21(v Byte) *OutPointSliceBuilder {
	s.inner[21] = v
	return s
}

func (s *OutPointSliceBuilder) Nth22(v Byte) *OutPointSliceBuilder {
	s.inner[22] = v
	return s
}

func (s *OutPointSliceBuilder) Nth23(v Byte) *OutPointSliceBuilder {
	s.inner[23] = v
	return s
}

type OutPointSlice struct {
	inner []byte
}

func OutPointSliceFromSliceUnchecked(slice []byte) *OutPointSlice {
	return &OutPointSlice{inner: slice}
}
func (s *OutPointSlice) AsSlice() []byte {
	return s.inner
}

func OutPointSliceDefault() OutPointSlice {
	return *OutPointSliceFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func OutPointSliceFromSlice(slice []byte, _compatible bool) (*OutPointSlice, error) {
	sliceLen := len(slice)
	if sliceLen != 24 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "OutPointSlice", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(24)}, " ")
		return nil, errors.New(errMsg)
	}
	return &OutPointSlice{inner: slice}, nil
}

func (s *OutPointSlice) RawData() []byte {
	return s.inner
}

func (s *OutPointSlice) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *OutPointSlice) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *OutPointSlice) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *OutPointSlice) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *OutPointSlice) Nth4() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *OutPointSlice) Nth5() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *OutPointSlice) Nth6() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *OutPointSlice) Nth7() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *OutPointSlice) Nth8() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *OutPointSlice) Nth9() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *OutPointSlice) Nth10() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *OutPointSlice) Nth11() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *OutPointSlice) Nth12() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *OutPointSlice) Nth13() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *OutPointSlice) Nth14() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *OutPointSlice) Nth15() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *OutPointSlice) Nth16() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[16:17])
	return ret
}

func (s *OutPointSlice) Nth17() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[17:18])
	return ret
}

func (s *OutPointSlice) Nth18() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[18:19])
	return ret
}

func (s *OutPointSlice) Nth19() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[19:20])
	return ret
}

func (s *OutPointSlice) Nth20() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[20:21])
	return ret
}

func (s *OutPointSlice) Nth21() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[21:22])
	return ret
}

func (s *OutPointSlice) Nth22() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[22:23])
	return ret
}

func (s *OutPointSlice) Nth23() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[23:24])
	return ret
}

func (s *OutPointSlice) AsBuilder() OutPointSliceBuilder {
	t := NewOutPointSliceBuilder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	t.Nth4(*s.Nth4())
	t.Nth5(*s.Nth5())
	t.Nth6(*s.Nth6())
	t.Nth7(*s.Nth7())
	t.Nth8(*s.Nth8())
	t.Nth9(*s.Nth9())
	t.Nth10(*s.Nth10())
	t.Nth11(*s.Nth11())
	t.Nth12(*s.Nth12())
	t.Nth13(*s.Nth13())
	t.Nth14(*s.Nth14())
	t.Nth15(*s.Nth15())
	t.Nth16(*s.Nth16())
	t.Nth17(*s.Nth17())
	t.Nth18(*s.Nth18())
	t.Nth19(*s.Nth19())
	t.Nth20(*s.Nth20())
	t.Nth21(*s.Nth21())
	t.Nth22(*s.Nth22())
	t.Nth23(*s.Nth23())
	return *t
}

type CotaNFTIdBuilder struct {
	smtType Uint16
	cotaId  CotaId
	index   Uint32
}

func (s *CotaNFTIdBuilder) Build() CotaNFTId {
	b := new(bytes.Buffer)
	b.Write(s.smtType.AsSlice())
	b.Write(s.cotaId.AsSlice())
	b.Write(s.index.AsSlice())
	return CotaNFTId{inner: b.Bytes()}
}

func (s *CotaNFTIdBuilder) SmtType(v Uint16) *CotaNFTIdBuilder {
	s.smtType = v
	return s
}

func (s *CotaNFTIdBuilder) CotaId(v CotaId) *CotaNFTIdBuilder {
	s.cotaId = v
	return s
}

func (s *CotaNFTIdBuilder) Index(v Uint32) *CotaNFTIdBuilder {
	s.index = v
	return s
}

func NewCotaNFTIdBuilder() *CotaNFTIdBuilder {
	return &CotaNFTIdBuilder{smtType: Uint16Default(), cotaId: CotaIdDefault(), index: Uint32Default()}
}

type CotaNFTId struct {
	inner []byte
}

func CotaNFTIdFromSliceUnchecked(slice []byte) *CotaNFTId {
	return &CotaNFTId{inner: slice}
}
func (s *CotaNFTId) AsSlice() []byte {
	return s.inner
}

func CotaNFTIdDefault() CotaNFTId {
	return *CotaNFTIdFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func CotaNFTIdFromSlice(slice []byte, _compatible bool) (*CotaNFTId, error) {
	sliceLen := len(slice)
	if sliceLen != 26 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CotaNFTId", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(26)}, " ")
		return nil, errors.New(errMsg)
	}
	return &CotaNFTId{inner: slice}, nil
}

func (s *CotaNFTId) SmtType() *Uint16 {
	ret := Uint16FromSliceUnchecked(s.inner[0:2])
	return ret
}

func (s *CotaNFTId) CotaId() *CotaId {
	ret := CotaIdFromSliceUnchecked(s.inner[2:22])
	return ret
}

func (s *CotaNFTId) Index() *Uint32 {
	ret := Uint32FromSliceUnchecked(s.inner[22:26])
	return ret
}

func (s *CotaNFTId) AsBuilder() CotaNFTIdBuilder {
	ret := NewCotaNFTIdBuilder().SmtType(*s.SmtType()).CotaId(*s.CotaId()).Index(*s.Index())
	return *ret
}

type CotaNFTInfoBuilder struct {
	configure      Byte
	state          Byte
	characteristic Characteristic
}

func (s *CotaNFTInfoBuilder) Build() CotaNFTInfo {
	b := new(bytes.Buffer)
	b.Write(s.configure.AsSlice())
	b.Write(s.state.AsSlice())
	b.Write(s.characteristic.AsSlice())
	return CotaNFTInfo{inner: b.Bytes()}
}

func (s *CotaNFTInfoBuilder) Configure(v Byte) *CotaNFTInfoBuilder {
	s.configure = v
	return s
}

func (s *CotaNFTInfoBuilder) State(v Byte) *CotaNFTInfoBuilder {
	s.state = v
	return s
}

func (s *CotaNFTInfoBuilder) Characteristic(v Characteristic) *CotaNFTInfoBuilder {
	s.characteristic = v
	return s
}

func NewCotaNFTInfoBuilder() *CotaNFTInfoBuilder {
	return &CotaNFTInfoBuilder{configure: ByteDefault(), state: ByteDefault(), characteristic: CharacteristicDefault()}
}

type CotaNFTInfo struct {
	inner []byte
}

func CotaNFTInfoFromSliceUnchecked(slice []byte) *CotaNFTInfo {
	return &CotaNFTInfo{inner: slice}
}
func (s *CotaNFTInfo) AsSlice() []byte {
	return s.inner
}

func CotaNFTInfoDefault() CotaNFTInfo {
	return *CotaNFTInfoFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func CotaNFTInfoFromSlice(slice []byte, _compatible bool) (*CotaNFTInfo, error) {
	sliceLen := len(slice)
	if sliceLen != 22 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CotaNFTInfo", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(22)}, " ")
		return nil, errors.New(errMsg)
	}
	return &CotaNFTInfo{inner: slice}, nil
}

func (s *CotaNFTInfo) Configure() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *CotaNFTInfo) State() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *CotaNFTInfo) Characteristic() *Characteristic {
	ret := CharacteristicFromSliceUnchecked(s.inner[2:22])
	return ret
}

func (s *CotaNFTInfo) AsBuilder() CotaNFTInfoBuilder {
	ret := NewCotaNFTInfoBuilder().Configure(*s.Configure()).State(*s.State()).Characteristic(*s.Characteristic())
	return *ret
}

type HoldCotaNFTKeyVecBuilder struct {
	inner []CotaNFTId
}

func (s *HoldCotaNFTKeyVecBuilder) Build() HoldCotaNFTKeyVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := HoldCotaNFTKeyVec{inner: b.Bytes()}

	return sb
}

func (s *HoldCotaNFTKeyVecBuilder) Set(v []CotaNFTId) *HoldCotaNFTKeyVecBuilder {
	s.inner = v
	return s
}
func (s *HoldCotaNFTKeyVecBuilder) Push(v CotaNFTId) *HoldCotaNFTKeyVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *HoldCotaNFTKeyVecBuilder) Extend(iter []CotaNFTId) *HoldCotaNFTKeyVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewHoldCotaNFTKeyVecBuilder() *HoldCotaNFTKeyVecBuilder {
	return &HoldCotaNFTKeyVecBuilder{[]CotaNFTId{}}
}

type HoldCotaNFTKeyVec struct {
	inner []byte
}

func HoldCotaNFTKeyVecFromSliceUnchecked(slice []byte) *HoldCotaNFTKeyVec {
	return &HoldCotaNFTKeyVec{inner: slice}
}
func (s *HoldCotaNFTKeyVec) AsSlice() []byte {
	return s.inner
}

func HoldCotaNFTKeyVecDefault() HoldCotaNFTKeyVec {
	return *HoldCotaNFTKeyVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func HoldCotaNFTKeyVecFromSlice(slice []byte, _compatible bool) (*HoldCotaNFTKeyVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "HoldCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "HoldCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &HoldCotaNFTKeyVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(26*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "HoldCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &HoldCotaNFTKeyVec{inner: slice}, nil
}

func (s *HoldCotaNFTKeyVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 26*s.ItemCount()
}
func (s *HoldCotaNFTKeyVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *HoldCotaNFTKeyVec) Len() uint {
	return s.ItemCount()
}
func (s *HoldCotaNFTKeyVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *CotaNFTId is nil, index is out of bounds
func (s *HoldCotaNFTKeyVec) Get(index uint) *CotaNFTId {
	var re *CotaNFTId
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 26*index
		end := start + 26
		re = CotaNFTIdFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *HoldCotaNFTKeyVec) AsBuilder() HoldCotaNFTKeyVecBuilder {
	size := s.ItemCount()
	t := NewHoldCotaNFTKeyVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type HoldCotaNFTValueVecBuilder struct {
	inner []CotaNFTInfo
}

func (s *HoldCotaNFTValueVecBuilder) Build() HoldCotaNFTValueVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := HoldCotaNFTValueVec{inner: b.Bytes()}

	return sb
}

func (s *HoldCotaNFTValueVecBuilder) Set(v []CotaNFTInfo) *HoldCotaNFTValueVecBuilder {
	s.inner = v
	return s
}
func (s *HoldCotaNFTValueVecBuilder) Push(v CotaNFTInfo) *HoldCotaNFTValueVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *HoldCotaNFTValueVecBuilder) Extend(iter []CotaNFTInfo) *HoldCotaNFTValueVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewHoldCotaNFTValueVecBuilder() *HoldCotaNFTValueVecBuilder {
	return &HoldCotaNFTValueVecBuilder{[]CotaNFTInfo{}}
}

type HoldCotaNFTValueVec struct {
	inner []byte
}

func HoldCotaNFTValueVecFromSliceUnchecked(slice []byte) *HoldCotaNFTValueVec {
	return &HoldCotaNFTValueVec{inner: slice}
}
func (s *HoldCotaNFTValueVec) AsSlice() []byte {
	return s.inner
}

func HoldCotaNFTValueVecDefault() HoldCotaNFTValueVec {
	return *HoldCotaNFTValueVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func HoldCotaNFTValueVecFromSlice(slice []byte, _compatible bool) (*HoldCotaNFTValueVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "HoldCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "HoldCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &HoldCotaNFTValueVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(22*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "HoldCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &HoldCotaNFTValueVec{inner: slice}, nil
}

func (s *HoldCotaNFTValueVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 22*s.ItemCount()
}
func (s *HoldCotaNFTValueVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *HoldCotaNFTValueVec) Len() uint {
	return s.ItemCount()
}
func (s *HoldCotaNFTValueVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *CotaNFTInfo is nil, index is out of bounds
func (s *HoldCotaNFTValueVec) Get(index uint) *CotaNFTInfo {
	var re *CotaNFTInfo
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 22*index
		end := start + 22
		re = CotaNFTInfoFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *HoldCotaNFTValueVec) AsBuilder() HoldCotaNFTValueVecBuilder {
	size := s.ItemCount()
	t := NewHoldCotaNFTValueVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type RegistryBuilder struct {
	lockHash Byte32
	state    Byte32
}

func (s *RegistryBuilder) Build() Registry {
	b := new(bytes.Buffer)
	b.Write(s.lockHash.AsSlice())
	b.Write(s.state.AsSlice())
	return Registry{inner: b.Bytes()}
}

func (s *RegistryBuilder) LockHash(v Byte32) *RegistryBuilder {
	s.lockHash = v
	return s
}

func (s *RegistryBuilder) State(v Byte32) *RegistryBuilder {
	s.state = v
	return s
}

func NewRegistryBuilder() *RegistryBuilder {
	return &RegistryBuilder{lockHash: Byte32Default(), state: Byte32Default()}
}

type Registry struct {
	inner []byte
}

func RegistryFromSliceUnchecked(slice []byte) *Registry {
	return &Registry{inner: slice}
}
func (s *Registry) AsSlice() []byte {
	return s.inner
}

func RegistryDefault() Registry {
	return *RegistryFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func RegistryFromSlice(slice []byte, _compatible bool) (*Registry, error) {
	sliceLen := len(slice)
	if sliceLen != 64 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Registry", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(64)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Registry{inner: slice}, nil
}

func (s *Registry) LockHash() *Byte32 {
	ret := Byte32FromSliceUnchecked(s.inner[0:32])
	return ret
}

func (s *Registry) State() *Byte32 {
	ret := Byte32FromSliceUnchecked(s.inner[32:64])
	return ret
}

func (s *Registry) AsBuilder() RegistryBuilder {
	ret := NewRegistryBuilder().LockHash(*s.LockHash()).State(*s.State())
	return *ret
}

type RegistryVecBuilder struct {
	inner []Registry
}

func (s *RegistryVecBuilder) Build() RegistryVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := RegistryVec{inner: b.Bytes()}

	return sb
}

func (s *RegistryVecBuilder) Set(v []Registry) *RegistryVecBuilder {
	s.inner = v
	return s
}
func (s *RegistryVecBuilder) Push(v Registry) *RegistryVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *RegistryVecBuilder) Extend(iter []Registry) *RegistryVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewRegistryVecBuilder() *RegistryVecBuilder {
	return &RegistryVecBuilder{[]Registry{}}
}

type RegistryVec struct {
	inner []byte
}

func RegistryVecFromSliceUnchecked(slice []byte) *RegistryVec {
	return &RegistryVec{inner: slice}
}
func (s *RegistryVec) AsSlice() []byte {
	return s.inner
}

func RegistryVecDefault() RegistryVec {
	return *RegistryVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func RegistryVecFromSlice(slice []byte, _compatible bool) (*RegistryVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "RegistryVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "RegistryVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &RegistryVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(64*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "RegistryVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &RegistryVec{inner: slice}, nil
}

func (s *RegistryVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 64*s.ItemCount()
}
func (s *RegistryVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *RegistryVec) Len() uint {
	return s.ItemCount()
}
func (s *RegistryVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *Registry is nil, index is out of bounds
func (s *RegistryVec) Get(index uint) *Registry {
	var re *Registry
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 64*index
		end := start + 64
		re = RegistryFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *RegistryVec) AsBuilder() RegistryVecBuilder {
	size := s.ItemCount()
	t := NewRegistryVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type CotaNFTRegistryEntriesBuilder struct {
	registries RegistryVec
	proof      Bytes
}

func (s *CotaNFTRegistryEntriesBuilder) Build() CotaNFTRegistryEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.registries.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.registries.AsSlice())
	b.Write(s.proof.AsSlice())
	return CotaNFTRegistryEntries{inner: b.Bytes()}
}

func (s *CotaNFTRegistryEntriesBuilder) Registries(v RegistryVec) *CotaNFTRegistryEntriesBuilder {
	s.registries = v
	return s
}

func (s *CotaNFTRegistryEntriesBuilder) Proof(v Bytes) *CotaNFTRegistryEntriesBuilder {
	s.proof = v
	return s
}

func NewCotaNFTRegistryEntriesBuilder() *CotaNFTRegistryEntriesBuilder {
	return &CotaNFTRegistryEntriesBuilder{registries: RegistryVecDefault(), proof: BytesDefault()}
}

type CotaNFTRegistryEntries struct {
	inner []byte
}

func CotaNFTRegistryEntriesFromSliceUnchecked(slice []byte) *CotaNFTRegistryEntries {
	return &CotaNFTRegistryEntries{inner: slice}
}
func (s *CotaNFTRegistryEntries) AsSlice() []byte {
	return s.inner
}

func CotaNFTRegistryEntriesDefault() CotaNFTRegistryEntries {
	return *CotaNFTRegistryEntriesFromSliceUnchecked([]byte{20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func CotaNFTRegistryEntriesFromSlice(slice []byte, compatible bool) (*CotaNFTRegistryEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "CotaNFTRegistryEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CotaNFTRegistryEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
		return &CotaNFTRegistryEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CotaNFTRegistryEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "CotaNFTRegistryEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "CotaNFTRegistryEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = RegistryVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &CotaNFTRegistryEntries{inner: slice}, nil
}

func (s *CotaNFTRegistryEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *CotaNFTRegistryEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *CotaNFTRegistryEntries) Len() uint {
	return s.FieldCount()
}
func (s *CotaNFTRegistryEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *CotaNFTRegistryEntries) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *CotaNFTRegistryEntries) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *CotaNFTRegistryEntries) Registries() *RegistryVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return RegistryVecFromSliceUnchecked(s.inner[start:end])
}

func (s *CotaNFTRegistryEntries) Proof() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *CotaNFTRegistryEntries) AsBuilder() CotaNFTRegistryEntriesBuilder {
	ret := NewCotaNFTRegistryEntriesBuilder().Registries(*s.Registries()).Proof(*s.Proof())
	return *ret
}

type DefineCotaNFTIdBuilder struct {
	smtType Uint16
	cotaId  CotaId
}

func (s *DefineCotaNFTIdBuilder) Build() DefineCotaNFTId {
	b := new(bytes.Buffer)
	b.Write(s.smtType.AsSlice())
	b.Write(s.cotaId.AsSlice())
	return DefineCotaNFTId{inner: b.Bytes()}
}

func (s *DefineCotaNFTIdBuilder) SmtType(v Uint16) *DefineCotaNFTIdBuilder {
	s.smtType = v
	return s
}

func (s *DefineCotaNFTIdBuilder) CotaId(v CotaId) *DefineCotaNFTIdBuilder {
	s.cotaId = v
	return s
}

func NewDefineCotaNFTIdBuilder() *DefineCotaNFTIdBuilder {
	return &DefineCotaNFTIdBuilder{smtType: Uint16Default(), cotaId: CotaIdDefault()}
}

type DefineCotaNFTId struct {
	inner []byte
}

func DefineCotaNFTIdFromSliceUnchecked(slice []byte) *DefineCotaNFTId {
	return &DefineCotaNFTId{inner: slice}
}
func (s *DefineCotaNFTId) AsSlice() []byte {
	return s.inner
}

func DefineCotaNFTIdDefault() DefineCotaNFTId {
	return *DefineCotaNFTIdFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func DefineCotaNFTIdFromSlice(slice []byte, _compatible bool) (*DefineCotaNFTId, error) {
	sliceLen := len(slice)
	if sliceLen != 22 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "DefineCotaNFTId", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(22)}, " ")
		return nil, errors.New(errMsg)
	}
	return &DefineCotaNFTId{inner: slice}, nil
}

func (s *DefineCotaNFTId) SmtType() *Uint16 {
	ret := Uint16FromSliceUnchecked(s.inner[0:2])
	return ret
}

func (s *DefineCotaNFTId) CotaId() *CotaId {
	ret := CotaIdFromSliceUnchecked(s.inner[2:22])
	return ret
}

func (s *DefineCotaNFTId) AsBuilder() DefineCotaNFTIdBuilder {
	ret := NewDefineCotaNFTIdBuilder().SmtType(*s.SmtType()).CotaId(*s.CotaId())
	return *ret
}

type DefineCotaNFTKeyVecBuilder struct {
	inner []DefineCotaNFTId
}

func (s *DefineCotaNFTKeyVecBuilder) Build() DefineCotaNFTKeyVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := DefineCotaNFTKeyVec{inner: b.Bytes()}

	return sb
}

func (s *DefineCotaNFTKeyVecBuilder) Set(v []DefineCotaNFTId) *DefineCotaNFTKeyVecBuilder {
	s.inner = v
	return s
}
func (s *DefineCotaNFTKeyVecBuilder) Push(v DefineCotaNFTId) *DefineCotaNFTKeyVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *DefineCotaNFTKeyVecBuilder) Extend(iter []DefineCotaNFTId) *DefineCotaNFTKeyVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewDefineCotaNFTKeyVecBuilder() *DefineCotaNFTKeyVecBuilder {
	return &DefineCotaNFTKeyVecBuilder{[]DefineCotaNFTId{}}
}

type DefineCotaNFTKeyVec struct {
	inner []byte
}

func DefineCotaNFTKeyVecFromSliceUnchecked(slice []byte) *DefineCotaNFTKeyVec {
	return &DefineCotaNFTKeyVec{inner: slice}
}
func (s *DefineCotaNFTKeyVec) AsSlice() []byte {
	return s.inner
}

func DefineCotaNFTKeyVecDefault() DefineCotaNFTKeyVec {
	return *DefineCotaNFTKeyVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func DefineCotaNFTKeyVecFromSlice(slice []byte, _compatible bool) (*DefineCotaNFTKeyVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "DefineCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "DefineCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &DefineCotaNFTKeyVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(22*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "DefineCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &DefineCotaNFTKeyVec{inner: slice}, nil
}

func (s *DefineCotaNFTKeyVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 22*s.ItemCount()
}
func (s *DefineCotaNFTKeyVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *DefineCotaNFTKeyVec) Len() uint {
	return s.ItemCount()
}
func (s *DefineCotaNFTKeyVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *DefineCotaNFTId is nil, index is out of bounds
func (s *DefineCotaNFTKeyVec) Get(index uint) *DefineCotaNFTId {
	var re *DefineCotaNFTId
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 22*index
		end := start + 22
		re = DefineCotaNFTIdFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *DefineCotaNFTKeyVec) AsBuilder() DefineCotaNFTKeyVecBuilder {
	size := s.ItemCount()
	t := NewDefineCotaNFTKeyVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type DefineCotaNFTValueBuilder struct {
	total     Uint32
	issued    Uint32
	configure Byte
}

func (s *DefineCotaNFTValueBuilder) Build() DefineCotaNFTValue {
	b := new(bytes.Buffer)
	b.Write(s.total.AsSlice())
	b.Write(s.issued.AsSlice())
	b.Write(s.configure.AsSlice())
	return DefineCotaNFTValue{inner: b.Bytes()}
}

func (s *DefineCotaNFTValueBuilder) Total(v Uint32) *DefineCotaNFTValueBuilder {
	s.total = v
	return s
}

func (s *DefineCotaNFTValueBuilder) Issued(v Uint32) *DefineCotaNFTValueBuilder {
	s.issued = v
	return s
}

func (s *DefineCotaNFTValueBuilder) Configure(v Byte) *DefineCotaNFTValueBuilder {
	s.configure = v
	return s
}

func NewDefineCotaNFTValueBuilder() *DefineCotaNFTValueBuilder {
	return &DefineCotaNFTValueBuilder{total: Uint32Default(), issued: Uint32Default(), configure: ByteDefault()}
}

type DefineCotaNFTValue struct {
	inner []byte
}

func DefineCotaNFTValueFromSliceUnchecked(slice []byte) *DefineCotaNFTValue {
	return &DefineCotaNFTValue{inner: slice}
}
func (s *DefineCotaNFTValue) AsSlice() []byte {
	return s.inner
}

func DefineCotaNFTValueDefault() DefineCotaNFTValue {
	return *DefineCotaNFTValueFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func DefineCotaNFTValueFromSlice(slice []byte, _compatible bool) (*DefineCotaNFTValue, error) {
	sliceLen := len(slice)
	if sliceLen != 9 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "DefineCotaNFTValue", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(9)}, " ")
		return nil, errors.New(errMsg)
	}
	return &DefineCotaNFTValue{inner: slice}, nil
}

func (s *DefineCotaNFTValue) Total() *Uint32 {
	ret := Uint32FromSliceUnchecked(s.inner[0:4])
	return ret
}

func (s *DefineCotaNFTValue) Issued() *Uint32 {
	ret := Uint32FromSliceUnchecked(s.inner[4:8])
	return ret
}

func (s *DefineCotaNFTValue) Configure() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *DefineCotaNFTValue) AsBuilder() DefineCotaNFTValueBuilder {
	ret := NewDefineCotaNFTValueBuilder().Total(*s.Total()).Issued(*s.Issued()).Configure(*s.Configure())
	return *ret
}

type DefineCotaNFTValueVecBuilder struct {
	inner []DefineCotaNFTValue
}

func (s *DefineCotaNFTValueVecBuilder) Build() DefineCotaNFTValueVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := DefineCotaNFTValueVec{inner: b.Bytes()}

	return sb
}

func (s *DefineCotaNFTValueVecBuilder) Set(v []DefineCotaNFTValue) *DefineCotaNFTValueVecBuilder {
	s.inner = v
	return s
}
func (s *DefineCotaNFTValueVecBuilder) Push(v DefineCotaNFTValue) *DefineCotaNFTValueVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *DefineCotaNFTValueVecBuilder) Extend(iter []DefineCotaNFTValue) *DefineCotaNFTValueVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewDefineCotaNFTValueVecBuilder() *DefineCotaNFTValueVecBuilder {
	return &DefineCotaNFTValueVecBuilder{[]DefineCotaNFTValue{}}
}

type DefineCotaNFTValueVec struct {
	inner []byte
}

func DefineCotaNFTValueVecFromSliceUnchecked(slice []byte) *DefineCotaNFTValueVec {
	return &DefineCotaNFTValueVec{inner: slice}
}
func (s *DefineCotaNFTValueVec) AsSlice() []byte {
	return s.inner
}

func DefineCotaNFTValueVecDefault() DefineCotaNFTValueVec {
	return *DefineCotaNFTValueVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func DefineCotaNFTValueVecFromSlice(slice []byte, _compatible bool) (*DefineCotaNFTValueVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "DefineCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "DefineCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &DefineCotaNFTValueVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(9*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "DefineCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &DefineCotaNFTValueVec{inner: slice}, nil
}

func (s *DefineCotaNFTValueVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 9*s.ItemCount()
}
func (s *DefineCotaNFTValueVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *DefineCotaNFTValueVec) Len() uint {
	return s.ItemCount()
}
func (s *DefineCotaNFTValueVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *DefineCotaNFTValue is nil, index is out of bounds
func (s *DefineCotaNFTValueVec) Get(index uint) *DefineCotaNFTValue {
	var re *DefineCotaNFTValue
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 9*index
		end := start + 9
		re = DefineCotaNFTValueFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *DefineCotaNFTValueVec) AsBuilder() DefineCotaNFTValueVecBuilder {
	size := s.ItemCount()
	t := NewDefineCotaNFTValueVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type DefineCotaNFTEntriesBuilder struct {
	defineKeys   DefineCotaNFTKeyVec
	defineValues DefineCotaNFTValueVec
	proof        Bytes
	action       Bytes
}

func (s *DefineCotaNFTEntriesBuilder) Build() DefineCotaNFTEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (4 + 1)
	offsets := make([]uint32, 0, 4)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.defineKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.defineValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.defineKeys.AsSlice())
	b.Write(s.defineValues.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.action.AsSlice())
	return DefineCotaNFTEntries{inner: b.Bytes()}
}

func (s *DefineCotaNFTEntriesBuilder) DefineKeys(v DefineCotaNFTKeyVec) *DefineCotaNFTEntriesBuilder {
	s.defineKeys = v
	return s
}

func (s *DefineCotaNFTEntriesBuilder) DefineValues(v DefineCotaNFTValueVec) *DefineCotaNFTEntriesBuilder {
	s.defineValues = v
	return s
}

func (s *DefineCotaNFTEntriesBuilder) Proof(v Bytes) *DefineCotaNFTEntriesBuilder {
	s.proof = v
	return s
}

func (s *DefineCotaNFTEntriesBuilder) Action(v Bytes) *DefineCotaNFTEntriesBuilder {
	s.action = v
	return s
}

func NewDefineCotaNFTEntriesBuilder() *DefineCotaNFTEntriesBuilder {
	return &DefineCotaNFTEntriesBuilder{defineKeys: DefineCotaNFTKeyVecDefault(), defineValues: DefineCotaNFTValueVecDefault(), proof: BytesDefault(), action: BytesDefault()}
}

type DefineCotaNFTEntries struct {
	inner []byte
}

func DefineCotaNFTEntriesFromSliceUnchecked(slice []byte) *DefineCotaNFTEntries {
	return &DefineCotaNFTEntries{inner: slice}
}
func (s *DefineCotaNFTEntries) AsSlice() []byte {
	return s.inner
}

func DefineCotaNFTEntriesDefault() DefineCotaNFTEntries {
	return *DefineCotaNFTEntriesFromSliceUnchecked([]byte{36, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func DefineCotaNFTEntriesFromSlice(slice []byte, compatible bool) (*DefineCotaNFTEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "DefineCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "DefineCotaNFTEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 4 == 0 {
		return &DefineCotaNFTEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "DefineCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "DefineCotaNFTEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "DefineCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 4 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 4 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = DefineCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = DefineCotaNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	return &DefineCotaNFTEntries{inner: slice}, nil
}

func (s *DefineCotaNFTEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *DefineCotaNFTEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *DefineCotaNFTEntries) Len() uint {
	return s.FieldCount()
}
func (s *DefineCotaNFTEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *DefineCotaNFTEntries) CountExtraFields() uint {
	return s.FieldCount() - 4
}

func (s *DefineCotaNFTEntries) HasExtraFields() bool {
	return 4 != s.FieldCount()
}

func (s *DefineCotaNFTEntries) DefineKeys() *DefineCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return DefineCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *DefineCotaNFTEntries) DefineValues() *DefineCotaNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return DefineCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *DefineCotaNFTEntries) Proof() *Bytes {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *DefineCotaNFTEntries) Action() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[16:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[20:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *DefineCotaNFTEntries) AsBuilder() DefineCotaNFTEntriesBuilder {
	ret := NewDefineCotaNFTEntriesBuilder().DefineKeys(*s.DefineKeys()).DefineValues(*s.DefineValues()).Proof(*s.Proof()).Action(*s.Action())
	return *ret
}

type MintCotaNFTEntriesBuilder struct {
	defineKeys       DefineCotaNFTKeyVec
	defineOldValues  DefineCotaNFTValueVec
	defineNewValues  DefineCotaNFTValueVec
	withdrawalKeys   WithdrawalCotaNFTKeyVec
	withdrawalValues WithdrawalCotaNFTValueVec
	proof            Bytes
	action           Bytes
}

func (s *MintCotaNFTEntriesBuilder) Build() MintCotaNFTEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (7 + 1)
	offsets := make([]uint32, 0, 7)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.defineKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.defineOldValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.defineNewValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawalKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawalValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.defineKeys.AsSlice())
	b.Write(s.defineOldValues.AsSlice())
	b.Write(s.defineNewValues.AsSlice())
	b.Write(s.withdrawalKeys.AsSlice())
	b.Write(s.withdrawalValues.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.action.AsSlice())
	return MintCotaNFTEntries{inner: b.Bytes()}
}

func (s *MintCotaNFTEntriesBuilder) DefineKeys(v DefineCotaNFTKeyVec) *MintCotaNFTEntriesBuilder {
	s.defineKeys = v
	return s
}

func (s *MintCotaNFTEntriesBuilder) DefineOldValues(v DefineCotaNFTValueVec) *MintCotaNFTEntriesBuilder {
	s.defineOldValues = v
	return s
}

func (s *MintCotaNFTEntriesBuilder) DefineNewValues(v DefineCotaNFTValueVec) *MintCotaNFTEntriesBuilder {
	s.defineNewValues = v
	return s
}

func (s *MintCotaNFTEntriesBuilder) WithdrawalKeys(v WithdrawalCotaNFTKeyVec) *MintCotaNFTEntriesBuilder {
	s.withdrawalKeys = v
	return s
}

func (s *MintCotaNFTEntriesBuilder) WithdrawalValues(v WithdrawalCotaNFTValueVec) *MintCotaNFTEntriesBuilder {
	s.withdrawalValues = v
	return s
}

func (s *MintCotaNFTEntriesBuilder) Proof(v Bytes) *MintCotaNFTEntriesBuilder {
	s.proof = v
	return s
}

func (s *MintCotaNFTEntriesBuilder) Action(v Bytes) *MintCotaNFTEntriesBuilder {
	s.action = v
	return s
}

func NewMintCotaNFTEntriesBuilder() *MintCotaNFTEntriesBuilder {
	return &MintCotaNFTEntriesBuilder{defineKeys: DefineCotaNFTKeyVecDefault(), defineOldValues: DefineCotaNFTValueVecDefault(), defineNewValues: DefineCotaNFTValueVecDefault(), withdrawalKeys: WithdrawalCotaNFTKeyVecDefault(), withdrawalValues: WithdrawalCotaNFTValueVecDefault(), proof: BytesDefault(), action: BytesDefault()}
}

type MintCotaNFTEntries struct {
	inner []byte
}

func MintCotaNFTEntriesFromSliceUnchecked(slice []byte) *MintCotaNFTEntries {
	return &MintCotaNFTEntries{inner: slice}
}
func (s *MintCotaNFTEntries) AsSlice() []byte {
	return s.inner
}

func MintCotaNFTEntriesDefault() MintCotaNFTEntries {
	return *MintCotaNFTEntriesFromSliceUnchecked([]byte{60, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func MintCotaNFTEntriesFromSlice(slice []byte, compatible bool) (*MintCotaNFTEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "MintCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "MintCotaNFTEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 7 == 0 {
		return &MintCotaNFTEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "MintCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "MintCotaNFTEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "MintCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 7 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 7 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = DefineCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = DefineCotaNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = DefineCotaNFTValueVecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTKeyVecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTValueVecFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	return &MintCotaNFTEntries{inner: slice}, nil
}

func (s *MintCotaNFTEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *MintCotaNFTEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *MintCotaNFTEntries) Len() uint {
	return s.FieldCount()
}
func (s *MintCotaNFTEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *MintCotaNFTEntries) CountExtraFields() uint {
	return s.FieldCount() - 7
}

func (s *MintCotaNFTEntries) HasExtraFields() bool {
	return 7 != s.FieldCount()
}

func (s *MintCotaNFTEntries) DefineKeys() *DefineCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return DefineCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCotaNFTEntries) DefineOldValues() *DefineCotaNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return DefineCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCotaNFTEntries) DefineNewValues() *DefineCotaNFTValueVec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return DefineCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCotaNFTEntries) WithdrawalKeys() *WithdrawalCotaNFTKeyVec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return WithdrawalCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCotaNFTEntries) WithdrawalValues() *WithdrawalCotaNFTValueVec {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return WithdrawalCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCotaNFTEntries) Proof() *Bytes {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCotaNFTEntries) Action() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[28:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[32:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *MintCotaNFTEntries) AsBuilder() MintCotaNFTEntriesBuilder {
	ret := NewMintCotaNFTEntriesBuilder().DefineKeys(*s.DefineKeys()).DefineOldValues(*s.DefineOldValues()).DefineNewValues(*s.DefineNewValues()).WithdrawalKeys(*s.WithdrawalKeys()).WithdrawalValues(*s.WithdrawalValues()).Proof(*s.Proof()).Action(*s.Action())
	return *ret
}

type WithdrawalCotaNFTKeyVecBuilder struct {
	inner []CotaNFTId
}

func (s *WithdrawalCotaNFTKeyVecBuilder) Build() WithdrawalCotaNFTKeyVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := WithdrawalCotaNFTKeyVec{inner: b.Bytes()}

	return sb
}

func (s *WithdrawalCotaNFTKeyVecBuilder) Set(v []CotaNFTId) *WithdrawalCotaNFTKeyVecBuilder {
	s.inner = v
	return s
}
func (s *WithdrawalCotaNFTKeyVecBuilder) Push(v CotaNFTId) *WithdrawalCotaNFTKeyVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *WithdrawalCotaNFTKeyVecBuilder) Extend(iter []CotaNFTId) *WithdrawalCotaNFTKeyVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewWithdrawalCotaNFTKeyVecBuilder() *WithdrawalCotaNFTKeyVecBuilder {
	return &WithdrawalCotaNFTKeyVecBuilder{[]CotaNFTId{}}
}

type WithdrawalCotaNFTKeyVec struct {
	inner []byte
}

func WithdrawalCotaNFTKeyVecFromSliceUnchecked(slice []byte) *WithdrawalCotaNFTKeyVec {
	return &WithdrawalCotaNFTKeyVec{inner: slice}
}
func (s *WithdrawalCotaNFTKeyVec) AsSlice() []byte {
	return s.inner
}

func WithdrawalCotaNFTKeyVecDefault() WithdrawalCotaNFTKeyVec {
	return *WithdrawalCotaNFTKeyVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func WithdrawalCotaNFTKeyVecFromSlice(slice []byte, _compatible bool) (*WithdrawalCotaNFTKeyVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &WithdrawalCotaNFTKeyVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(26*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &WithdrawalCotaNFTKeyVec{inner: slice}, nil
}

func (s *WithdrawalCotaNFTKeyVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 26*s.ItemCount()
}
func (s *WithdrawalCotaNFTKeyVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *WithdrawalCotaNFTKeyVec) Len() uint {
	return s.ItemCount()
}
func (s *WithdrawalCotaNFTKeyVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *CotaNFTId is nil, index is out of bounds
func (s *WithdrawalCotaNFTKeyVec) Get(index uint) *CotaNFTId {
	var re *CotaNFTId
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 26*index
		end := start + 26
		re = CotaNFTIdFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *WithdrawalCotaNFTKeyVec) AsBuilder() WithdrawalCotaNFTKeyVecBuilder {
	size := s.ItemCount()
	t := NewWithdrawalCotaNFTKeyVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type WithdrawalCotaNFTValueBuilder struct {
	nftInfo  CotaNFTInfo
	to_lock  Bytes
	outPoint OutPointSlice
}

func (s *WithdrawalCotaNFTValueBuilder) Build() WithdrawalCotaNFTValue {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.nftInfo.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.to_lock.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.outPoint.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.nftInfo.AsSlice())
	b.Write(s.to_lock.AsSlice())
	b.Write(s.outPoint.AsSlice())
	return WithdrawalCotaNFTValue{inner: b.Bytes()}
}

func (s *WithdrawalCotaNFTValueBuilder) NftInfo(v CotaNFTInfo) *WithdrawalCotaNFTValueBuilder {
	s.nftInfo = v
	return s
}

func (s *WithdrawalCotaNFTValueBuilder) ToLock(v Bytes) *WithdrawalCotaNFTValueBuilder {
	s.to_lock = v
	return s
}

func (s *WithdrawalCotaNFTValueBuilder) OutPoint(v OutPointSlice) *WithdrawalCotaNFTValueBuilder {
	s.outPoint = v
	return s
}

func NewWithdrawalCotaNFTValueBuilder() *WithdrawalCotaNFTValueBuilder {
	return &WithdrawalCotaNFTValueBuilder{nftInfo: CotaNFTInfoDefault(), to_lock: BytesDefault(), outPoint: OutPointSliceDefault()}
}

type WithdrawalCotaNFTValue struct {
	inner []byte
}

func WithdrawalCotaNFTValueFromSliceUnchecked(slice []byte) *WithdrawalCotaNFTValue {
	return &WithdrawalCotaNFTValue{inner: slice}
}
func (s *WithdrawalCotaNFTValue) AsSlice() []byte {
	return s.inner
}

func WithdrawalCotaNFTValueDefault() WithdrawalCotaNFTValue {
	return *WithdrawalCotaNFTValueFromSliceUnchecked([]byte{66, 0, 0, 0, 16, 0, 0, 0, 38, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func WithdrawalCotaNFTValueFromSlice(slice []byte, compatible bool) (*WithdrawalCotaNFTValue, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTValue", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTValue", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 3 == 0 {
		return &WithdrawalCotaNFTValue{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTValue", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "WithdrawalCotaNFTValue", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTValue", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = CotaNFTInfoFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = OutPointSliceFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &WithdrawalCotaNFTValue{inner: slice}, nil
}

func (s *WithdrawalCotaNFTValue) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *WithdrawalCotaNFTValue) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *WithdrawalCotaNFTValue) Len() uint {
	return s.FieldCount()
}
func (s *WithdrawalCotaNFTValue) IsEmpty() bool {
	return s.Len() == 0
}
func (s *WithdrawalCotaNFTValue) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *WithdrawalCotaNFTValue) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *WithdrawalCotaNFTValue) NftInfo() *CotaNFTInfo {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return CotaNFTInfoFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawalCotaNFTValue) ToLock() *Bytes {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawalCotaNFTValue) OutPoint() *OutPointSlice {
	var ret *OutPointSlice
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = OutPointSliceFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = OutPointSliceFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *WithdrawalCotaNFTValue) AsBuilder() WithdrawalCotaNFTValueBuilder {
	ret := NewWithdrawalCotaNFTValueBuilder().NftInfo(*s.NftInfo()).ToLock(*s.ToLock()).OutPoint(*s.OutPoint())
	return *ret
}

type WithdrawalCotaNFTValueVecBuilder struct {
	inner []WithdrawalCotaNFTValue
}

func (s *WithdrawalCotaNFTValueVecBuilder) Build() WithdrawalCotaNFTValueVec {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return WithdrawalCotaNFTValueVec{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return WithdrawalCotaNFTValueVec{inner: b.Bytes()}
}

func (s *WithdrawalCotaNFTValueVecBuilder) Set(v []WithdrawalCotaNFTValue) *WithdrawalCotaNFTValueVecBuilder {
	s.inner = v
	return s
}
func (s *WithdrawalCotaNFTValueVecBuilder) Push(v WithdrawalCotaNFTValue) *WithdrawalCotaNFTValueVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *WithdrawalCotaNFTValueVecBuilder) Extend(iter []WithdrawalCotaNFTValue) *WithdrawalCotaNFTValueVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewWithdrawalCotaNFTValueVecBuilder() *WithdrawalCotaNFTValueVecBuilder {
	return &WithdrawalCotaNFTValueVecBuilder{[]WithdrawalCotaNFTValue{}}
}

type WithdrawalCotaNFTValueVec struct {
	inner []byte
}

func WithdrawalCotaNFTValueVecFromSliceUnchecked(slice []byte) *WithdrawalCotaNFTValueVec {
	return &WithdrawalCotaNFTValueVec{inner: slice}
}
func (s *WithdrawalCotaNFTValueVec) AsSlice() []byte {
	return s.inner
}

func WithdrawalCotaNFTValueVecDefault() WithdrawalCotaNFTValueVec {
	return *WithdrawalCotaNFTValueVecFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func WithdrawalCotaNFTValueVecFromSlice(slice []byte, compatible bool) (*WithdrawalCotaNFTValueVec, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &WithdrawalCotaNFTValueVec{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "WithdrawalCotaNFTValueVec", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "WithdrawalCotaNFTValueVec"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := WithdrawalCotaNFTValueFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &WithdrawalCotaNFTValueVec{inner: slice}, nil
}

func (s *WithdrawalCotaNFTValueVec) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *WithdrawalCotaNFTValueVec) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *WithdrawalCotaNFTValueVec) Len() uint {
	return s.ItemCount()
}
func (s *WithdrawalCotaNFTValueVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *WithdrawalCotaNFTValue is nil, index is out of bounds
func (s *WithdrawalCotaNFTValueVec) Get(index uint) *WithdrawalCotaNFTValue {
	var b *WithdrawalCotaNFTValue
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = WithdrawalCotaNFTValueFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = WithdrawalCotaNFTValueFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *WithdrawalCotaNFTValueVec) AsBuilder() WithdrawalCotaNFTValueVecBuilder {
	size := s.ItemCount()
	t := NewWithdrawalCotaNFTValueVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type WithdrawalCotaNFTEntriesBuilder struct {
	holdKeys         HoldCotaNFTKeyVec
	holdValues       HoldCotaNFTValueVec
	withdrawalKeys   WithdrawalCotaNFTKeyVec
	withdrawalValues WithdrawalCotaNFTValueVec
	proof            Bytes
	action           Bytes
}

func (s *WithdrawalCotaNFTEntriesBuilder) Build() WithdrawalCotaNFTEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (6 + 1)
	offsets := make([]uint32, 0, 6)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.holdKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.holdValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawalKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawalValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.holdKeys.AsSlice())
	b.Write(s.holdValues.AsSlice())
	b.Write(s.withdrawalKeys.AsSlice())
	b.Write(s.withdrawalValues.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.action.AsSlice())
	return WithdrawalCotaNFTEntries{inner: b.Bytes()}
}

func (s *WithdrawalCotaNFTEntriesBuilder) HoldKeys(v HoldCotaNFTKeyVec) *WithdrawalCotaNFTEntriesBuilder {
	s.holdKeys = v
	return s
}

func (s *WithdrawalCotaNFTEntriesBuilder) HoldValues(v HoldCotaNFTValueVec) *WithdrawalCotaNFTEntriesBuilder {
	s.holdValues = v
	return s
}

func (s *WithdrawalCotaNFTEntriesBuilder) WithdrawalKeys(v WithdrawalCotaNFTKeyVec) *WithdrawalCotaNFTEntriesBuilder {
	s.withdrawalKeys = v
	return s
}

func (s *WithdrawalCotaNFTEntriesBuilder) WithdrawalValues(v WithdrawalCotaNFTValueVec) *WithdrawalCotaNFTEntriesBuilder {
	s.withdrawalValues = v
	return s
}

func (s *WithdrawalCotaNFTEntriesBuilder) Proof(v Bytes) *WithdrawalCotaNFTEntriesBuilder {
	s.proof = v
	return s
}

func (s *WithdrawalCotaNFTEntriesBuilder) Action(v Bytes) *WithdrawalCotaNFTEntriesBuilder {
	s.action = v
	return s
}

func NewWithdrawalCotaNFTEntriesBuilder() *WithdrawalCotaNFTEntriesBuilder {
	return &WithdrawalCotaNFTEntriesBuilder{holdKeys: HoldCotaNFTKeyVecDefault(), holdValues: HoldCotaNFTValueVecDefault(), withdrawalKeys: WithdrawalCotaNFTKeyVecDefault(), withdrawalValues: WithdrawalCotaNFTValueVecDefault(), proof: BytesDefault(), action: BytesDefault()}
}

type WithdrawalCotaNFTEntries struct {
	inner []byte
}

func WithdrawalCotaNFTEntriesFromSliceUnchecked(slice []byte) *WithdrawalCotaNFTEntries {
	return &WithdrawalCotaNFTEntries{inner: slice}
}
func (s *WithdrawalCotaNFTEntries) AsSlice() []byte {
	return s.inner
}

func WithdrawalCotaNFTEntriesDefault() WithdrawalCotaNFTEntries {
	return *WithdrawalCotaNFTEntriesFromSliceUnchecked([]byte{52, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func WithdrawalCotaNFTEntriesFromSlice(slice []byte, compatible bool) (*WithdrawalCotaNFTEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 6 == 0 {
		return &WithdrawalCotaNFTEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "WithdrawalCotaNFTEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 6 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 6 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = HoldCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HoldCotaNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTKeyVecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTValueVecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	return &WithdrawalCotaNFTEntries{inner: slice}, nil
}

func (s *WithdrawalCotaNFTEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *WithdrawalCotaNFTEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *WithdrawalCotaNFTEntries) Len() uint {
	return s.FieldCount()
}
func (s *WithdrawalCotaNFTEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *WithdrawalCotaNFTEntries) CountExtraFields() uint {
	return s.FieldCount() - 6
}

func (s *WithdrawalCotaNFTEntries) HasExtraFields() bool {
	return 6 != s.FieldCount()
}

func (s *WithdrawalCotaNFTEntries) HoldKeys() *HoldCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return HoldCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawalCotaNFTEntries) HoldValues() *HoldCotaNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return HoldCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawalCotaNFTEntries) WithdrawalKeys() *WithdrawalCotaNFTKeyVec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return WithdrawalCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawalCotaNFTEntries) WithdrawalValues() *WithdrawalCotaNFTValueVec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return WithdrawalCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawalCotaNFTEntries) Proof() *Bytes {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawalCotaNFTEntries) Action() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[24:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[28:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *WithdrawalCotaNFTEntries) AsBuilder() WithdrawalCotaNFTEntriesBuilder {
	ret := NewWithdrawalCotaNFTEntriesBuilder().HoldKeys(*s.HoldKeys()).HoldValues(*s.HoldValues()).WithdrawalKeys(*s.WithdrawalKeys()).WithdrawalValues(*s.WithdrawalValues()).Proof(*s.Proof()).Action(*s.Action())
	return *ret
}

type ClaimCotaNFTKeyBuilder struct {
	nftId    CotaNFTId
	outPoint OutPointSlice
}

func (s *ClaimCotaNFTKeyBuilder) Build() ClaimCotaNFTKey {
	b := new(bytes.Buffer)
	b.Write(s.nftId.AsSlice())
	b.Write(s.outPoint.AsSlice())
	return ClaimCotaNFTKey{inner: b.Bytes()}
}

func (s *ClaimCotaNFTKeyBuilder) NftId(v CotaNFTId) *ClaimCotaNFTKeyBuilder {
	s.nftId = v
	return s
}

func (s *ClaimCotaNFTKeyBuilder) OutPoint(v OutPointSlice) *ClaimCotaNFTKeyBuilder {
	s.outPoint = v
	return s
}

func NewClaimCotaNFTKeyBuilder() *ClaimCotaNFTKeyBuilder {
	return &ClaimCotaNFTKeyBuilder{nftId: CotaNFTIdDefault(), outPoint: OutPointSliceDefault()}
}

type ClaimCotaNFTKey struct {
	inner []byte
}

func ClaimCotaNFTKeyFromSliceUnchecked(slice []byte) *ClaimCotaNFTKey {
	return &ClaimCotaNFTKey{inner: slice}
}
func (s *ClaimCotaNFTKey) AsSlice() []byte {
	return s.inner
}

func ClaimCotaNFTKeyDefault() ClaimCotaNFTKey {
	return *ClaimCotaNFTKeyFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ClaimCotaNFTKeyFromSlice(slice []byte, _compatible bool) (*ClaimCotaNFTKey, error) {
	sliceLen := len(slice)
	if sliceLen != 50 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimCotaNFTKey", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(50)}, " ")
		return nil, errors.New(errMsg)
	}
	return &ClaimCotaNFTKey{inner: slice}, nil
}

func (s *ClaimCotaNFTKey) NftId() *CotaNFTId {
	ret := CotaNFTIdFromSliceUnchecked(s.inner[0:26])
	return ret
}

func (s *ClaimCotaNFTKey) OutPoint() *OutPointSlice {
	ret := OutPointSliceFromSliceUnchecked(s.inner[26:50])
	return ret
}

func (s *ClaimCotaNFTKey) AsBuilder() ClaimCotaNFTKeyBuilder {
	ret := NewClaimCotaNFTKeyBuilder().NftId(*s.NftId()).OutPoint(*s.OutPoint())
	return *ret
}

type ClaimCotaNFTKeyVecBuilder struct {
	inner []ClaimCotaNFTKey
}

func (s *ClaimCotaNFTKeyVecBuilder) Build() ClaimCotaNFTKeyVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := ClaimCotaNFTKeyVec{inner: b.Bytes()}

	return sb
}

func (s *ClaimCotaNFTKeyVecBuilder) Set(v []ClaimCotaNFTKey) *ClaimCotaNFTKeyVecBuilder {
	s.inner = v
	return s
}
func (s *ClaimCotaNFTKeyVecBuilder) Push(v ClaimCotaNFTKey) *ClaimCotaNFTKeyVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *ClaimCotaNFTKeyVecBuilder) Extend(iter []ClaimCotaNFTKey) *ClaimCotaNFTKeyVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewClaimCotaNFTKeyVecBuilder() *ClaimCotaNFTKeyVecBuilder {
	return &ClaimCotaNFTKeyVecBuilder{[]ClaimCotaNFTKey{}}
}

type ClaimCotaNFTKeyVec struct {
	inner []byte
}

func ClaimCotaNFTKeyVecFromSliceUnchecked(slice []byte) *ClaimCotaNFTKeyVec {
	return &ClaimCotaNFTKeyVec{inner: slice}
}
func (s *ClaimCotaNFTKeyVec) AsSlice() []byte {
	return s.inner
}

func ClaimCotaNFTKeyVecDefault() ClaimCotaNFTKeyVec {
	return *ClaimCotaNFTKeyVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func ClaimCotaNFTKeyVecFromSlice(slice []byte, _compatible bool) (*ClaimCotaNFTKeyVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &ClaimCotaNFTKeyVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(50*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &ClaimCotaNFTKeyVec{inner: slice}, nil
}

func (s *ClaimCotaNFTKeyVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 50*s.ItemCount()
}
func (s *ClaimCotaNFTKeyVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *ClaimCotaNFTKeyVec) Len() uint {
	return s.ItemCount()
}
func (s *ClaimCotaNFTKeyVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *ClaimCotaNFTKey is nil, index is out of bounds
func (s *ClaimCotaNFTKeyVec) Get(index uint) *ClaimCotaNFTKey {
	var re *ClaimCotaNFTKey
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 50*index
		end := start + 50
		re = ClaimCotaNFTKeyFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *ClaimCotaNFTKeyVec) AsBuilder() ClaimCotaNFTKeyVecBuilder {
	size := s.ItemCount()
	t := NewClaimCotaNFTKeyVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type ClaimCotaNFTValueVecBuilder struct {
	inner []Byte32
}

func (s *ClaimCotaNFTValueVecBuilder) Build() ClaimCotaNFTValueVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := ClaimCotaNFTValueVec{inner: b.Bytes()}

	return sb
}

func (s *ClaimCotaNFTValueVecBuilder) Set(v []Byte32) *ClaimCotaNFTValueVecBuilder {
	s.inner = v
	return s
}
func (s *ClaimCotaNFTValueVecBuilder) Push(v Byte32) *ClaimCotaNFTValueVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *ClaimCotaNFTValueVecBuilder) Extend(iter []Byte32) *ClaimCotaNFTValueVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewClaimCotaNFTValueVecBuilder() *ClaimCotaNFTValueVecBuilder {
	return &ClaimCotaNFTValueVecBuilder{[]Byte32{}}
}

type ClaimCotaNFTValueVec struct {
	inner []byte
}

func ClaimCotaNFTValueVecFromSliceUnchecked(slice []byte) *ClaimCotaNFTValueVec {
	return &ClaimCotaNFTValueVec{inner: slice}
}
func (s *ClaimCotaNFTValueVec) AsSlice() []byte {
	return s.inner
}

func ClaimCotaNFTValueVecDefault() ClaimCotaNFTValueVec {
	return *ClaimCotaNFTValueVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func ClaimCotaNFTValueVecFromSlice(slice []byte, _compatible bool) (*ClaimCotaNFTValueVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &ClaimCotaNFTValueVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(32*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &ClaimCotaNFTValueVec{inner: slice}, nil
}

func (s *ClaimCotaNFTValueVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 32*s.ItemCount()
}
func (s *ClaimCotaNFTValueVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *ClaimCotaNFTValueVec) Len() uint {
	return s.ItemCount()
}
func (s *ClaimCotaNFTValueVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *Byte32 is nil, index is out of bounds
func (s *ClaimCotaNFTValueVec) Get(index uint) *Byte32 {
	var re *Byte32
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 32*index
		end := start + 32
		re = Byte32FromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *ClaimCotaNFTValueVec) AsBuilder() ClaimCotaNFTValueVecBuilder {
	size := s.ItemCount()
	t := NewClaimCotaNFTValueVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type ClaimCotaNFTEntriesBuilder struct {
	holdKeys        HoldCotaNFTKeyVec
	holdValues      HoldCotaNFTValueVec
	claimKeys       ClaimCotaNFTKeyVec
	claimValues     ClaimCotaNFTValueVec
	proof           Bytes
	withdrawalProof Bytes
	action          Bytes
}

func (s *ClaimCotaNFTEntriesBuilder) Build() ClaimCotaNFTEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (7 + 1)
	offsets := make([]uint32, 0, 7)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.holdKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.holdValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claimKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claimValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawalProof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.holdKeys.AsSlice())
	b.Write(s.holdValues.AsSlice())
	b.Write(s.claimKeys.AsSlice())
	b.Write(s.claimValues.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.withdrawalProof.AsSlice())
	b.Write(s.action.AsSlice())
	return ClaimCotaNFTEntries{inner: b.Bytes()}
}

func (s *ClaimCotaNFTEntriesBuilder) HoldKeys(v HoldCotaNFTKeyVec) *ClaimCotaNFTEntriesBuilder {
	s.holdKeys = v
	return s
}

func (s *ClaimCotaNFTEntriesBuilder) HoldValues(v HoldCotaNFTValueVec) *ClaimCotaNFTEntriesBuilder {
	s.holdValues = v
	return s
}

func (s *ClaimCotaNFTEntriesBuilder) ClaimKeys(v ClaimCotaNFTKeyVec) *ClaimCotaNFTEntriesBuilder {
	s.claimKeys = v
	return s
}

func (s *ClaimCotaNFTEntriesBuilder) ClaimValues(v ClaimCotaNFTValueVec) *ClaimCotaNFTEntriesBuilder {
	s.claimValues = v
	return s
}

func (s *ClaimCotaNFTEntriesBuilder) Proof(v Bytes) *ClaimCotaNFTEntriesBuilder {
	s.proof = v
	return s
}

func (s *ClaimCotaNFTEntriesBuilder) WithdrawalProof(v Bytes) *ClaimCotaNFTEntriesBuilder {
	s.withdrawalProof = v
	return s
}

func (s *ClaimCotaNFTEntriesBuilder) Action(v Bytes) *ClaimCotaNFTEntriesBuilder {
	s.action = v
	return s
}

func NewClaimCotaNFTEntriesBuilder() *ClaimCotaNFTEntriesBuilder {
	return &ClaimCotaNFTEntriesBuilder{holdKeys: HoldCotaNFTKeyVecDefault(), holdValues: HoldCotaNFTValueVecDefault(), claimKeys: ClaimCotaNFTKeyVecDefault(), claimValues: ClaimCotaNFTValueVecDefault(), proof: BytesDefault(), withdrawalProof: BytesDefault(), action: BytesDefault()}
}

type ClaimCotaNFTEntries struct {
	inner []byte
}

func ClaimCotaNFTEntriesFromSliceUnchecked(slice []byte) *ClaimCotaNFTEntries {
	return &ClaimCotaNFTEntries{inner: slice}
}
func (s *ClaimCotaNFTEntries) AsSlice() []byte {
	return s.inner
}

func ClaimCotaNFTEntriesDefault() ClaimCotaNFTEntries {
	return *ClaimCotaNFTEntriesFromSliceUnchecked([]byte{60, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ClaimCotaNFTEntriesFromSlice(slice []byte, compatible bool) (*ClaimCotaNFTEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimCotaNFTEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 7 == 0 {
		return &ClaimCotaNFTEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ClaimCotaNFTEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 7 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 7 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = HoldCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HoldCotaNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimCotaNFTKeyVecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimCotaNFTValueVecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	return &ClaimCotaNFTEntries{inner: slice}, nil
}

func (s *ClaimCotaNFTEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ClaimCotaNFTEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ClaimCotaNFTEntries) Len() uint {
	return s.FieldCount()
}
func (s *ClaimCotaNFTEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ClaimCotaNFTEntries) CountExtraFields() uint {
	return s.FieldCount() - 7
}

func (s *ClaimCotaNFTEntries) HasExtraFields() bool {
	return 7 != s.FieldCount()
}

func (s *ClaimCotaNFTEntries) HoldKeys() *HoldCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return HoldCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTEntries) HoldValues() *HoldCotaNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return HoldCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTEntries) ClaimKeys() *ClaimCotaNFTKeyVec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return ClaimCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTEntries) ClaimValues() *ClaimCotaNFTValueVec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return ClaimCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTEntries) Proof() *Bytes {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTEntries) WithdrawalProof() *Bytes {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTEntries) Action() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[28:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[32:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ClaimCotaNFTEntries) AsBuilder() ClaimCotaNFTEntriesBuilder {
	ret := NewClaimCotaNFTEntriesBuilder().HoldKeys(*s.HoldKeys()).HoldValues(*s.HoldValues()).ClaimKeys(*s.ClaimKeys()).ClaimValues(*s.ClaimValues()).Proof(*s.Proof()).WithdrawalProof(*s.WithdrawalProof()).Action(*s.Action())
	return *ret
}

type TransferCotaNFTEntriesBuilder struct {
	claim_keys        ClaimCotaNFTKeyVec
	claim_values      ClaimCotaNFTValueVec
	withdrawal_keys   WithdrawalCotaNFTKeyVec
	withdrawal_values WithdrawalCotaNFTValueVec
	proof             Bytes
	withdrawal_proof  Bytes
	action            Bytes
}

func (s *TransferCotaNFTEntriesBuilder) Build() TransferCotaNFTEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (7 + 1)
	offsets := make([]uint32, 0, 7)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claim_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claim_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.claim_keys.AsSlice())
	b.Write(s.claim_values.AsSlice())
	b.Write(s.withdrawal_keys.AsSlice())
	b.Write(s.withdrawal_values.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.withdrawal_proof.AsSlice())
	b.Write(s.action.AsSlice())
	return TransferCotaNFTEntries{inner: b.Bytes()}
}

func (s *TransferCotaNFTEntriesBuilder) ClaimKeys(v ClaimCotaNFTKeyVec) *TransferCotaNFTEntriesBuilder {
	s.claim_keys = v
	return s
}

func (s *TransferCotaNFTEntriesBuilder) ClaimValues(v ClaimCotaNFTValueVec) *TransferCotaNFTEntriesBuilder {
	s.claim_values = v
	return s
}

func (s *TransferCotaNFTEntriesBuilder) WithdrawalKeys(v WithdrawalCotaNFTKeyVec) *TransferCotaNFTEntriesBuilder {
	s.withdrawal_keys = v
	return s
}

func (s *TransferCotaNFTEntriesBuilder) WithdrawalValues(v WithdrawalCotaNFTValueVec) *TransferCotaNFTEntriesBuilder {
	s.withdrawal_values = v
	return s
}

func (s *TransferCotaNFTEntriesBuilder) Proof(v Bytes) *TransferCotaNFTEntriesBuilder {
	s.proof = v
	return s
}

func (s *TransferCotaNFTEntriesBuilder) WithdrawalProof(v Bytes) *TransferCotaNFTEntriesBuilder {
	s.withdrawal_proof = v
	return s
}

func (s *TransferCotaNFTEntriesBuilder) Action(v Bytes) *TransferCotaNFTEntriesBuilder {
	s.action = v
	return s
}

func NewTransferCotaNFTEntriesBuilder() *TransferCotaNFTEntriesBuilder {
	return &TransferCotaNFTEntriesBuilder{claim_keys: ClaimCotaNFTKeyVecDefault(), claim_values: ClaimCotaNFTValueVecDefault(), withdrawal_keys: WithdrawalCotaNFTKeyVecDefault(), withdrawal_values: WithdrawalCotaNFTValueVecDefault(), proof: BytesDefault(), withdrawal_proof: BytesDefault(), action: BytesDefault()}
}

type TransferCotaNFTEntries struct {
	inner []byte
}

func TransferCotaNFTEntriesFromSliceUnchecked(slice []byte) *TransferCotaNFTEntries {
	return &TransferCotaNFTEntries{inner: slice}
}
func (s *TransferCotaNFTEntries) AsSlice() []byte {
	return s.inner
}

func TransferCotaNFTEntriesDefault() TransferCotaNFTEntries {
	return *TransferCotaNFTEntriesFromSliceUnchecked([]byte{60, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func TransferCotaNFTEntriesFromSlice(slice []byte, compatible bool) (*TransferCotaNFTEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TransferCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TransferCotaNFTEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 7 == 0 {
		return &TransferCotaNFTEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TransferCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "TransferCotaNFTEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TransferCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 7 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 7 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = ClaimCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimCotaNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTKeyVecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTValueVecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	return &TransferCotaNFTEntries{inner: slice}, nil
}

func (s *TransferCotaNFTEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *TransferCotaNFTEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *TransferCotaNFTEntries) Len() uint {
	return s.FieldCount()
}
func (s *TransferCotaNFTEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *TransferCotaNFTEntries) CountExtraFields() uint {
	return s.FieldCount() - 7
}

func (s *TransferCotaNFTEntries) HasExtraFields() bool {
	return 7 != s.FieldCount()
}

func (s *TransferCotaNFTEntries) ClaimKeys() *ClaimCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return ClaimCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTEntries) ClaimValues() *ClaimCotaNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return ClaimCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTEntries) WithdrawalKeys() *WithdrawalCotaNFTKeyVec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return WithdrawalCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTEntries) WithdrawalValues() *WithdrawalCotaNFTValueVec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return WithdrawalCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTEntries) Proof() *Bytes {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTEntries) WithdrawalProof() *Bytes {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTEntries) Action() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[28:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[32:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *TransferCotaNFTEntries) AsBuilder() TransferCotaNFTEntriesBuilder {
	ret := NewTransferCotaNFTEntriesBuilder().ClaimKeys(*s.ClaimKeys()).ClaimValues(*s.ClaimValues()).WithdrawalKeys(*s.WithdrawalKeys()).WithdrawalValues(*s.WithdrawalValues()).Proof(*s.Proof()).WithdrawalProof(*s.WithdrawalProof()).Action(*s.Action())
	return *ret
}

type UpdateCotaNFTEntriesBuilder struct {
	holdKeys      HoldCotaNFTKeyVec
	holdOldValues HoldCotaNFTValueVec
	holdNewValues HoldCotaNFTValueVec
	proof         Bytes
	action        Bytes
}

func (s *UpdateCotaNFTEntriesBuilder) Build() UpdateCotaNFTEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (5 + 1)
	offsets := make([]uint32, 0, 5)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.holdKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.holdOldValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.holdNewValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.holdKeys.AsSlice())
	b.Write(s.holdOldValues.AsSlice())
	b.Write(s.holdNewValues.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.action.AsSlice())
	return UpdateCotaNFTEntries{inner: b.Bytes()}
}

func (s *UpdateCotaNFTEntriesBuilder) HoldKeys(v HoldCotaNFTKeyVec) *UpdateCotaNFTEntriesBuilder {
	s.holdKeys = v
	return s
}

func (s *UpdateCotaNFTEntriesBuilder) HoldOldValues(v HoldCotaNFTValueVec) *UpdateCotaNFTEntriesBuilder {
	s.holdOldValues = v
	return s
}

func (s *UpdateCotaNFTEntriesBuilder) HoldNewValues(v HoldCotaNFTValueVec) *UpdateCotaNFTEntriesBuilder {
	s.holdNewValues = v
	return s
}

func (s *UpdateCotaNFTEntriesBuilder) Proof(v Bytes) *UpdateCotaNFTEntriesBuilder {
	s.proof = v
	return s
}

func (s *UpdateCotaNFTEntriesBuilder) Action(v Bytes) *UpdateCotaNFTEntriesBuilder {
	s.action = v
	return s
}

func NewUpdateCotaNFTEntriesBuilder() *UpdateCotaNFTEntriesBuilder {
	return &UpdateCotaNFTEntriesBuilder{holdKeys: HoldCotaNFTKeyVecDefault(), holdOldValues: HoldCotaNFTValueVecDefault(), holdNewValues: HoldCotaNFTValueVecDefault(), proof: BytesDefault(), action: BytesDefault()}
}

type UpdateCotaNFTEntries struct {
	inner []byte
}

func UpdateCotaNFTEntriesFromSliceUnchecked(slice []byte) *UpdateCotaNFTEntries {
	return &UpdateCotaNFTEntries{inner: slice}
}
func (s *UpdateCotaNFTEntries) AsSlice() []byte {
	return s.inner
}

func UpdateCotaNFTEntriesDefault() UpdateCotaNFTEntries {
	return *UpdateCotaNFTEntriesFromSliceUnchecked([]byte{44, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func UpdateCotaNFTEntriesFromSlice(slice []byte, compatible bool) (*UpdateCotaNFTEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "UpdateCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "UpdateCotaNFTEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 5 == 0 {
		return &UpdateCotaNFTEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "UpdateCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "UpdateCotaNFTEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "UpdateCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 5 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 5 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = HoldCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HoldCotaNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HoldCotaNFTValueVecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	return &UpdateCotaNFTEntries{inner: slice}, nil
}

func (s *UpdateCotaNFTEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *UpdateCotaNFTEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *UpdateCotaNFTEntries) Len() uint {
	return s.FieldCount()
}
func (s *UpdateCotaNFTEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *UpdateCotaNFTEntries) CountExtraFields() uint {
	return s.FieldCount() - 5
}

func (s *UpdateCotaNFTEntries) HasExtraFields() bool {
	return 5 != s.FieldCount()
}

func (s *UpdateCotaNFTEntries) HoldKeys() *HoldCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return HoldCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *UpdateCotaNFTEntries) HoldOldValues() *HoldCotaNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return HoldCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *UpdateCotaNFTEntries) HoldNewValues() *HoldCotaNFTValueVec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return HoldCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *UpdateCotaNFTEntries) Proof() *Bytes {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *UpdateCotaNFTEntries) Action() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[20:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[24:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *UpdateCotaNFTEntries) AsBuilder() UpdateCotaNFTEntriesBuilder {
	ret := NewUpdateCotaNFTEntriesBuilder().HoldKeys(*s.HoldKeys()).HoldOldValues(*s.HoldOldValues()).HoldNewValues(*s.HoldNewValues()).Proof(*s.Proof()).Action(*s.Action())
	return *ret
}
