// Generated by Molecule 0.7.3
// Generated by Moleculec-Go 0.1.9

package smt

import (
	"bytes"
	"encoding/binary"
	"errors"
	"strconv"
	"strings"
)

type Number uint32

const HeaderSizeUint uint32 = 4

// Byte is the primitive type
type Byte [1]byte

func NewByte(b byte) Byte {
	return Byte([1]byte{b})
}
func ByteDefault() Byte {
	return Byte([1]byte{0})
}
func ByteFromSliceUnchecked(slice []byte) *Byte {
	b := new(Byte)
	b[0] = slice[0]
	return b
}
func (b *Byte) AsSlice() []byte {
	return b[:]
}
func ByteFromSlice(slice []byte, _compatible bool) (*Byte, error) {
	if len(slice) != 1 {
		return nil, errors.New("TotalSizeNotMatch")
	}
	b := new(Byte)
	b[0] = slice[0]
	return b, nil
}
func unpackNumber(b []byte) Number {
	bytesBuffer := bytes.NewBuffer(b)
	var x Number
	binary.Read(bytesBuffer, binary.LittleEndian, &x)
	return x
}
func packNumber(num Number) []byte {
	b := make([]byte, 4)
	binary.LittleEndian.PutUint32(b, uint32(num))
	return b
}

type Byte32Builder struct {
	inner [32]Byte
}

func NewByte32Builder() *Byte32Builder {
	return &Byte32Builder{inner: [32]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *Byte32Builder) Build() Byte32 {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Byte32{inner: b.Bytes()}
}

func (s *Byte32Builder) Set(v [32]Byte) *Byte32Builder {
	s.inner = v
	return s
}

func (s *Byte32Builder) Nth0(v Byte) *Byte32Builder {
	s.inner[0] = v
	return s
}

func (s *Byte32Builder) Nth1(v Byte) *Byte32Builder {
	s.inner[1] = v
	return s
}

func (s *Byte32Builder) Nth2(v Byte) *Byte32Builder {
	s.inner[2] = v
	return s
}

func (s *Byte32Builder) Nth3(v Byte) *Byte32Builder {
	s.inner[3] = v
	return s
}

func (s *Byte32Builder) Nth4(v Byte) *Byte32Builder {
	s.inner[4] = v
	return s
}

func (s *Byte32Builder) Nth5(v Byte) *Byte32Builder {
	s.inner[5] = v
	return s
}

func (s *Byte32Builder) Nth6(v Byte) *Byte32Builder {
	s.inner[6] = v
	return s
}

func (s *Byte32Builder) Nth7(v Byte) *Byte32Builder {
	s.inner[7] = v
	return s
}

func (s *Byte32Builder) Nth8(v Byte) *Byte32Builder {
	s.inner[8] = v
	return s
}

func (s *Byte32Builder) Nth9(v Byte) *Byte32Builder {
	s.inner[9] = v
	return s
}

func (s *Byte32Builder) Nth10(v Byte) *Byte32Builder {
	s.inner[10] = v
	return s
}

func (s *Byte32Builder) Nth11(v Byte) *Byte32Builder {
	s.inner[11] = v
	return s
}

func (s *Byte32Builder) Nth12(v Byte) *Byte32Builder {
	s.inner[12] = v
	return s
}

func (s *Byte32Builder) Nth13(v Byte) *Byte32Builder {
	s.inner[13] = v
	return s
}

func (s *Byte32Builder) Nth14(v Byte) *Byte32Builder {
	s.inner[14] = v
	return s
}

func (s *Byte32Builder) Nth15(v Byte) *Byte32Builder {
	s.inner[15] = v
	return s
}

func (s *Byte32Builder) Nth16(v Byte) *Byte32Builder {
	s.inner[16] = v
	return s
}

func (s *Byte32Builder) Nth17(v Byte) *Byte32Builder {
	s.inner[17] = v
	return s
}

func (s *Byte32Builder) Nth18(v Byte) *Byte32Builder {
	s.inner[18] = v
	return s
}

func (s *Byte32Builder) Nth19(v Byte) *Byte32Builder {
	s.inner[19] = v
	return s
}

func (s *Byte32Builder) Nth20(v Byte) *Byte32Builder {
	s.inner[20] = v
	return s
}

func (s *Byte32Builder) Nth21(v Byte) *Byte32Builder {
	s.inner[21] = v
	return s
}

func (s *Byte32Builder) Nth22(v Byte) *Byte32Builder {
	s.inner[22] = v
	return s
}

func (s *Byte32Builder) Nth23(v Byte) *Byte32Builder {
	s.inner[23] = v
	return s
}

func (s *Byte32Builder) Nth24(v Byte) *Byte32Builder {
	s.inner[24] = v
	return s
}

func (s *Byte32Builder) Nth25(v Byte) *Byte32Builder {
	s.inner[25] = v
	return s
}

func (s *Byte32Builder) Nth26(v Byte) *Byte32Builder {
	s.inner[26] = v
	return s
}

func (s *Byte32Builder) Nth27(v Byte) *Byte32Builder {
	s.inner[27] = v
	return s
}

func (s *Byte32Builder) Nth28(v Byte) *Byte32Builder {
	s.inner[28] = v
	return s
}

func (s *Byte32Builder) Nth29(v Byte) *Byte32Builder {
	s.inner[29] = v
	return s
}

func (s *Byte32Builder) Nth30(v Byte) *Byte32Builder {
	s.inner[30] = v
	return s
}

func (s *Byte32Builder) Nth31(v Byte) *Byte32Builder {
	s.inner[31] = v
	return s
}

type Byte32 struct {
	inner []byte
}

func Byte32FromSliceUnchecked(slice []byte) *Byte32 {
	return &Byte32{inner: slice}
}
func (s *Byte32) AsSlice() []byte {
	return s.inner
}

func Byte32Default() Byte32 {
	return *Byte32FromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func Byte32FromSlice(slice []byte, _compatible bool) (*Byte32, error) {
	sliceLen := len(slice)
	if sliceLen != 32 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Byte32", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(32)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Byte32{inner: slice}, nil
}

func (s *Byte32) RawData() []byte {
	return s.inner
}

func (s *Byte32) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Byte32) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Byte32) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Byte32) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Byte32) Nth4() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *Byte32) Nth5() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *Byte32) Nth6() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *Byte32) Nth7() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *Byte32) Nth8() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *Byte32) Nth9() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *Byte32) Nth10() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *Byte32) Nth11() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *Byte32) Nth12() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *Byte32) Nth13() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *Byte32) Nth14() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *Byte32) Nth15() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *Byte32) Nth16() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[16:17])
	return ret
}

func (s *Byte32) Nth17() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[17:18])
	return ret
}

func (s *Byte32) Nth18() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[18:19])
	return ret
}

func (s *Byte32) Nth19() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[19:20])
	return ret
}

func (s *Byte32) Nth20() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[20:21])
	return ret
}

func (s *Byte32) Nth21() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[21:22])
	return ret
}

func (s *Byte32) Nth22() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[22:23])
	return ret
}

func (s *Byte32) Nth23() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[23:24])
	return ret
}

func (s *Byte32) Nth24() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[24:25])
	return ret
}

func (s *Byte32) Nth25() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[25:26])
	return ret
}

func (s *Byte32) Nth26() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[26:27])
	return ret
}

func (s *Byte32) Nth27() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[27:28])
	return ret
}

func (s *Byte32) Nth28() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[28:29])
	return ret
}

func (s *Byte32) Nth29() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[29:30])
	return ret
}

func (s *Byte32) Nth30() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[30:31])
	return ret
}

func (s *Byte32) Nth31() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[31:32])
	return ret
}

func (s *Byte32) AsBuilder() Byte32Builder {
	t := NewByte32Builder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	t.Nth4(*s.Nth4())
	t.Nth5(*s.Nth5())
	t.Nth6(*s.Nth6())
	t.Nth7(*s.Nth7())
	t.Nth8(*s.Nth8())
	t.Nth9(*s.Nth9())
	t.Nth10(*s.Nth10())
	t.Nth11(*s.Nth11())
	t.Nth12(*s.Nth12())
	t.Nth13(*s.Nth13())
	t.Nth14(*s.Nth14())
	t.Nth15(*s.Nth15())
	t.Nth16(*s.Nth16())
	t.Nth17(*s.Nth17())
	t.Nth18(*s.Nth18())
	t.Nth19(*s.Nth19())
	t.Nth20(*s.Nth20())
	t.Nth21(*s.Nth21())
	t.Nth22(*s.Nth22())
	t.Nth23(*s.Nth23())
	t.Nth24(*s.Nth24())
	t.Nth25(*s.Nth25())
	t.Nth26(*s.Nth26())
	t.Nth27(*s.Nth27())
	t.Nth28(*s.Nth28())
	t.Nth29(*s.Nth29())
	t.Nth30(*s.Nth30())
	t.Nth31(*s.Nth31())
	return *t
}

type Uint16Builder struct {
	inner [2]Byte
}

func NewUint16Builder() *Uint16Builder {
	return &Uint16Builder{inner: [2]Byte{ByteDefault(), ByteDefault()}}
}

func (s *Uint16Builder) Build() Uint16 {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Uint16{inner: b.Bytes()}
}

func (s *Uint16Builder) Set(v [2]Byte) *Uint16Builder {
	s.inner = v
	return s
}

func (s *Uint16Builder) Nth0(v Byte) *Uint16Builder {
	s.inner[0] = v
	return s
}

func (s *Uint16Builder) Nth1(v Byte) *Uint16Builder {
	s.inner[1] = v
	return s
}

type Uint16 struct {
	inner []byte
}

func Uint16FromSliceUnchecked(slice []byte) *Uint16 {
	return &Uint16{inner: slice}
}
func (s *Uint16) AsSlice() []byte {
	return s.inner
}

func Uint16Default() Uint16 {
	return *Uint16FromSliceUnchecked([]byte{0, 0})
}

func Uint16FromSlice(slice []byte, _compatible bool) (*Uint16, error) {
	sliceLen := len(slice)
	if sliceLen != 2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint16", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(2)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Uint16{inner: slice}, nil
}

func (s *Uint16) RawData() []byte {
	return s.inner
}

func (s *Uint16) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Uint16) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Uint16) AsBuilder() Uint16Builder {
	t := NewUint16Builder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	return *t
}

type Uint32Builder struct {
	inner [4]Byte
}

func NewUint32Builder() *Uint32Builder {
	return &Uint32Builder{inner: [4]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *Uint32Builder) Build() Uint32 {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Uint32{inner: b.Bytes()}
}

func (s *Uint32Builder) Set(v [4]Byte) *Uint32Builder {
	s.inner = v
	return s
}

func (s *Uint32Builder) Nth0(v Byte) *Uint32Builder {
	s.inner[0] = v
	return s
}

func (s *Uint32Builder) Nth1(v Byte) *Uint32Builder {
	s.inner[1] = v
	return s
}

func (s *Uint32Builder) Nth2(v Byte) *Uint32Builder {
	s.inner[2] = v
	return s
}

func (s *Uint32Builder) Nth3(v Byte) *Uint32Builder {
	s.inner[3] = v
	return s
}

type Uint32 struct {
	inner []byte
}

func Uint32FromSliceUnchecked(slice []byte) *Uint32 {
	return &Uint32{inner: slice}
}
func (s *Uint32) AsSlice() []byte {
	return s.inner
}

func Uint32Default() Uint32 {
	return *Uint32FromSliceUnchecked([]byte{0, 0, 0, 0})
}

func Uint32FromSlice(slice []byte, _compatible bool) (*Uint32, error) {
	sliceLen := len(slice)
	if sliceLen != 4 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint32", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(4)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Uint32{inner: slice}, nil
}

func (s *Uint32) RawData() []byte {
	return s.inner
}

func (s *Uint32) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Uint32) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Uint32) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Uint32) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Uint32) AsBuilder() Uint32Builder {
	t := NewUint32Builder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	return *t
}

type BytesBuilder struct {
	inner []Byte
}

func (s *BytesBuilder) Build() Bytes {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := Bytes{inner: b.Bytes()}

	return sb
}

func (s *BytesBuilder) Set(v []Byte) *BytesBuilder {
	s.inner = v
	return s
}
func (s *BytesBuilder) Push(v Byte) *BytesBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *BytesBuilder) Extend(iter []Byte) *BytesBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *BytesBuilder) Replace(index uint, v Byte) *Byte {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewBytesBuilder() *BytesBuilder {
	return &BytesBuilder{[]Byte{}}
}

type Bytes struct {
	inner []byte
}

func BytesFromSliceUnchecked(slice []byte) *Bytes {
	return &Bytes{inner: slice}
}
func (s *Bytes) AsSlice() []byte {
	return s.inner
}

func BytesDefault() Bytes {
	return *BytesFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func BytesFromSlice(slice []byte, _compatible bool) (*Bytes, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Bytes", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "Bytes", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &Bytes{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(1*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Bytes", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &Bytes{inner: slice}, nil
}

func (s *Bytes) TotalSize() uint {
	return uint(HeaderSizeUint) + 1*s.ItemCount()
}
func (s *Bytes) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *Bytes) Len() uint {
	return s.ItemCount()
}
func (s *Bytes) IsEmpty() bool {
	return s.Len() == 0
}

// if *Byte is nil, index is out of bounds
func (s *Bytes) Get(index uint) *Byte {
	var re *Byte
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 1*index
		end := start + 1
		re = ByteFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *Bytes) RawData() []byte {
	return s.inner[HeaderSizeUint:]
}

func (s *Bytes) AsBuilder() BytesBuilder {
	size := s.ItemCount()
	t := NewBytesBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type CotaIdBuilder struct {
	inner [20]Byte
}

func NewCotaIdBuilder() *CotaIdBuilder {
	return &CotaIdBuilder{inner: [20]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *CotaIdBuilder) Build() CotaId {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return CotaId{inner: b.Bytes()}
}

func (s *CotaIdBuilder) Set(v [20]Byte) *CotaIdBuilder {
	s.inner = v
	return s
}

func (s *CotaIdBuilder) Nth0(v Byte) *CotaIdBuilder {
	s.inner[0] = v
	return s
}

func (s *CotaIdBuilder) Nth1(v Byte) *CotaIdBuilder {
	s.inner[1] = v
	return s
}

func (s *CotaIdBuilder) Nth2(v Byte) *CotaIdBuilder {
	s.inner[2] = v
	return s
}

func (s *CotaIdBuilder) Nth3(v Byte) *CotaIdBuilder {
	s.inner[3] = v
	return s
}

func (s *CotaIdBuilder) Nth4(v Byte) *CotaIdBuilder {
	s.inner[4] = v
	return s
}

func (s *CotaIdBuilder) Nth5(v Byte) *CotaIdBuilder {
	s.inner[5] = v
	return s
}

func (s *CotaIdBuilder) Nth6(v Byte) *CotaIdBuilder {
	s.inner[6] = v
	return s
}

func (s *CotaIdBuilder) Nth7(v Byte) *CotaIdBuilder {
	s.inner[7] = v
	return s
}

func (s *CotaIdBuilder) Nth8(v Byte) *CotaIdBuilder {
	s.inner[8] = v
	return s
}

func (s *CotaIdBuilder) Nth9(v Byte) *CotaIdBuilder {
	s.inner[9] = v
	return s
}

func (s *CotaIdBuilder) Nth10(v Byte) *CotaIdBuilder {
	s.inner[10] = v
	return s
}

func (s *CotaIdBuilder) Nth11(v Byte) *CotaIdBuilder {
	s.inner[11] = v
	return s
}

func (s *CotaIdBuilder) Nth12(v Byte) *CotaIdBuilder {
	s.inner[12] = v
	return s
}

func (s *CotaIdBuilder) Nth13(v Byte) *CotaIdBuilder {
	s.inner[13] = v
	return s
}

func (s *CotaIdBuilder) Nth14(v Byte) *CotaIdBuilder {
	s.inner[14] = v
	return s
}

func (s *CotaIdBuilder) Nth15(v Byte) *CotaIdBuilder {
	s.inner[15] = v
	return s
}

func (s *CotaIdBuilder) Nth16(v Byte) *CotaIdBuilder {
	s.inner[16] = v
	return s
}

func (s *CotaIdBuilder) Nth17(v Byte) *CotaIdBuilder {
	s.inner[17] = v
	return s
}

func (s *CotaIdBuilder) Nth18(v Byte) *CotaIdBuilder {
	s.inner[18] = v
	return s
}

func (s *CotaIdBuilder) Nth19(v Byte) *CotaIdBuilder {
	s.inner[19] = v
	return s
}

type CotaId struct {
	inner []byte
}

func CotaIdFromSliceUnchecked(slice []byte) *CotaId {
	return &CotaId{inner: slice}
}
func (s *CotaId) AsSlice() []byte {
	return s.inner
}

func CotaIdDefault() CotaId {
	return *CotaIdFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func CotaIdFromSlice(slice []byte, _compatible bool) (*CotaId, error) {
	sliceLen := len(slice)
	if sliceLen != 20 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CotaId", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(20)}, " ")
		return nil, errors.New(errMsg)
	}
	return &CotaId{inner: slice}, nil
}

func (s *CotaId) RawData() []byte {
	return s.inner
}

func (s *CotaId) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *CotaId) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *CotaId) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *CotaId) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *CotaId) Nth4() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *CotaId) Nth5() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *CotaId) Nth6() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *CotaId) Nth7() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *CotaId) Nth8() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *CotaId) Nth9() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *CotaId) Nth10() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *CotaId) Nth11() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *CotaId) Nth12() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *CotaId) Nth13() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *CotaId) Nth14() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *CotaId) Nth15() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *CotaId) Nth16() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[16:17])
	return ret
}

func (s *CotaId) Nth17() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[17:18])
	return ret
}

func (s *CotaId) Nth18() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[18:19])
	return ret
}

func (s *CotaId) Nth19() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[19:20])
	return ret
}

func (s *CotaId) AsBuilder() CotaIdBuilder {
	t := NewCotaIdBuilder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	t.Nth4(*s.Nth4())
	t.Nth5(*s.Nth5())
	t.Nth6(*s.Nth6())
	t.Nth7(*s.Nth7())
	t.Nth8(*s.Nth8())
	t.Nth9(*s.Nth9())
	t.Nth10(*s.Nth10())
	t.Nth11(*s.Nth11())
	t.Nth12(*s.Nth12())
	t.Nth13(*s.Nth13())
	t.Nth14(*s.Nth14())
	t.Nth15(*s.Nth15())
	t.Nth16(*s.Nth16())
	t.Nth17(*s.Nth17())
	t.Nth18(*s.Nth18())
	t.Nth19(*s.Nth19())
	return *t
}

type CharacteristicBuilder struct {
	inner [20]Byte
}

func NewCharacteristicBuilder() *CharacteristicBuilder {
	return &CharacteristicBuilder{inner: [20]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *CharacteristicBuilder) Build() Characteristic {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Characteristic{inner: b.Bytes()}
}

func (s *CharacteristicBuilder) Set(v [20]Byte) *CharacteristicBuilder {
	s.inner = v
	return s
}

func (s *CharacteristicBuilder) Nth0(v Byte) *CharacteristicBuilder {
	s.inner[0] = v
	return s
}

func (s *CharacteristicBuilder) Nth1(v Byte) *CharacteristicBuilder {
	s.inner[1] = v
	return s
}

func (s *CharacteristicBuilder) Nth2(v Byte) *CharacteristicBuilder {
	s.inner[2] = v
	return s
}

func (s *CharacteristicBuilder) Nth3(v Byte) *CharacteristicBuilder {
	s.inner[3] = v
	return s
}

func (s *CharacteristicBuilder) Nth4(v Byte) *CharacteristicBuilder {
	s.inner[4] = v
	return s
}

func (s *CharacteristicBuilder) Nth5(v Byte) *CharacteristicBuilder {
	s.inner[5] = v
	return s
}

func (s *CharacteristicBuilder) Nth6(v Byte) *CharacteristicBuilder {
	s.inner[6] = v
	return s
}

func (s *CharacteristicBuilder) Nth7(v Byte) *CharacteristicBuilder {
	s.inner[7] = v
	return s
}

func (s *CharacteristicBuilder) Nth8(v Byte) *CharacteristicBuilder {
	s.inner[8] = v
	return s
}

func (s *CharacteristicBuilder) Nth9(v Byte) *CharacteristicBuilder {
	s.inner[9] = v
	return s
}

func (s *CharacteristicBuilder) Nth10(v Byte) *CharacteristicBuilder {
	s.inner[10] = v
	return s
}

func (s *CharacteristicBuilder) Nth11(v Byte) *CharacteristicBuilder {
	s.inner[11] = v
	return s
}

func (s *CharacteristicBuilder) Nth12(v Byte) *CharacteristicBuilder {
	s.inner[12] = v
	return s
}

func (s *CharacteristicBuilder) Nth13(v Byte) *CharacteristicBuilder {
	s.inner[13] = v
	return s
}

func (s *CharacteristicBuilder) Nth14(v Byte) *CharacteristicBuilder {
	s.inner[14] = v
	return s
}

func (s *CharacteristicBuilder) Nth15(v Byte) *CharacteristicBuilder {
	s.inner[15] = v
	return s
}

func (s *CharacteristicBuilder) Nth16(v Byte) *CharacteristicBuilder {
	s.inner[16] = v
	return s
}

func (s *CharacteristicBuilder) Nth17(v Byte) *CharacteristicBuilder {
	s.inner[17] = v
	return s
}

func (s *CharacteristicBuilder) Nth18(v Byte) *CharacteristicBuilder {
	s.inner[18] = v
	return s
}

func (s *CharacteristicBuilder) Nth19(v Byte) *CharacteristicBuilder {
	s.inner[19] = v
	return s
}

type Characteristic struct {
	inner []byte
}

func CharacteristicFromSliceUnchecked(slice []byte) *Characteristic {
	return &Characteristic{inner: slice}
}
func (s *Characteristic) AsSlice() []byte {
	return s.inner
}

func CharacteristicDefault() Characteristic {
	return *CharacteristicFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func CharacteristicFromSlice(slice []byte, _compatible bool) (*Characteristic, error) {
	sliceLen := len(slice)
	if sliceLen != 20 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Characteristic", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(20)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Characteristic{inner: slice}, nil
}

func (s *Characteristic) RawData() []byte {
	return s.inner
}

func (s *Characteristic) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Characteristic) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Characteristic) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Characteristic) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Characteristic) Nth4() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *Characteristic) Nth5() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *Characteristic) Nth6() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *Characteristic) Nth7() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *Characteristic) Nth8() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *Characteristic) Nth9() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *Characteristic) Nth10() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *Characteristic) Nth11() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *Characteristic) Nth12() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *Characteristic) Nth13() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *Characteristic) Nth14() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *Characteristic) Nth15() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *Characteristic) Nth16() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[16:17])
	return ret
}

func (s *Characteristic) Nth17() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[17:18])
	return ret
}

func (s *Characteristic) Nth18() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[18:19])
	return ret
}

func (s *Characteristic) Nth19() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[19:20])
	return ret
}

func (s *Characteristic) AsBuilder() CharacteristicBuilder {
	t := NewCharacteristicBuilder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	t.Nth4(*s.Nth4())
	t.Nth5(*s.Nth5())
	t.Nth6(*s.Nth6())
	t.Nth7(*s.Nth7())
	t.Nth8(*s.Nth8())
	t.Nth9(*s.Nth9())
	t.Nth10(*s.Nth10())
	t.Nth11(*s.Nth11())
	t.Nth12(*s.Nth12())
	t.Nth13(*s.Nth13())
	t.Nth14(*s.Nth14())
	t.Nth15(*s.Nth15())
	t.Nth16(*s.Nth16())
	t.Nth17(*s.Nth17())
	t.Nth18(*s.Nth18())
	t.Nth19(*s.Nth19())
	return *t
}

type OutPointSliceBuilder struct {
	inner [24]Byte
}

func NewOutPointSliceBuilder() *OutPointSliceBuilder {
	return &OutPointSliceBuilder{inner: [24]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *OutPointSliceBuilder) Build() OutPointSlice {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return OutPointSlice{inner: b.Bytes()}
}

func (s *OutPointSliceBuilder) Set(v [24]Byte) *OutPointSliceBuilder {
	s.inner = v
	return s
}

func (s *OutPointSliceBuilder) Nth0(v Byte) *OutPointSliceBuilder {
	s.inner[0] = v
	return s
}

func (s *OutPointSliceBuilder) Nth1(v Byte) *OutPointSliceBuilder {
	s.inner[1] = v
	return s
}

func (s *OutPointSliceBuilder) Nth2(v Byte) *OutPointSliceBuilder {
	s.inner[2] = v
	return s
}

func (s *OutPointSliceBuilder) Nth3(v Byte) *OutPointSliceBuilder {
	s.inner[3] = v
	return s
}

func (s *OutPointSliceBuilder) Nth4(v Byte) *OutPointSliceBuilder {
	s.inner[4] = v
	return s
}

func (s *OutPointSliceBuilder) Nth5(v Byte) *OutPointSliceBuilder {
	s.inner[5] = v
	return s
}

func (s *OutPointSliceBuilder) Nth6(v Byte) *OutPointSliceBuilder {
	s.inner[6] = v
	return s
}

func (s *OutPointSliceBuilder) Nth7(v Byte) *OutPointSliceBuilder {
	s.inner[7] = v
	return s
}

func (s *OutPointSliceBuilder) Nth8(v Byte) *OutPointSliceBuilder {
	s.inner[8] = v
	return s
}

func (s *OutPointSliceBuilder) Nth9(v Byte) *OutPointSliceBuilder {
	s.inner[9] = v
	return s
}

func (s *OutPointSliceBuilder) Nth10(v Byte) *OutPointSliceBuilder {
	s.inner[10] = v
	return s
}

func (s *OutPointSliceBuilder) Nth11(v Byte) *OutPointSliceBuilder {
	s.inner[11] = v
	return s
}

func (s *OutPointSliceBuilder) Nth12(v Byte) *OutPointSliceBuilder {
	s.inner[12] = v
	return s
}

func (s *OutPointSliceBuilder) Nth13(v Byte) *OutPointSliceBuilder {
	s.inner[13] = v
	return s
}

func (s *OutPointSliceBuilder) Nth14(v Byte) *OutPointSliceBuilder {
	s.inner[14] = v
	return s
}

func (s *OutPointSliceBuilder) Nth15(v Byte) *OutPointSliceBuilder {
	s.inner[15] = v
	return s
}

func (s *OutPointSliceBuilder) Nth16(v Byte) *OutPointSliceBuilder {
	s.inner[16] = v
	return s
}

func (s *OutPointSliceBuilder) Nth17(v Byte) *OutPointSliceBuilder {
	s.inner[17] = v
	return s
}

func (s *OutPointSliceBuilder) Nth18(v Byte) *OutPointSliceBuilder {
	s.inner[18] = v
	return s
}

func (s *OutPointSliceBuilder) Nth19(v Byte) *OutPointSliceBuilder {
	s.inner[19] = v
	return s
}

func (s *OutPointSliceBuilder) Nth20(v Byte) *OutPointSliceBuilder {
	s.inner[20] = v
	return s
}

func (s *OutPointSliceBuilder) Nth21(v Byte) *OutPointSliceBuilder {
	s.inner[21] = v
	return s
}

func (s *OutPointSliceBuilder) Nth22(v Byte) *OutPointSliceBuilder {
	s.inner[22] = v
	return s
}

func (s *OutPointSliceBuilder) Nth23(v Byte) *OutPointSliceBuilder {
	s.inner[23] = v
	return s
}

type OutPointSlice struct {
	inner []byte
}

func OutPointSliceFromSliceUnchecked(slice []byte) *OutPointSlice {
	return &OutPointSlice{inner: slice}
}
func (s *OutPointSlice) AsSlice() []byte {
	return s.inner
}

func OutPointSliceDefault() OutPointSlice {
	return *OutPointSliceFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func OutPointSliceFromSlice(slice []byte, _compatible bool) (*OutPointSlice, error) {
	sliceLen := len(slice)
	if sliceLen != 24 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "OutPointSlice", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(24)}, " ")
		return nil, errors.New(errMsg)
	}
	return &OutPointSlice{inner: slice}, nil
}

func (s *OutPointSlice) RawData() []byte {
	return s.inner
}

func (s *OutPointSlice) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *OutPointSlice) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *OutPointSlice) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *OutPointSlice) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *OutPointSlice) Nth4() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *OutPointSlice) Nth5() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *OutPointSlice) Nth6() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *OutPointSlice) Nth7() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *OutPointSlice) Nth8() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *OutPointSlice) Nth9() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *OutPointSlice) Nth10() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *OutPointSlice) Nth11() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *OutPointSlice) Nth12() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *OutPointSlice) Nth13() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *OutPointSlice) Nth14() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *OutPointSlice) Nth15() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *OutPointSlice) Nth16() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[16:17])
	return ret
}

func (s *OutPointSlice) Nth17() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[17:18])
	return ret
}

func (s *OutPointSlice) Nth18() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[18:19])
	return ret
}

func (s *OutPointSlice) Nth19() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[19:20])
	return ret
}

func (s *OutPointSlice) Nth20() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[20:21])
	return ret
}

func (s *OutPointSlice) Nth21() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[21:22])
	return ret
}

func (s *OutPointSlice) Nth22() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[22:23])
	return ret
}

func (s *OutPointSlice) Nth23() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[23:24])
	return ret
}

func (s *OutPointSlice) AsBuilder() OutPointSliceBuilder {
	t := NewOutPointSliceBuilder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	t.Nth4(*s.Nth4())
	t.Nth5(*s.Nth5())
	t.Nth6(*s.Nth6())
	t.Nth7(*s.Nth7())
	t.Nth8(*s.Nth8())
	t.Nth9(*s.Nth9())
	t.Nth10(*s.Nth10())
	t.Nth11(*s.Nth11())
	t.Nth12(*s.Nth12())
	t.Nth13(*s.Nth13())
	t.Nth14(*s.Nth14())
	t.Nth15(*s.Nth15())
	t.Nth16(*s.Nth16())
	t.Nth17(*s.Nth17())
	t.Nth18(*s.Nth18())
	t.Nth19(*s.Nth19())
	t.Nth20(*s.Nth20())
	t.Nth21(*s.Nth21())
	t.Nth22(*s.Nth22())
	t.Nth23(*s.Nth23())
	return *t
}

type Uint32VecBuilder struct {
	inner []Uint32
}

func (s *Uint32VecBuilder) Build() Uint32Vec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := Uint32Vec{inner: b.Bytes()}

	return sb
}

func (s *Uint32VecBuilder) Set(v []Uint32) *Uint32VecBuilder {
	s.inner = v
	return s
}
func (s *Uint32VecBuilder) Push(v Uint32) *Uint32VecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *Uint32VecBuilder) Extend(iter []Uint32) *Uint32VecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *Uint32VecBuilder) Replace(index uint, v Uint32) *Uint32 {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewUint32VecBuilder() *Uint32VecBuilder {
	return &Uint32VecBuilder{[]Uint32{}}
}

type Uint32Vec struct {
	inner []byte
}

func Uint32VecFromSliceUnchecked(slice []byte) *Uint32Vec {
	return &Uint32Vec{inner: slice}
}
func (s *Uint32Vec) AsSlice() []byte {
	return s.inner
}

func Uint32VecDefault() Uint32Vec {
	return *Uint32VecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func Uint32VecFromSlice(slice []byte, _compatible bool) (*Uint32Vec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Uint32Vec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint32Vec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &Uint32Vec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(4*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint32Vec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &Uint32Vec{inner: slice}, nil
}

func (s *Uint32Vec) TotalSize() uint {
	return uint(HeaderSizeUint) + 4*s.ItemCount()
}
func (s *Uint32Vec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *Uint32Vec) Len() uint {
	return s.ItemCount()
}
func (s *Uint32Vec) IsEmpty() bool {
	return s.Len() == 0
}

// if *Uint32 is nil, index is out of bounds
func (s *Uint32Vec) Get(index uint) *Uint32 {
	var re *Uint32
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 4*index
		end := start + 4
		re = Uint32FromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *Uint32Vec) AsBuilder() Uint32VecBuilder {
	size := s.ItemCount()
	t := NewUint32VecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type Byte32VecBuilder struct {
	inner []Byte32
}

func (s *Byte32VecBuilder) Build() Byte32Vec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := Byte32Vec{inner: b.Bytes()}

	return sb
}

func (s *Byte32VecBuilder) Set(v []Byte32) *Byte32VecBuilder {
	s.inner = v
	return s
}
func (s *Byte32VecBuilder) Push(v Byte32) *Byte32VecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *Byte32VecBuilder) Extend(iter []Byte32) *Byte32VecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *Byte32VecBuilder) Replace(index uint, v Byte32) *Byte32 {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewByte32VecBuilder() *Byte32VecBuilder {
	return &Byte32VecBuilder{[]Byte32{}}
}

type Byte32Vec struct {
	inner []byte
}

func Byte32VecFromSliceUnchecked(slice []byte) *Byte32Vec {
	return &Byte32Vec{inner: slice}
}
func (s *Byte32Vec) AsSlice() []byte {
	return s.inner
}

func Byte32VecDefault() Byte32Vec {
	return *Byte32VecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func Byte32VecFromSlice(slice []byte, _compatible bool) (*Byte32Vec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Byte32Vec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "Byte32Vec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &Byte32Vec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(32*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Byte32Vec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &Byte32Vec{inner: slice}, nil
}

func (s *Byte32Vec) TotalSize() uint {
	return uint(HeaderSizeUint) + 32*s.ItemCount()
}
func (s *Byte32Vec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *Byte32Vec) Len() uint {
	return s.ItemCount()
}
func (s *Byte32Vec) IsEmpty() bool {
	return s.Len() == 0
}

// if *Byte32 is nil, index is out of bounds
func (s *Byte32Vec) Get(index uint) *Byte32 {
	var re *Byte32
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 32*index
		end := start + 32
		re = Byte32FromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *Byte32Vec) AsBuilder() Byte32VecBuilder {
	size := s.ItemCount()
	t := NewByte32VecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type CotaNFTIdBuilder struct {
	smtType Uint16
	cotaId  CotaId
	index   Uint32
}

func (s *CotaNFTIdBuilder) Build() CotaNFTId {
	b := new(bytes.Buffer)
	b.Write(s.smtType.AsSlice())
	b.Write(s.cotaId.AsSlice())
	b.Write(s.index.AsSlice())
	return CotaNFTId{inner: b.Bytes()}
}

func (s *CotaNFTIdBuilder) SmtType(v Uint16) *CotaNFTIdBuilder {
	s.smtType = v
	return s
}

func (s *CotaNFTIdBuilder) CotaId(v CotaId) *CotaNFTIdBuilder {
	s.cotaId = v
	return s
}

func (s *CotaNFTIdBuilder) Index(v Uint32) *CotaNFTIdBuilder {
	s.index = v
	return s
}

func NewCotaNFTIdBuilder() *CotaNFTIdBuilder {
	return &CotaNFTIdBuilder{smtType: Uint16Default(), cotaId: CotaIdDefault(), index: Uint32Default()}
}

type CotaNFTId struct {
	inner []byte
}

func CotaNFTIdFromSliceUnchecked(slice []byte) *CotaNFTId {
	return &CotaNFTId{inner: slice}
}
func (s *CotaNFTId) AsSlice() []byte {
	return s.inner
}

func CotaNFTIdDefault() CotaNFTId {
	return *CotaNFTIdFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func CotaNFTIdFromSlice(slice []byte, _compatible bool) (*CotaNFTId, error) {
	sliceLen := len(slice)
	if sliceLen != 26 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CotaNFTId", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(26)}, " ")
		return nil, errors.New(errMsg)
	}
	return &CotaNFTId{inner: slice}, nil
}

func (s *CotaNFTId) SmtType() *Uint16 {
	ret := Uint16FromSliceUnchecked(s.inner[0:2])
	return ret
}

func (s *CotaNFTId) CotaId() *CotaId {
	ret := CotaIdFromSliceUnchecked(s.inner[2:22])
	return ret
}

func (s *CotaNFTId) Index() *Uint32 {
	ret := Uint32FromSliceUnchecked(s.inner[22:26])
	return ret
}

func (s *CotaNFTId) AsBuilder() CotaNFTIdBuilder {
	ret := NewCotaNFTIdBuilder().SmtType(*s.SmtType()).CotaId(*s.CotaId()).Index(*s.Index())
	return *ret
}

type CotaNFTInfoBuilder struct {
	configure      Byte
	state          Byte
	characteristic Characteristic
}

func (s *CotaNFTInfoBuilder) Build() CotaNFTInfo {
	b := new(bytes.Buffer)
	b.Write(s.configure.AsSlice())
	b.Write(s.state.AsSlice())
	b.Write(s.characteristic.AsSlice())
	return CotaNFTInfo{inner: b.Bytes()}
}

func (s *CotaNFTInfoBuilder) Configure(v Byte) *CotaNFTInfoBuilder {
	s.configure = v
	return s
}

func (s *CotaNFTInfoBuilder) State(v Byte) *CotaNFTInfoBuilder {
	s.state = v
	return s
}

func (s *CotaNFTInfoBuilder) Characteristic(v Characteristic) *CotaNFTInfoBuilder {
	s.characteristic = v
	return s
}

func NewCotaNFTInfoBuilder() *CotaNFTInfoBuilder {
	return &CotaNFTInfoBuilder{configure: ByteDefault(), state: ByteDefault(), characteristic: CharacteristicDefault()}
}

type CotaNFTInfo struct {
	inner []byte
}

func CotaNFTInfoFromSliceUnchecked(slice []byte) *CotaNFTInfo {
	return &CotaNFTInfo{inner: slice}
}
func (s *CotaNFTInfo) AsSlice() []byte {
	return s.inner
}

func CotaNFTInfoDefault() CotaNFTInfo {
	return *CotaNFTInfoFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func CotaNFTInfoFromSlice(slice []byte, _compatible bool) (*CotaNFTInfo, error) {
	sliceLen := len(slice)
	if sliceLen != 22 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CotaNFTInfo", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(22)}, " ")
		return nil, errors.New(errMsg)
	}
	return &CotaNFTInfo{inner: slice}, nil
}

func (s *CotaNFTInfo) Configure() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *CotaNFTInfo) State() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *CotaNFTInfo) Characteristic() *Characteristic {
	ret := CharacteristicFromSliceUnchecked(s.inner[2:22])
	return ret
}

func (s *CotaNFTInfo) AsBuilder() CotaNFTInfoBuilder {
	ret := NewCotaNFTInfoBuilder().Configure(*s.Configure()).State(*s.State()).Characteristic(*s.Characteristic())
	return *ret
}

type MerkleProofBuilder struct {
	indices Uint32Vec
	lemmas  Byte32Vec
}

func (s *MerkleProofBuilder) Build() MerkleProof {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.indices.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.lemmas.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.indices.AsSlice())
	b.Write(s.lemmas.AsSlice())
	return MerkleProof{inner: b.Bytes()}
}

func (s *MerkleProofBuilder) Indices(v Uint32Vec) *MerkleProofBuilder {
	s.indices = v
	return s
}

func (s *MerkleProofBuilder) Lemmas(v Byte32Vec) *MerkleProofBuilder {
	s.lemmas = v
	return s
}

func NewMerkleProofBuilder() *MerkleProofBuilder {
	return &MerkleProofBuilder{indices: Uint32VecDefault(), lemmas: Byte32VecDefault()}
}

type MerkleProof struct {
	inner []byte
}

func MerkleProofFromSliceUnchecked(slice []byte) *MerkleProof {
	return &MerkleProof{inner: slice}
}
func (s *MerkleProof) AsSlice() []byte {
	return s.inner
}

func MerkleProofDefault() MerkleProof {
	return *MerkleProofFromSliceUnchecked([]byte{20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func MerkleProofFromSlice(slice []byte, compatible bool) (*MerkleProof, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "MerkleProof", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "MerkleProof", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
		return &MerkleProof{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "MerkleProof", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "MerkleProof", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "MerkleProof", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint32VecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Byte32VecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &MerkleProof{inner: slice}, nil
}

func (s *MerkleProof) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *MerkleProof) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *MerkleProof) Len() uint {
	return s.FieldCount()
}
func (s *MerkleProof) IsEmpty() bool {
	return s.Len() == 0
}
func (s *MerkleProof) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *MerkleProof) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *MerkleProof) Indices() *Uint32Vec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint32VecFromSliceUnchecked(s.inner[start:end])
}

func (s *MerkleProof) Lemmas() *Byte32Vec {
	var ret *Byte32Vec
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = Byte32VecFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Byte32VecFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *MerkleProof) AsBuilder() MerkleProofBuilder {
	ret := NewMerkleProofBuilder().Indices(*s.Indices()).Lemmas(*s.Lemmas())
	return *ret
}

type TransactionProofBuilder struct {
	witnesses_root Byte32
	proof          MerkleProof
}

func (s *TransactionProofBuilder) Build() TransactionProof {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.witnesses_root.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.witnesses_root.AsSlice())
	b.Write(s.proof.AsSlice())
	return TransactionProof{inner: b.Bytes()}
}

func (s *TransactionProofBuilder) WitnessesRoot(v Byte32) *TransactionProofBuilder {
	s.witnesses_root = v
	return s
}

func (s *TransactionProofBuilder) Proof(v MerkleProof) *TransactionProofBuilder {
	s.proof = v
	return s
}

func NewTransactionProofBuilder() *TransactionProofBuilder {
	return &TransactionProofBuilder{witnesses_root: Byte32Default(), proof: MerkleProofDefault()}
}

type TransactionProof struct {
	inner []byte
}

func TransactionProofFromSliceUnchecked(slice []byte) *TransactionProof {
	return &TransactionProof{inner: slice}
}
func (s *TransactionProof) AsSlice() []byte {
	return s.inner
}

func TransactionProofDefault() TransactionProof {
	return *TransactionProofFromSliceUnchecked([]byte{64, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func TransactionProofFromSlice(slice []byte, compatible bool) (*TransactionProof, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TransactionProof", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TransactionProof", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
		return &TransactionProof{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TransactionProof", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "TransactionProof", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TransactionProof", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Byte32FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = MerkleProofFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &TransactionProof{inner: slice}, nil
}

func (s *TransactionProof) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *TransactionProof) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *TransactionProof) Len() uint {
	return s.FieldCount()
}
func (s *TransactionProof) IsEmpty() bool {
	return s.Len() == 0
}
func (s *TransactionProof) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *TransactionProof) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *TransactionProof) WitnessesRoot() *Byte32 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Byte32FromSliceUnchecked(s.inner[start:end])
}

func (s *TransactionProof) Proof() *MerkleProof {
	var ret *MerkleProof
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = MerkleProofFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = MerkleProofFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *TransactionProof) AsBuilder() TransactionProofBuilder {
	ret := NewTransactionProofBuilder().WitnessesRoot(*s.WitnessesRoot()).Proof(*s.Proof())
	return *ret
}

type HoldCotaNFTKeyVecBuilder struct {
	inner []CotaNFTId
}

func (s *HoldCotaNFTKeyVecBuilder) Build() HoldCotaNFTKeyVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := HoldCotaNFTKeyVec{inner: b.Bytes()}

	return sb
}

func (s *HoldCotaNFTKeyVecBuilder) Set(v []CotaNFTId) *HoldCotaNFTKeyVecBuilder {
	s.inner = v
	return s
}
func (s *HoldCotaNFTKeyVecBuilder) Push(v CotaNFTId) *HoldCotaNFTKeyVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *HoldCotaNFTKeyVecBuilder) Extend(iter []CotaNFTId) *HoldCotaNFTKeyVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *HoldCotaNFTKeyVecBuilder) Replace(index uint, v CotaNFTId) *CotaNFTId {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewHoldCotaNFTKeyVecBuilder() *HoldCotaNFTKeyVecBuilder {
	return &HoldCotaNFTKeyVecBuilder{[]CotaNFTId{}}
}

type HoldCotaNFTKeyVec struct {
	inner []byte
}

func HoldCotaNFTKeyVecFromSliceUnchecked(slice []byte) *HoldCotaNFTKeyVec {
	return &HoldCotaNFTKeyVec{inner: slice}
}
func (s *HoldCotaNFTKeyVec) AsSlice() []byte {
	return s.inner
}

func HoldCotaNFTKeyVecDefault() HoldCotaNFTKeyVec {
	return *HoldCotaNFTKeyVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func HoldCotaNFTKeyVecFromSlice(slice []byte, _compatible bool) (*HoldCotaNFTKeyVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "HoldCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "HoldCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &HoldCotaNFTKeyVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(26*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "HoldCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &HoldCotaNFTKeyVec{inner: slice}, nil
}

func (s *HoldCotaNFTKeyVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 26*s.ItemCount()
}
func (s *HoldCotaNFTKeyVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *HoldCotaNFTKeyVec) Len() uint {
	return s.ItemCount()
}
func (s *HoldCotaNFTKeyVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *CotaNFTId is nil, index is out of bounds
func (s *HoldCotaNFTKeyVec) Get(index uint) *CotaNFTId {
	var re *CotaNFTId
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 26*index
		end := start + 26
		re = CotaNFTIdFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *HoldCotaNFTKeyVec) AsBuilder() HoldCotaNFTKeyVecBuilder {
	size := s.ItemCount()
	t := NewHoldCotaNFTKeyVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type HoldCotaNFTValueVecBuilder struct {
	inner []CotaNFTInfo
}

func (s *HoldCotaNFTValueVecBuilder) Build() HoldCotaNFTValueVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := HoldCotaNFTValueVec{inner: b.Bytes()}

	return sb
}

func (s *HoldCotaNFTValueVecBuilder) Set(v []CotaNFTInfo) *HoldCotaNFTValueVecBuilder {
	s.inner = v
	return s
}
func (s *HoldCotaNFTValueVecBuilder) Push(v CotaNFTInfo) *HoldCotaNFTValueVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *HoldCotaNFTValueVecBuilder) Extend(iter []CotaNFTInfo) *HoldCotaNFTValueVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *HoldCotaNFTValueVecBuilder) Replace(index uint, v CotaNFTInfo) *CotaNFTInfo {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewHoldCotaNFTValueVecBuilder() *HoldCotaNFTValueVecBuilder {
	return &HoldCotaNFTValueVecBuilder{[]CotaNFTInfo{}}
}

type HoldCotaNFTValueVec struct {
	inner []byte
}

func HoldCotaNFTValueVecFromSliceUnchecked(slice []byte) *HoldCotaNFTValueVec {
	return &HoldCotaNFTValueVec{inner: slice}
}
func (s *HoldCotaNFTValueVec) AsSlice() []byte {
	return s.inner
}

func HoldCotaNFTValueVecDefault() HoldCotaNFTValueVec {
	return *HoldCotaNFTValueVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func HoldCotaNFTValueVecFromSlice(slice []byte, _compatible bool) (*HoldCotaNFTValueVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "HoldCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "HoldCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &HoldCotaNFTValueVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(22*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "HoldCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &HoldCotaNFTValueVec{inner: slice}, nil
}

func (s *HoldCotaNFTValueVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 22*s.ItemCount()
}
func (s *HoldCotaNFTValueVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *HoldCotaNFTValueVec) Len() uint {
	return s.ItemCount()
}
func (s *HoldCotaNFTValueVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *CotaNFTInfo is nil, index is out of bounds
func (s *HoldCotaNFTValueVec) Get(index uint) *CotaNFTInfo {
	var re *CotaNFTInfo
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 22*index
		end := start + 22
		re = CotaNFTInfoFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *HoldCotaNFTValueVec) AsBuilder() HoldCotaNFTValueVecBuilder {
	size := s.ItemCount()
	t := NewHoldCotaNFTValueVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type RegistryBuilder struct {
	lockHash Byte32
	state    Byte32
}

func (s *RegistryBuilder) Build() Registry {
	b := new(bytes.Buffer)
	b.Write(s.lockHash.AsSlice())
	b.Write(s.state.AsSlice())
	return Registry{inner: b.Bytes()}
}

func (s *RegistryBuilder) LockHash(v Byte32) *RegistryBuilder {
	s.lockHash = v
	return s
}

func (s *RegistryBuilder) State(v Byte32) *RegistryBuilder {
	s.state = v
	return s
}

func NewRegistryBuilder() *RegistryBuilder {
	return &RegistryBuilder{lockHash: Byte32Default(), state: Byte32Default()}
}

type Registry struct {
	inner []byte
}

func RegistryFromSliceUnchecked(slice []byte) *Registry {
	return &Registry{inner: slice}
}
func (s *Registry) AsSlice() []byte {
	return s.inner
}

func RegistryDefault() Registry {
	return *RegistryFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func RegistryFromSlice(slice []byte, _compatible bool) (*Registry, error) {
	sliceLen := len(slice)
	if sliceLen != 64 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Registry", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(64)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Registry{inner: slice}, nil
}

func (s *Registry) LockHash() *Byte32 {
	ret := Byte32FromSliceUnchecked(s.inner[0:32])
	return ret
}

func (s *Registry) State() *Byte32 {
	ret := Byte32FromSliceUnchecked(s.inner[32:64])
	return ret
}

func (s *Registry) AsBuilder() RegistryBuilder {
	ret := NewRegistryBuilder().LockHash(*s.LockHash()).State(*s.State())
	return *ret
}

type RegistryVecBuilder struct {
	inner []Registry
}

func (s *RegistryVecBuilder) Build() RegistryVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := RegistryVec{inner: b.Bytes()}

	return sb
}

func (s *RegistryVecBuilder) Set(v []Registry) *RegistryVecBuilder {
	s.inner = v
	return s
}
func (s *RegistryVecBuilder) Push(v Registry) *RegistryVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *RegistryVecBuilder) Extend(iter []Registry) *RegistryVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *RegistryVecBuilder) Replace(index uint, v Registry) *Registry {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewRegistryVecBuilder() *RegistryVecBuilder {
	return &RegistryVecBuilder{[]Registry{}}
}

type RegistryVec struct {
	inner []byte
}

func RegistryVecFromSliceUnchecked(slice []byte) *RegistryVec {
	return &RegistryVec{inner: slice}
}
func (s *RegistryVec) AsSlice() []byte {
	return s.inner
}

func RegistryVecDefault() RegistryVec {
	return *RegistryVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func RegistryVecFromSlice(slice []byte, _compatible bool) (*RegistryVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "RegistryVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "RegistryVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &RegistryVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(64*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "RegistryVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &RegistryVec{inner: slice}, nil
}

func (s *RegistryVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 64*s.ItemCount()
}
func (s *RegistryVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *RegistryVec) Len() uint {
	return s.ItemCount()
}
func (s *RegistryVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *Registry is nil, index is out of bounds
func (s *RegistryVec) Get(index uint) *Registry {
	var re *Registry
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 64*index
		end := start + 64
		re = RegistryFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *RegistryVec) AsBuilder() RegistryVecBuilder {
	size := s.ItemCount()
	t := NewRegistryVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type CotaNFTRegistryEntriesBuilder struct {
	registries RegistryVec
	proof      Bytes
}

func (s *CotaNFTRegistryEntriesBuilder) Build() CotaNFTRegistryEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.registries.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.registries.AsSlice())
	b.Write(s.proof.AsSlice())
	return CotaNFTRegistryEntries{inner: b.Bytes()}
}

func (s *CotaNFTRegistryEntriesBuilder) Registries(v RegistryVec) *CotaNFTRegistryEntriesBuilder {
	s.registries = v
	return s
}

func (s *CotaNFTRegistryEntriesBuilder) Proof(v Bytes) *CotaNFTRegistryEntriesBuilder {
	s.proof = v
	return s
}

func NewCotaNFTRegistryEntriesBuilder() *CotaNFTRegistryEntriesBuilder {
	return &CotaNFTRegistryEntriesBuilder{registries: RegistryVecDefault(), proof: BytesDefault()}
}

type CotaNFTRegistryEntries struct {
	inner []byte
}

func CotaNFTRegistryEntriesFromSliceUnchecked(slice []byte) *CotaNFTRegistryEntries {
	return &CotaNFTRegistryEntries{inner: slice}
}
func (s *CotaNFTRegistryEntries) AsSlice() []byte {
	return s.inner
}

func CotaNFTRegistryEntriesDefault() CotaNFTRegistryEntries {
	return *CotaNFTRegistryEntriesFromSliceUnchecked([]byte{20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func CotaNFTRegistryEntriesFromSlice(slice []byte, compatible bool) (*CotaNFTRegistryEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "CotaNFTRegistryEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CotaNFTRegistryEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
		return &CotaNFTRegistryEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CotaNFTRegistryEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "CotaNFTRegistryEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "CotaNFTRegistryEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = RegistryVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &CotaNFTRegistryEntries{inner: slice}, nil
}

func (s *CotaNFTRegistryEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *CotaNFTRegistryEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *CotaNFTRegistryEntries) Len() uint {
	return s.FieldCount()
}
func (s *CotaNFTRegistryEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *CotaNFTRegistryEntries) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *CotaNFTRegistryEntries) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *CotaNFTRegistryEntries) Registries() *RegistryVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return RegistryVecFromSliceUnchecked(s.inner[start:end])
}

func (s *CotaNFTRegistryEntries) Proof() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *CotaNFTRegistryEntries) AsBuilder() CotaNFTRegistryEntriesBuilder {
	ret := NewCotaNFTRegistryEntriesBuilder().Registries(*s.Registries()).Proof(*s.Proof())
	return *ret
}

type DefineCotaNFTIdBuilder struct {
	smtType Uint16
	cotaId  CotaId
}

func (s *DefineCotaNFTIdBuilder) Build() DefineCotaNFTId {
	b := new(bytes.Buffer)
	b.Write(s.smtType.AsSlice())
	b.Write(s.cotaId.AsSlice())
	return DefineCotaNFTId{inner: b.Bytes()}
}

func (s *DefineCotaNFTIdBuilder) SmtType(v Uint16) *DefineCotaNFTIdBuilder {
	s.smtType = v
	return s
}

func (s *DefineCotaNFTIdBuilder) CotaId(v CotaId) *DefineCotaNFTIdBuilder {
	s.cotaId = v
	return s
}

func NewDefineCotaNFTIdBuilder() *DefineCotaNFTIdBuilder {
	return &DefineCotaNFTIdBuilder{smtType: Uint16Default(), cotaId: CotaIdDefault()}
}

type DefineCotaNFTId struct {
	inner []byte
}

func DefineCotaNFTIdFromSliceUnchecked(slice []byte) *DefineCotaNFTId {
	return &DefineCotaNFTId{inner: slice}
}
func (s *DefineCotaNFTId) AsSlice() []byte {
	return s.inner
}

func DefineCotaNFTIdDefault() DefineCotaNFTId {
	return *DefineCotaNFTIdFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func DefineCotaNFTIdFromSlice(slice []byte, _compatible bool) (*DefineCotaNFTId, error) {
	sliceLen := len(slice)
	if sliceLen != 22 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "DefineCotaNFTId", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(22)}, " ")
		return nil, errors.New(errMsg)
	}
	return &DefineCotaNFTId{inner: slice}, nil
}

func (s *DefineCotaNFTId) SmtType() *Uint16 {
	ret := Uint16FromSliceUnchecked(s.inner[0:2])
	return ret
}

func (s *DefineCotaNFTId) CotaId() *CotaId {
	ret := CotaIdFromSliceUnchecked(s.inner[2:22])
	return ret
}

func (s *DefineCotaNFTId) AsBuilder() DefineCotaNFTIdBuilder {
	ret := NewDefineCotaNFTIdBuilder().SmtType(*s.SmtType()).CotaId(*s.CotaId())
	return *ret
}

type DefineCotaNFTKeyVecBuilder struct {
	inner []DefineCotaNFTId
}

func (s *DefineCotaNFTKeyVecBuilder) Build() DefineCotaNFTKeyVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := DefineCotaNFTKeyVec{inner: b.Bytes()}

	return sb
}

func (s *DefineCotaNFTKeyVecBuilder) Set(v []DefineCotaNFTId) *DefineCotaNFTKeyVecBuilder {
	s.inner = v
	return s
}
func (s *DefineCotaNFTKeyVecBuilder) Push(v DefineCotaNFTId) *DefineCotaNFTKeyVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *DefineCotaNFTKeyVecBuilder) Extend(iter []DefineCotaNFTId) *DefineCotaNFTKeyVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *DefineCotaNFTKeyVecBuilder) Replace(index uint, v DefineCotaNFTId) *DefineCotaNFTId {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewDefineCotaNFTKeyVecBuilder() *DefineCotaNFTKeyVecBuilder {
	return &DefineCotaNFTKeyVecBuilder{[]DefineCotaNFTId{}}
}

type DefineCotaNFTKeyVec struct {
	inner []byte
}

func DefineCotaNFTKeyVecFromSliceUnchecked(slice []byte) *DefineCotaNFTKeyVec {
	return &DefineCotaNFTKeyVec{inner: slice}
}
func (s *DefineCotaNFTKeyVec) AsSlice() []byte {
	return s.inner
}

func DefineCotaNFTKeyVecDefault() DefineCotaNFTKeyVec {
	return *DefineCotaNFTKeyVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func DefineCotaNFTKeyVecFromSlice(slice []byte, _compatible bool) (*DefineCotaNFTKeyVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "DefineCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "DefineCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &DefineCotaNFTKeyVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(22*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "DefineCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &DefineCotaNFTKeyVec{inner: slice}, nil
}

func (s *DefineCotaNFTKeyVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 22*s.ItemCount()
}
func (s *DefineCotaNFTKeyVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *DefineCotaNFTKeyVec) Len() uint {
	return s.ItemCount()
}
func (s *DefineCotaNFTKeyVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *DefineCotaNFTId is nil, index is out of bounds
func (s *DefineCotaNFTKeyVec) Get(index uint) *DefineCotaNFTId {
	var re *DefineCotaNFTId
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 22*index
		end := start + 22
		re = DefineCotaNFTIdFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *DefineCotaNFTKeyVec) AsBuilder() DefineCotaNFTKeyVecBuilder {
	size := s.ItemCount()
	t := NewDefineCotaNFTKeyVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type DefineCotaNFTValueBuilder struct {
	total     Uint32
	issued    Uint32
	configure Byte
}

func (s *DefineCotaNFTValueBuilder) Build() DefineCotaNFTValue {
	b := new(bytes.Buffer)
	b.Write(s.total.AsSlice())
	b.Write(s.issued.AsSlice())
	b.Write(s.configure.AsSlice())
	return DefineCotaNFTValue{inner: b.Bytes()}
}

func (s *DefineCotaNFTValueBuilder) Total(v Uint32) *DefineCotaNFTValueBuilder {
	s.total = v
	return s
}

func (s *DefineCotaNFTValueBuilder) Issued(v Uint32) *DefineCotaNFTValueBuilder {
	s.issued = v
	return s
}

func (s *DefineCotaNFTValueBuilder) Configure(v Byte) *DefineCotaNFTValueBuilder {
	s.configure = v
	return s
}

func NewDefineCotaNFTValueBuilder() *DefineCotaNFTValueBuilder {
	return &DefineCotaNFTValueBuilder{total: Uint32Default(), issued: Uint32Default(), configure: ByteDefault()}
}

type DefineCotaNFTValue struct {
	inner []byte
}

func DefineCotaNFTValueFromSliceUnchecked(slice []byte) *DefineCotaNFTValue {
	return &DefineCotaNFTValue{inner: slice}
}
func (s *DefineCotaNFTValue) AsSlice() []byte {
	return s.inner
}

func DefineCotaNFTValueDefault() DefineCotaNFTValue {
	return *DefineCotaNFTValueFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func DefineCotaNFTValueFromSlice(slice []byte, _compatible bool) (*DefineCotaNFTValue, error) {
	sliceLen := len(slice)
	if sliceLen != 9 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "DefineCotaNFTValue", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(9)}, " ")
		return nil, errors.New(errMsg)
	}
	return &DefineCotaNFTValue{inner: slice}, nil
}

func (s *DefineCotaNFTValue) Total() *Uint32 {
	ret := Uint32FromSliceUnchecked(s.inner[0:4])
	return ret
}

func (s *DefineCotaNFTValue) Issued() *Uint32 {
	ret := Uint32FromSliceUnchecked(s.inner[4:8])
	return ret
}

func (s *DefineCotaNFTValue) Configure() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *DefineCotaNFTValue) AsBuilder() DefineCotaNFTValueBuilder {
	ret := NewDefineCotaNFTValueBuilder().Total(*s.Total()).Issued(*s.Issued()).Configure(*s.Configure())
	return *ret
}

type DefineCotaNFTValueVecBuilder struct {
	inner []DefineCotaNFTValue
}

func (s *DefineCotaNFTValueVecBuilder) Build() DefineCotaNFTValueVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := DefineCotaNFTValueVec{inner: b.Bytes()}

	return sb
}

func (s *DefineCotaNFTValueVecBuilder) Set(v []DefineCotaNFTValue) *DefineCotaNFTValueVecBuilder {
	s.inner = v
	return s
}
func (s *DefineCotaNFTValueVecBuilder) Push(v DefineCotaNFTValue) *DefineCotaNFTValueVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *DefineCotaNFTValueVecBuilder) Extend(iter []DefineCotaNFTValue) *DefineCotaNFTValueVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *DefineCotaNFTValueVecBuilder) Replace(index uint, v DefineCotaNFTValue) *DefineCotaNFTValue {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewDefineCotaNFTValueVecBuilder() *DefineCotaNFTValueVecBuilder {
	return &DefineCotaNFTValueVecBuilder{[]DefineCotaNFTValue{}}
}

type DefineCotaNFTValueVec struct {
	inner []byte
}

func DefineCotaNFTValueVecFromSliceUnchecked(slice []byte) *DefineCotaNFTValueVec {
	return &DefineCotaNFTValueVec{inner: slice}
}
func (s *DefineCotaNFTValueVec) AsSlice() []byte {
	return s.inner
}

func DefineCotaNFTValueVecDefault() DefineCotaNFTValueVec {
	return *DefineCotaNFTValueVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func DefineCotaNFTValueVecFromSlice(slice []byte, _compatible bool) (*DefineCotaNFTValueVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "DefineCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "DefineCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &DefineCotaNFTValueVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(9*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "DefineCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &DefineCotaNFTValueVec{inner: slice}, nil
}

func (s *DefineCotaNFTValueVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 9*s.ItemCount()
}
func (s *DefineCotaNFTValueVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *DefineCotaNFTValueVec) Len() uint {
	return s.ItemCount()
}
func (s *DefineCotaNFTValueVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *DefineCotaNFTValue is nil, index is out of bounds
func (s *DefineCotaNFTValueVec) Get(index uint) *DefineCotaNFTValue {
	var re *DefineCotaNFTValue
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 9*index
		end := start + 9
		re = DefineCotaNFTValueFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *DefineCotaNFTValueVec) AsBuilder() DefineCotaNFTValueVecBuilder {
	size := s.ItemCount()
	t := NewDefineCotaNFTValueVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type DefineCotaNFTEntriesBuilder struct {
	defineKeys   DefineCotaNFTKeyVec
	defineValues DefineCotaNFTValueVec
	proof        Bytes
	action       Bytes
}

func (s *DefineCotaNFTEntriesBuilder) Build() DefineCotaNFTEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (4 + 1)
	offsets := make([]uint32, 0, 4)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.defineKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.defineValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.defineKeys.AsSlice())
	b.Write(s.defineValues.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.action.AsSlice())
	return DefineCotaNFTEntries{inner: b.Bytes()}
}

func (s *DefineCotaNFTEntriesBuilder) DefineKeys(v DefineCotaNFTKeyVec) *DefineCotaNFTEntriesBuilder {
	s.defineKeys = v
	return s
}

func (s *DefineCotaNFTEntriesBuilder) DefineValues(v DefineCotaNFTValueVec) *DefineCotaNFTEntriesBuilder {
	s.defineValues = v
	return s
}

func (s *DefineCotaNFTEntriesBuilder) Proof(v Bytes) *DefineCotaNFTEntriesBuilder {
	s.proof = v
	return s
}

func (s *DefineCotaNFTEntriesBuilder) Action(v Bytes) *DefineCotaNFTEntriesBuilder {
	s.action = v
	return s
}

func NewDefineCotaNFTEntriesBuilder() *DefineCotaNFTEntriesBuilder {
	return &DefineCotaNFTEntriesBuilder{defineKeys: DefineCotaNFTKeyVecDefault(), defineValues: DefineCotaNFTValueVecDefault(), proof: BytesDefault(), action: BytesDefault()}
}

type DefineCotaNFTEntries struct {
	inner []byte
}

func DefineCotaNFTEntriesFromSliceUnchecked(slice []byte) *DefineCotaNFTEntries {
	return &DefineCotaNFTEntries{inner: slice}
}
func (s *DefineCotaNFTEntries) AsSlice() []byte {
	return s.inner
}

func DefineCotaNFTEntriesDefault() DefineCotaNFTEntries {
	return *DefineCotaNFTEntriesFromSliceUnchecked([]byte{36, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func DefineCotaNFTEntriesFromSlice(slice []byte, compatible bool) (*DefineCotaNFTEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "DefineCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "DefineCotaNFTEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 4 == 0 {
		return &DefineCotaNFTEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "DefineCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "DefineCotaNFTEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "DefineCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 4 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 4 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = DefineCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = DefineCotaNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	return &DefineCotaNFTEntries{inner: slice}, nil
}

func (s *DefineCotaNFTEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *DefineCotaNFTEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *DefineCotaNFTEntries) Len() uint {
	return s.FieldCount()
}
func (s *DefineCotaNFTEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *DefineCotaNFTEntries) CountExtraFields() uint {
	return s.FieldCount() - 4
}

func (s *DefineCotaNFTEntries) HasExtraFields() bool {
	return 4 != s.FieldCount()
}

func (s *DefineCotaNFTEntries) DefineKeys() *DefineCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return DefineCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *DefineCotaNFTEntries) DefineValues() *DefineCotaNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return DefineCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *DefineCotaNFTEntries) Proof() *Bytes {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *DefineCotaNFTEntries) Action() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[16:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[20:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *DefineCotaNFTEntries) AsBuilder() DefineCotaNFTEntriesBuilder {
	ret := NewDefineCotaNFTEntriesBuilder().DefineKeys(*s.DefineKeys()).DefineValues(*s.DefineValues()).Proof(*s.Proof()).Action(*s.Action())
	return *ret
}

type MintCotaNFTEntriesBuilder struct {
	defineKeys       DefineCotaNFTKeyVec
	defineOldValues  DefineCotaNFTValueVec
	defineNewValues  DefineCotaNFTValueVec
	withdrawalKeys   WithdrawalCotaNFTKeyVec
	withdrawalValues WithdrawalCotaNFTValueVec
	proof            Bytes
	action           Bytes
}

func (s *MintCotaNFTEntriesBuilder) Build() MintCotaNFTEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (7 + 1)
	offsets := make([]uint32, 0, 7)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.defineKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.defineOldValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.defineNewValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawalKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawalValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.defineKeys.AsSlice())
	b.Write(s.defineOldValues.AsSlice())
	b.Write(s.defineNewValues.AsSlice())
	b.Write(s.withdrawalKeys.AsSlice())
	b.Write(s.withdrawalValues.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.action.AsSlice())
	return MintCotaNFTEntries{inner: b.Bytes()}
}

func (s *MintCotaNFTEntriesBuilder) DefineKeys(v DefineCotaNFTKeyVec) *MintCotaNFTEntriesBuilder {
	s.defineKeys = v
	return s
}

func (s *MintCotaNFTEntriesBuilder) DefineOldValues(v DefineCotaNFTValueVec) *MintCotaNFTEntriesBuilder {
	s.defineOldValues = v
	return s
}

func (s *MintCotaNFTEntriesBuilder) DefineNewValues(v DefineCotaNFTValueVec) *MintCotaNFTEntriesBuilder {
	s.defineNewValues = v
	return s
}

func (s *MintCotaNFTEntriesBuilder) WithdrawalKeys(v WithdrawalCotaNFTKeyVec) *MintCotaNFTEntriesBuilder {
	s.withdrawalKeys = v
	return s
}

func (s *MintCotaNFTEntriesBuilder) WithdrawalValues(v WithdrawalCotaNFTValueVec) *MintCotaNFTEntriesBuilder {
	s.withdrawalValues = v
	return s
}

func (s *MintCotaNFTEntriesBuilder) Proof(v Bytes) *MintCotaNFTEntriesBuilder {
	s.proof = v
	return s
}

func (s *MintCotaNFTEntriesBuilder) Action(v Bytes) *MintCotaNFTEntriesBuilder {
	s.action = v
	return s
}

func NewMintCotaNFTEntriesBuilder() *MintCotaNFTEntriesBuilder {
	return &MintCotaNFTEntriesBuilder{defineKeys: DefineCotaNFTKeyVecDefault(), defineOldValues: DefineCotaNFTValueVecDefault(), defineNewValues: DefineCotaNFTValueVecDefault(), withdrawalKeys: WithdrawalCotaNFTKeyVecDefault(), withdrawalValues: WithdrawalCotaNFTValueVecDefault(), proof: BytesDefault(), action: BytesDefault()}
}

type MintCotaNFTEntries struct {
	inner []byte
}

func MintCotaNFTEntriesFromSliceUnchecked(slice []byte) *MintCotaNFTEntries {
	return &MintCotaNFTEntries{inner: slice}
}
func (s *MintCotaNFTEntries) AsSlice() []byte {
	return s.inner
}

func MintCotaNFTEntriesDefault() MintCotaNFTEntries {
	return *MintCotaNFTEntriesFromSliceUnchecked([]byte{60, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func MintCotaNFTEntriesFromSlice(slice []byte, compatible bool) (*MintCotaNFTEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "MintCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "MintCotaNFTEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 7 == 0 {
		return &MintCotaNFTEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "MintCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "MintCotaNFTEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "MintCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 7 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 7 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = DefineCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = DefineCotaNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = DefineCotaNFTValueVecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTKeyVecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTValueVecFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	return &MintCotaNFTEntries{inner: slice}, nil
}

func (s *MintCotaNFTEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *MintCotaNFTEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *MintCotaNFTEntries) Len() uint {
	return s.FieldCount()
}
func (s *MintCotaNFTEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *MintCotaNFTEntries) CountExtraFields() uint {
	return s.FieldCount() - 7
}

func (s *MintCotaNFTEntries) HasExtraFields() bool {
	return 7 != s.FieldCount()
}

func (s *MintCotaNFTEntries) DefineKeys() *DefineCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return DefineCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCotaNFTEntries) DefineOldValues() *DefineCotaNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return DefineCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCotaNFTEntries) DefineNewValues() *DefineCotaNFTValueVec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return DefineCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCotaNFTEntries) WithdrawalKeys() *WithdrawalCotaNFTKeyVec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return WithdrawalCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCotaNFTEntries) WithdrawalValues() *WithdrawalCotaNFTValueVec {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return WithdrawalCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCotaNFTEntries) Proof() *Bytes {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCotaNFTEntries) Action() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[28:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[32:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *MintCotaNFTEntries) AsBuilder() MintCotaNFTEntriesBuilder {
	ret := NewMintCotaNFTEntriesBuilder().DefineKeys(*s.DefineKeys()).DefineOldValues(*s.DefineOldValues()).DefineNewValues(*s.DefineNewValues()).WithdrawalKeys(*s.WithdrawalKeys()).WithdrawalValues(*s.WithdrawalValues()).Proof(*s.Proof()).Action(*s.Action())
	return *ret
}

type WithdrawalCotaNFTKeyVecBuilder struct {
	inner []CotaNFTId
}

func (s *WithdrawalCotaNFTKeyVecBuilder) Build() WithdrawalCotaNFTKeyVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := WithdrawalCotaNFTKeyVec{inner: b.Bytes()}

	return sb
}

func (s *WithdrawalCotaNFTKeyVecBuilder) Set(v []CotaNFTId) *WithdrawalCotaNFTKeyVecBuilder {
	s.inner = v
	return s
}
func (s *WithdrawalCotaNFTKeyVecBuilder) Push(v CotaNFTId) *WithdrawalCotaNFTKeyVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *WithdrawalCotaNFTKeyVecBuilder) Extend(iter []CotaNFTId) *WithdrawalCotaNFTKeyVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *WithdrawalCotaNFTKeyVecBuilder) Replace(index uint, v CotaNFTId) *CotaNFTId {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewWithdrawalCotaNFTKeyVecBuilder() *WithdrawalCotaNFTKeyVecBuilder {
	return &WithdrawalCotaNFTKeyVecBuilder{[]CotaNFTId{}}
}

type WithdrawalCotaNFTKeyVec struct {
	inner []byte
}

func WithdrawalCotaNFTKeyVecFromSliceUnchecked(slice []byte) *WithdrawalCotaNFTKeyVec {
	return &WithdrawalCotaNFTKeyVec{inner: slice}
}
func (s *WithdrawalCotaNFTKeyVec) AsSlice() []byte {
	return s.inner
}

func WithdrawalCotaNFTKeyVecDefault() WithdrawalCotaNFTKeyVec {
	return *WithdrawalCotaNFTKeyVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func WithdrawalCotaNFTKeyVecFromSlice(slice []byte, _compatible bool) (*WithdrawalCotaNFTKeyVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &WithdrawalCotaNFTKeyVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(26*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &WithdrawalCotaNFTKeyVec{inner: slice}, nil
}

func (s *WithdrawalCotaNFTKeyVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 26*s.ItemCount()
}
func (s *WithdrawalCotaNFTKeyVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *WithdrawalCotaNFTKeyVec) Len() uint {
	return s.ItemCount()
}
func (s *WithdrawalCotaNFTKeyVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *CotaNFTId is nil, index is out of bounds
func (s *WithdrawalCotaNFTKeyVec) Get(index uint) *CotaNFTId {
	var re *CotaNFTId
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 26*index
		end := start + 26
		re = CotaNFTIdFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *WithdrawalCotaNFTKeyVec) AsBuilder() WithdrawalCotaNFTKeyVecBuilder {
	size := s.ItemCount()
	t := NewWithdrawalCotaNFTKeyVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type WithdrawalCotaNFTValueBuilder struct {
	nftInfo  CotaNFTInfo
	to_lock  Bytes
	outPoint OutPointSlice
}

func (s *WithdrawalCotaNFTValueBuilder) Build() WithdrawalCotaNFTValue {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.nftInfo.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.to_lock.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.outPoint.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.nftInfo.AsSlice())
	b.Write(s.to_lock.AsSlice())
	b.Write(s.outPoint.AsSlice())
	return WithdrawalCotaNFTValue{inner: b.Bytes()}
}

func (s *WithdrawalCotaNFTValueBuilder) NftInfo(v CotaNFTInfo) *WithdrawalCotaNFTValueBuilder {
	s.nftInfo = v
	return s
}

func (s *WithdrawalCotaNFTValueBuilder) ToLock(v Bytes) *WithdrawalCotaNFTValueBuilder {
	s.to_lock = v
	return s
}

func (s *WithdrawalCotaNFTValueBuilder) OutPoint(v OutPointSlice) *WithdrawalCotaNFTValueBuilder {
	s.outPoint = v
	return s
}

func NewWithdrawalCotaNFTValueBuilder() *WithdrawalCotaNFTValueBuilder {
	return &WithdrawalCotaNFTValueBuilder{nftInfo: CotaNFTInfoDefault(), to_lock: BytesDefault(), outPoint: OutPointSliceDefault()}
}

type WithdrawalCotaNFTValue struct {
	inner []byte
}

func WithdrawalCotaNFTValueFromSliceUnchecked(slice []byte) *WithdrawalCotaNFTValue {
	return &WithdrawalCotaNFTValue{inner: slice}
}
func (s *WithdrawalCotaNFTValue) AsSlice() []byte {
	return s.inner
}

func WithdrawalCotaNFTValueDefault() WithdrawalCotaNFTValue {
	return *WithdrawalCotaNFTValueFromSliceUnchecked([]byte{66, 0, 0, 0, 16, 0, 0, 0, 38, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func WithdrawalCotaNFTValueFromSlice(slice []byte, compatible bool) (*WithdrawalCotaNFTValue, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTValue", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTValue", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 3 == 0 {
		return &WithdrawalCotaNFTValue{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTValue", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "WithdrawalCotaNFTValue", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTValue", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = CotaNFTInfoFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = OutPointSliceFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &WithdrawalCotaNFTValue{inner: slice}, nil
}

func (s *WithdrawalCotaNFTValue) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *WithdrawalCotaNFTValue) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *WithdrawalCotaNFTValue) Len() uint {
	return s.FieldCount()
}
func (s *WithdrawalCotaNFTValue) IsEmpty() bool {
	return s.Len() == 0
}
func (s *WithdrawalCotaNFTValue) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *WithdrawalCotaNFTValue) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *WithdrawalCotaNFTValue) NftInfo() *CotaNFTInfo {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return CotaNFTInfoFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawalCotaNFTValue) ToLock() *Bytes {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawalCotaNFTValue) OutPoint() *OutPointSlice {
	var ret *OutPointSlice
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = OutPointSliceFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = OutPointSliceFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *WithdrawalCotaNFTValue) AsBuilder() WithdrawalCotaNFTValueBuilder {
	ret := NewWithdrawalCotaNFTValueBuilder().NftInfo(*s.NftInfo()).ToLock(*s.ToLock()).OutPoint(*s.OutPoint())
	return *ret
}

type WithdrawalCotaNFTValueVecBuilder struct {
	inner []WithdrawalCotaNFTValue
}

func (s *WithdrawalCotaNFTValueVecBuilder) Build() WithdrawalCotaNFTValueVec {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return WithdrawalCotaNFTValueVec{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return WithdrawalCotaNFTValueVec{inner: b.Bytes()}
}

func (s *WithdrawalCotaNFTValueVecBuilder) Set(v []WithdrawalCotaNFTValue) *WithdrawalCotaNFTValueVecBuilder {
	s.inner = v
	return s
}
func (s *WithdrawalCotaNFTValueVecBuilder) Push(v WithdrawalCotaNFTValue) *WithdrawalCotaNFTValueVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *WithdrawalCotaNFTValueVecBuilder) Extend(iter []WithdrawalCotaNFTValue) *WithdrawalCotaNFTValueVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *WithdrawalCotaNFTValueVecBuilder) Replace(index uint, v WithdrawalCotaNFTValue) *WithdrawalCotaNFTValue {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewWithdrawalCotaNFTValueVecBuilder() *WithdrawalCotaNFTValueVecBuilder {
	return &WithdrawalCotaNFTValueVecBuilder{[]WithdrawalCotaNFTValue{}}
}

type WithdrawalCotaNFTValueVec struct {
	inner []byte
}

func WithdrawalCotaNFTValueVecFromSliceUnchecked(slice []byte) *WithdrawalCotaNFTValueVec {
	return &WithdrawalCotaNFTValueVec{inner: slice}
}
func (s *WithdrawalCotaNFTValueVec) AsSlice() []byte {
	return s.inner
}

func WithdrawalCotaNFTValueVecDefault() WithdrawalCotaNFTValueVec {
	return *WithdrawalCotaNFTValueVecFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func WithdrawalCotaNFTValueVecFromSlice(slice []byte, compatible bool) (*WithdrawalCotaNFTValueVec, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &WithdrawalCotaNFTValueVec{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "WithdrawalCotaNFTValueVec", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "WithdrawalCotaNFTValueVec"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := WithdrawalCotaNFTValueFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &WithdrawalCotaNFTValueVec{inner: slice}, nil
}

func (s *WithdrawalCotaNFTValueVec) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *WithdrawalCotaNFTValueVec) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *WithdrawalCotaNFTValueVec) Len() uint {
	return s.ItemCount()
}
func (s *WithdrawalCotaNFTValueVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *WithdrawalCotaNFTValue is nil, index is out of bounds
func (s *WithdrawalCotaNFTValueVec) Get(index uint) *WithdrawalCotaNFTValue {
	var b *WithdrawalCotaNFTValue
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = WithdrawalCotaNFTValueFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = WithdrawalCotaNFTValueFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *WithdrawalCotaNFTValueVec) AsBuilder() WithdrawalCotaNFTValueVecBuilder {
	size := s.ItemCount()
	t := NewWithdrawalCotaNFTValueVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type WithdrawalCotaNFTEntriesBuilder struct {
	holdKeys         HoldCotaNFTKeyVec
	holdValues       HoldCotaNFTValueVec
	withdrawalKeys   WithdrawalCotaNFTKeyVec
	withdrawalValues WithdrawalCotaNFTValueVec
	proof            Bytes
	action           Bytes
}

func (s *WithdrawalCotaNFTEntriesBuilder) Build() WithdrawalCotaNFTEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (6 + 1)
	offsets := make([]uint32, 0, 6)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.holdKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.holdValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawalKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawalValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.holdKeys.AsSlice())
	b.Write(s.holdValues.AsSlice())
	b.Write(s.withdrawalKeys.AsSlice())
	b.Write(s.withdrawalValues.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.action.AsSlice())
	return WithdrawalCotaNFTEntries{inner: b.Bytes()}
}

func (s *WithdrawalCotaNFTEntriesBuilder) HoldKeys(v HoldCotaNFTKeyVec) *WithdrawalCotaNFTEntriesBuilder {
	s.holdKeys = v
	return s
}

func (s *WithdrawalCotaNFTEntriesBuilder) HoldValues(v HoldCotaNFTValueVec) *WithdrawalCotaNFTEntriesBuilder {
	s.holdValues = v
	return s
}

func (s *WithdrawalCotaNFTEntriesBuilder) WithdrawalKeys(v WithdrawalCotaNFTKeyVec) *WithdrawalCotaNFTEntriesBuilder {
	s.withdrawalKeys = v
	return s
}

func (s *WithdrawalCotaNFTEntriesBuilder) WithdrawalValues(v WithdrawalCotaNFTValueVec) *WithdrawalCotaNFTEntriesBuilder {
	s.withdrawalValues = v
	return s
}

func (s *WithdrawalCotaNFTEntriesBuilder) Proof(v Bytes) *WithdrawalCotaNFTEntriesBuilder {
	s.proof = v
	return s
}

func (s *WithdrawalCotaNFTEntriesBuilder) Action(v Bytes) *WithdrawalCotaNFTEntriesBuilder {
	s.action = v
	return s
}

func NewWithdrawalCotaNFTEntriesBuilder() *WithdrawalCotaNFTEntriesBuilder {
	return &WithdrawalCotaNFTEntriesBuilder{holdKeys: HoldCotaNFTKeyVecDefault(), holdValues: HoldCotaNFTValueVecDefault(), withdrawalKeys: WithdrawalCotaNFTKeyVecDefault(), withdrawalValues: WithdrawalCotaNFTValueVecDefault(), proof: BytesDefault(), action: BytesDefault()}
}

type WithdrawalCotaNFTEntries struct {
	inner []byte
}

func WithdrawalCotaNFTEntriesFromSliceUnchecked(slice []byte) *WithdrawalCotaNFTEntries {
	return &WithdrawalCotaNFTEntries{inner: slice}
}
func (s *WithdrawalCotaNFTEntries) AsSlice() []byte {
	return s.inner
}

func WithdrawalCotaNFTEntriesDefault() WithdrawalCotaNFTEntries {
	return *WithdrawalCotaNFTEntriesFromSliceUnchecked([]byte{52, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func WithdrawalCotaNFTEntriesFromSlice(slice []byte, compatible bool) (*WithdrawalCotaNFTEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 6 == 0 {
		return &WithdrawalCotaNFTEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "WithdrawalCotaNFTEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 6 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 6 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = HoldCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HoldCotaNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTKeyVecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTValueVecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	return &WithdrawalCotaNFTEntries{inner: slice}, nil
}

func (s *WithdrawalCotaNFTEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *WithdrawalCotaNFTEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *WithdrawalCotaNFTEntries) Len() uint {
	return s.FieldCount()
}
func (s *WithdrawalCotaNFTEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *WithdrawalCotaNFTEntries) CountExtraFields() uint {
	return s.FieldCount() - 6
}

func (s *WithdrawalCotaNFTEntries) HasExtraFields() bool {
	return 6 != s.FieldCount()
}

func (s *WithdrawalCotaNFTEntries) HoldKeys() *HoldCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return HoldCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawalCotaNFTEntries) HoldValues() *HoldCotaNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return HoldCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawalCotaNFTEntries) WithdrawalKeys() *WithdrawalCotaNFTKeyVec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return WithdrawalCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawalCotaNFTEntries) WithdrawalValues() *WithdrawalCotaNFTValueVec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return WithdrawalCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawalCotaNFTEntries) Proof() *Bytes {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawalCotaNFTEntries) Action() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[24:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[28:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *WithdrawalCotaNFTEntries) AsBuilder() WithdrawalCotaNFTEntriesBuilder {
	ret := NewWithdrawalCotaNFTEntriesBuilder().HoldKeys(*s.HoldKeys()).HoldValues(*s.HoldValues()).WithdrawalKeys(*s.WithdrawalKeys()).WithdrawalValues(*s.WithdrawalValues()).Proof(*s.Proof()).Action(*s.Action())
	return *ret
}

type ClaimCotaNFTKeyBuilder struct {
	nftId    CotaNFTId
	outPoint OutPointSlice
}

func (s *ClaimCotaNFTKeyBuilder) Build() ClaimCotaNFTKey {
	b := new(bytes.Buffer)
	b.Write(s.nftId.AsSlice())
	b.Write(s.outPoint.AsSlice())
	return ClaimCotaNFTKey{inner: b.Bytes()}
}

func (s *ClaimCotaNFTKeyBuilder) NftId(v CotaNFTId) *ClaimCotaNFTKeyBuilder {
	s.nftId = v
	return s
}

func (s *ClaimCotaNFTKeyBuilder) OutPoint(v OutPointSlice) *ClaimCotaNFTKeyBuilder {
	s.outPoint = v
	return s
}

func NewClaimCotaNFTKeyBuilder() *ClaimCotaNFTKeyBuilder {
	return &ClaimCotaNFTKeyBuilder{nftId: CotaNFTIdDefault(), outPoint: OutPointSliceDefault()}
}

type ClaimCotaNFTKey struct {
	inner []byte
}

func ClaimCotaNFTKeyFromSliceUnchecked(slice []byte) *ClaimCotaNFTKey {
	return &ClaimCotaNFTKey{inner: slice}
}
func (s *ClaimCotaNFTKey) AsSlice() []byte {
	return s.inner
}

func ClaimCotaNFTKeyDefault() ClaimCotaNFTKey {
	return *ClaimCotaNFTKeyFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ClaimCotaNFTKeyFromSlice(slice []byte, _compatible bool) (*ClaimCotaNFTKey, error) {
	sliceLen := len(slice)
	if sliceLen != 50 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimCotaNFTKey", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(50)}, " ")
		return nil, errors.New(errMsg)
	}
	return &ClaimCotaNFTKey{inner: slice}, nil
}

func (s *ClaimCotaNFTKey) NftId() *CotaNFTId {
	ret := CotaNFTIdFromSliceUnchecked(s.inner[0:26])
	return ret
}

func (s *ClaimCotaNFTKey) OutPoint() *OutPointSlice {
	ret := OutPointSliceFromSliceUnchecked(s.inner[26:50])
	return ret
}

func (s *ClaimCotaNFTKey) AsBuilder() ClaimCotaNFTKeyBuilder {
	ret := NewClaimCotaNFTKeyBuilder().NftId(*s.NftId()).OutPoint(*s.OutPoint())
	return *ret
}

type ClaimCotaNFTKeyVecBuilder struct {
	inner []ClaimCotaNFTKey
}

func (s *ClaimCotaNFTKeyVecBuilder) Build() ClaimCotaNFTKeyVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := ClaimCotaNFTKeyVec{inner: b.Bytes()}

	return sb
}

func (s *ClaimCotaNFTKeyVecBuilder) Set(v []ClaimCotaNFTKey) *ClaimCotaNFTKeyVecBuilder {
	s.inner = v
	return s
}
func (s *ClaimCotaNFTKeyVecBuilder) Push(v ClaimCotaNFTKey) *ClaimCotaNFTKeyVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *ClaimCotaNFTKeyVecBuilder) Extend(iter []ClaimCotaNFTKey) *ClaimCotaNFTKeyVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *ClaimCotaNFTKeyVecBuilder) Replace(index uint, v ClaimCotaNFTKey) *ClaimCotaNFTKey {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewClaimCotaNFTKeyVecBuilder() *ClaimCotaNFTKeyVecBuilder {
	return &ClaimCotaNFTKeyVecBuilder{[]ClaimCotaNFTKey{}}
}

type ClaimCotaNFTKeyVec struct {
	inner []byte
}

func ClaimCotaNFTKeyVecFromSliceUnchecked(slice []byte) *ClaimCotaNFTKeyVec {
	return &ClaimCotaNFTKeyVec{inner: slice}
}
func (s *ClaimCotaNFTKeyVec) AsSlice() []byte {
	return s.inner
}

func ClaimCotaNFTKeyVecDefault() ClaimCotaNFTKeyVec {
	return *ClaimCotaNFTKeyVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func ClaimCotaNFTKeyVecFromSlice(slice []byte, _compatible bool) (*ClaimCotaNFTKeyVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &ClaimCotaNFTKeyVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(50*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimCotaNFTKeyVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &ClaimCotaNFTKeyVec{inner: slice}, nil
}

func (s *ClaimCotaNFTKeyVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 50*s.ItemCount()
}
func (s *ClaimCotaNFTKeyVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *ClaimCotaNFTKeyVec) Len() uint {
	return s.ItemCount()
}
func (s *ClaimCotaNFTKeyVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *ClaimCotaNFTKey is nil, index is out of bounds
func (s *ClaimCotaNFTKeyVec) Get(index uint) *ClaimCotaNFTKey {
	var re *ClaimCotaNFTKey
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 50*index
		end := start + 50
		re = ClaimCotaNFTKeyFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *ClaimCotaNFTKeyVec) AsBuilder() ClaimCotaNFTKeyVecBuilder {
	size := s.ItemCount()
	t := NewClaimCotaNFTKeyVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type ClaimCotaNFTValueVecBuilder struct {
	inner []Byte32
}

func (s *ClaimCotaNFTValueVecBuilder) Build() ClaimCotaNFTValueVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := ClaimCotaNFTValueVec{inner: b.Bytes()}

	return sb
}

func (s *ClaimCotaNFTValueVecBuilder) Set(v []Byte32) *ClaimCotaNFTValueVecBuilder {
	s.inner = v
	return s
}
func (s *ClaimCotaNFTValueVecBuilder) Push(v Byte32) *ClaimCotaNFTValueVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *ClaimCotaNFTValueVecBuilder) Extend(iter []Byte32) *ClaimCotaNFTValueVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *ClaimCotaNFTValueVecBuilder) Replace(index uint, v Byte32) *Byte32 {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewClaimCotaNFTValueVecBuilder() *ClaimCotaNFTValueVecBuilder {
	return &ClaimCotaNFTValueVecBuilder{[]Byte32{}}
}

type ClaimCotaNFTValueVec struct {
	inner []byte
}

func ClaimCotaNFTValueVecFromSliceUnchecked(slice []byte) *ClaimCotaNFTValueVec {
	return &ClaimCotaNFTValueVec{inner: slice}
}
func (s *ClaimCotaNFTValueVec) AsSlice() []byte {
	return s.inner
}

func ClaimCotaNFTValueVecDefault() ClaimCotaNFTValueVec {
	return *ClaimCotaNFTValueVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func ClaimCotaNFTValueVecFromSlice(slice []byte, _compatible bool) (*ClaimCotaNFTValueVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &ClaimCotaNFTValueVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(32*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimCotaNFTValueVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &ClaimCotaNFTValueVec{inner: slice}, nil
}

func (s *ClaimCotaNFTValueVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 32*s.ItemCount()
}
func (s *ClaimCotaNFTValueVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *ClaimCotaNFTValueVec) Len() uint {
	return s.ItemCount()
}
func (s *ClaimCotaNFTValueVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *Byte32 is nil, index is out of bounds
func (s *ClaimCotaNFTValueVec) Get(index uint) *Byte32 {
	var re *Byte32
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 32*index
		end := start + 32
		re = Byte32FromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *ClaimCotaNFTValueVec) AsBuilder() ClaimCotaNFTValueVecBuilder {
	size := s.ItemCount()
	t := NewClaimCotaNFTValueVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type ClaimCotaNFTInfoBuilder struct {
	version  Byte
	nft_info CotaNFTInfo
}

func (s *ClaimCotaNFTInfoBuilder) Build() ClaimCotaNFTInfo {
	b := new(bytes.Buffer)
	b.Write(s.version.AsSlice())
	b.Write(s.nft_info.AsSlice())
	return ClaimCotaNFTInfo{inner: b.Bytes()}
}

func (s *ClaimCotaNFTInfoBuilder) Version(v Byte) *ClaimCotaNFTInfoBuilder {
	s.version = v
	return s
}

func (s *ClaimCotaNFTInfoBuilder) NftInfo(v CotaNFTInfo) *ClaimCotaNFTInfoBuilder {
	s.nft_info = v
	return s
}

func NewClaimCotaNFTInfoBuilder() *ClaimCotaNFTInfoBuilder {
	return &ClaimCotaNFTInfoBuilder{version: ByteDefault(), nft_info: CotaNFTInfoDefault()}
}

type ClaimCotaNFTInfo struct {
	inner []byte
}

func ClaimCotaNFTInfoFromSliceUnchecked(slice []byte) *ClaimCotaNFTInfo {
	return &ClaimCotaNFTInfo{inner: slice}
}
func (s *ClaimCotaNFTInfo) AsSlice() []byte {
	return s.inner
}

func ClaimCotaNFTInfoDefault() ClaimCotaNFTInfo {
	return *ClaimCotaNFTInfoFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ClaimCotaNFTInfoFromSlice(slice []byte, _compatible bool) (*ClaimCotaNFTInfo, error) {
	sliceLen := len(slice)
	if sliceLen != 23 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimCotaNFTInfo", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(23)}, " ")
		return nil, errors.New(errMsg)
	}
	return &ClaimCotaNFTInfo{inner: slice}, nil
}

func (s *ClaimCotaNFTInfo) Version() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *ClaimCotaNFTInfo) NftInfo() *CotaNFTInfo {
	ret := CotaNFTInfoFromSliceUnchecked(s.inner[1:23])
	return ret
}

func (s *ClaimCotaNFTInfo) AsBuilder() ClaimCotaNFTInfoBuilder {
	ret := NewClaimCotaNFTInfoBuilder().Version(*s.Version()).NftInfo(*s.NftInfo())
	return *ret
}

type ClaimCotaNFTInfoVecBuilder struct {
	inner []ClaimCotaNFTInfo
}

func (s *ClaimCotaNFTInfoVecBuilder) Build() ClaimCotaNFTInfoVec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := ClaimCotaNFTInfoVec{inner: b.Bytes()}

	return sb
}

func (s *ClaimCotaNFTInfoVecBuilder) Set(v []ClaimCotaNFTInfo) *ClaimCotaNFTInfoVecBuilder {
	s.inner = v
	return s
}
func (s *ClaimCotaNFTInfoVecBuilder) Push(v ClaimCotaNFTInfo) *ClaimCotaNFTInfoVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *ClaimCotaNFTInfoVecBuilder) Extend(iter []ClaimCotaNFTInfo) *ClaimCotaNFTInfoVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *ClaimCotaNFTInfoVecBuilder) Replace(index uint, v ClaimCotaNFTInfo) *ClaimCotaNFTInfo {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewClaimCotaNFTInfoVecBuilder() *ClaimCotaNFTInfoVecBuilder {
	return &ClaimCotaNFTInfoVecBuilder{[]ClaimCotaNFTInfo{}}
}

type ClaimCotaNFTInfoVec struct {
	inner []byte
}

func ClaimCotaNFTInfoVecFromSliceUnchecked(slice []byte) *ClaimCotaNFTInfoVec {
	return &ClaimCotaNFTInfoVec{inner: slice}
}
func (s *ClaimCotaNFTInfoVec) AsSlice() []byte {
	return s.inner
}

func ClaimCotaNFTInfoVecDefault() ClaimCotaNFTInfoVec {
	return *ClaimCotaNFTInfoVecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func ClaimCotaNFTInfoVecFromSlice(slice []byte, _compatible bool) (*ClaimCotaNFTInfoVec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimCotaNFTInfoVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimCotaNFTInfoVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &ClaimCotaNFTInfoVec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(23*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimCotaNFTInfoVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &ClaimCotaNFTInfoVec{inner: slice}, nil
}

func (s *ClaimCotaNFTInfoVec) TotalSize() uint {
	return uint(HeaderSizeUint) + 23*s.ItemCount()
}
func (s *ClaimCotaNFTInfoVec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *ClaimCotaNFTInfoVec) Len() uint {
	return s.ItemCount()
}
func (s *ClaimCotaNFTInfoVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *ClaimCotaNFTInfo is nil, index is out of bounds
func (s *ClaimCotaNFTInfoVec) Get(index uint) *ClaimCotaNFTInfo {
	var re *ClaimCotaNFTInfo
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 23*index
		end := start + 23
		re = ClaimCotaNFTInfoFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *ClaimCotaNFTInfoVec) AsBuilder() ClaimCotaNFTInfoVecBuilder {
	size := s.ItemCount()
	t := NewClaimCotaNFTInfoVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type ClaimCotaNFTEntriesBuilder struct {
	holdKeys        HoldCotaNFTKeyVec
	holdValues      HoldCotaNFTValueVec
	claimKeys       ClaimCotaNFTKeyVec
	claimValues     ClaimCotaNFTValueVec
	proof           Bytes
	withdrawalProof Bytes
	action          Bytes
}

func (s *ClaimCotaNFTEntriesBuilder) Build() ClaimCotaNFTEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (7 + 1)
	offsets := make([]uint32, 0, 7)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.holdKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.holdValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claimKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claimValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawalProof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.holdKeys.AsSlice())
	b.Write(s.holdValues.AsSlice())
	b.Write(s.claimKeys.AsSlice())
	b.Write(s.claimValues.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.withdrawalProof.AsSlice())
	b.Write(s.action.AsSlice())
	return ClaimCotaNFTEntries{inner: b.Bytes()}
}

func (s *ClaimCotaNFTEntriesBuilder) HoldKeys(v HoldCotaNFTKeyVec) *ClaimCotaNFTEntriesBuilder {
	s.holdKeys = v
	return s
}

func (s *ClaimCotaNFTEntriesBuilder) HoldValues(v HoldCotaNFTValueVec) *ClaimCotaNFTEntriesBuilder {
	s.holdValues = v
	return s
}

func (s *ClaimCotaNFTEntriesBuilder) ClaimKeys(v ClaimCotaNFTKeyVec) *ClaimCotaNFTEntriesBuilder {
	s.claimKeys = v
	return s
}

func (s *ClaimCotaNFTEntriesBuilder) ClaimValues(v ClaimCotaNFTValueVec) *ClaimCotaNFTEntriesBuilder {
	s.claimValues = v
	return s
}

func (s *ClaimCotaNFTEntriesBuilder) Proof(v Bytes) *ClaimCotaNFTEntriesBuilder {
	s.proof = v
	return s
}

func (s *ClaimCotaNFTEntriesBuilder) WithdrawalProof(v Bytes) *ClaimCotaNFTEntriesBuilder {
	s.withdrawalProof = v
	return s
}

func (s *ClaimCotaNFTEntriesBuilder) Action(v Bytes) *ClaimCotaNFTEntriesBuilder {
	s.action = v
	return s
}

func NewClaimCotaNFTEntriesBuilder() *ClaimCotaNFTEntriesBuilder {
	return &ClaimCotaNFTEntriesBuilder{holdKeys: HoldCotaNFTKeyVecDefault(), holdValues: HoldCotaNFTValueVecDefault(), claimKeys: ClaimCotaNFTKeyVecDefault(), claimValues: ClaimCotaNFTValueVecDefault(), proof: BytesDefault(), withdrawalProof: BytesDefault(), action: BytesDefault()}
}

type ClaimCotaNFTEntries struct {
	inner []byte
}

func ClaimCotaNFTEntriesFromSliceUnchecked(slice []byte) *ClaimCotaNFTEntries {
	return &ClaimCotaNFTEntries{inner: slice}
}
func (s *ClaimCotaNFTEntries) AsSlice() []byte {
	return s.inner
}

func ClaimCotaNFTEntriesDefault() ClaimCotaNFTEntries {
	return *ClaimCotaNFTEntriesFromSliceUnchecked([]byte{60, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ClaimCotaNFTEntriesFromSlice(slice []byte, compatible bool) (*ClaimCotaNFTEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimCotaNFTEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 7 == 0 {
		return &ClaimCotaNFTEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ClaimCotaNFTEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 7 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 7 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = HoldCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HoldCotaNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimCotaNFTKeyVecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimCotaNFTValueVecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	return &ClaimCotaNFTEntries{inner: slice}, nil
}

func (s *ClaimCotaNFTEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ClaimCotaNFTEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ClaimCotaNFTEntries) Len() uint {
	return s.FieldCount()
}
func (s *ClaimCotaNFTEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ClaimCotaNFTEntries) CountExtraFields() uint {
	return s.FieldCount() - 7
}

func (s *ClaimCotaNFTEntries) HasExtraFields() bool {
	return 7 != s.FieldCount()
}

func (s *ClaimCotaNFTEntries) HoldKeys() *HoldCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return HoldCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTEntries) HoldValues() *HoldCotaNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return HoldCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTEntries) ClaimKeys() *ClaimCotaNFTKeyVec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return ClaimCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTEntries) ClaimValues() *ClaimCotaNFTValueVec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return ClaimCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTEntries) Proof() *Bytes {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTEntries) WithdrawalProof() *Bytes {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTEntries) Action() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[28:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[32:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ClaimCotaNFTEntries) AsBuilder() ClaimCotaNFTEntriesBuilder {
	ret := NewClaimCotaNFTEntriesBuilder().HoldKeys(*s.HoldKeys()).HoldValues(*s.HoldValues()).ClaimKeys(*s.ClaimKeys()).ClaimValues(*s.ClaimValues()).Proof(*s.Proof()).WithdrawalProof(*s.WithdrawalProof()).Action(*s.Action())
	return *ret
}

type TransferCotaNFTEntriesBuilder struct {
	claim_keys        ClaimCotaNFTKeyVec
	claim_values      ClaimCotaNFTValueVec
	withdrawal_keys   WithdrawalCotaNFTKeyVec
	withdrawal_values WithdrawalCotaNFTValueVec
	proof             Bytes
	withdrawal_proof  Bytes
	action            Bytes
}

func (s *TransferCotaNFTEntriesBuilder) Build() TransferCotaNFTEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (7 + 1)
	offsets := make([]uint32, 0, 7)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claim_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claim_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.claim_keys.AsSlice())
	b.Write(s.claim_values.AsSlice())
	b.Write(s.withdrawal_keys.AsSlice())
	b.Write(s.withdrawal_values.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.withdrawal_proof.AsSlice())
	b.Write(s.action.AsSlice())
	return TransferCotaNFTEntries{inner: b.Bytes()}
}

func (s *TransferCotaNFTEntriesBuilder) ClaimKeys(v ClaimCotaNFTKeyVec) *TransferCotaNFTEntriesBuilder {
	s.claim_keys = v
	return s
}

func (s *TransferCotaNFTEntriesBuilder) ClaimValues(v ClaimCotaNFTValueVec) *TransferCotaNFTEntriesBuilder {
	s.claim_values = v
	return s
}

func (s *TransferCotaNFTEntriesBuilder) WithdrawalKeys(v WithdrawalCotaNFTKeyVec) *TransferCotaNFTEntriesBuilder {
	s.withdrawal_keys = v
	return s
}

func (s *TransferCotaNFTEntriesBuilder) WithdrawalValues(v WithdrawalCotaNFTValueVec) *TransferCotaNFTEntriesBuilder {
	s.withdrawal_values = v
	return s
}

func (s *TransferCotaNFTEntriesBuilder) Proof(v Bytes) *TransferCotaNFTEntriesBuilder {
	s.proof = v
	return s
}

func (s *TransferCotaNFTEntriesBuilder) WithdrawalProof(v Bytes) *TransferCotaNFTEntriesBuilder {
	s.withdrawal_proof = v
	return s
}

func (s *TransferCotaNFTEntriesBuilder) Action(v Bytes) *TransferCotaNFTEntriesBuilder {
	s.action = v
	return s
}

func NewTransferCotaNFTEntriesBuilder() *TransferCotaNFTEntriesBuilder {
	return &TransferCotaNFTEntriesBuilder{claim_keys: ClaimCotaNFTKeyVecDefault(), claim_values: ClaimCotaNFTValueVecDefault(), withdrawal_keys: WithdrawalCotaNFTKeyVecDefault(), withdrawal_values: WithdrawalCotaNFTValueVecDefault(), proof: BytesDefault(), withdrawal_proof: BytesDefault(), action: BytesDefault()}
}

type TransferCotaNFTEntries struct {
	inner []byte
}

func TransferCotaNFTEntriesFromSliceUnchecked(slice []byte) *TransferCotaNFTEntries {
	return &TransferCotaNFTEntries{inner: slice}
}
func (s *TransferCotaNFTEntries) AsSlice() []byte {
	return s.inner
}

func TransferCotaNFTEntriesDefault() TransferCotaNFTEntries {
	return *TransferCotaNFTEntriesFromSliceUnchecked([]byte{60, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func TransferCotaNFTEntriesFromSlice(slice []byte, compatible bool) (*TransferCotaNFTEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TransferCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TransferCotaNFTEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 7 == 0 {
		return &TransferCotaNFTEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TransferCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "TransferCotaNFTEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TransferCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 7 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 7 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = ClaimCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimCotaNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTKeyVecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTValueVecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	return &TransferCotaNFTEntries{inner: slice}, nil
}

func (s *TransferCotaNFTEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *TransferCotaNFTEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *TransferCotaNFTEntries) Len() uint {
	return s.FieldCount()
}
func (s *TransferCotaNFTEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *TransferCotaNFTEntries) CountExtraFields() uint {
	return s.FieldCount() - 7
}

func (s *TransferCotaNFTEntries) HasExtraFields() bool {
	return 7 != s.FieldCount()
}

func (s *TransferCotaNFTEntries) ClaimKeys() *ClaimCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return ClaimCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTEntries) ClaimValues() *ClaimCotaNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return ClaimCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTEntries) WithdrawalKeys() *WithdrawalCotaNFTKeyVec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return WithdrawalCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTEntries) WithdrawalValues() *WithdrawalCotaNFTValueVec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return WithdrawalCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTEntries) Proof() *Bytes {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTEntries) WithdrawalProof() *Bytes {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTEntries) Action() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[28:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[32:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *TransferCotaNFTEntries) AsBuilder() TransferCotaNFTEntriesBuilder {
	ret := NewTransferCotaNFTEntriesBuilder().ClaimKeys(*s.ClaimKeys()).ClaimValues(*s.ClaimValues()).WithdrawalKeys(*s.WithdrawalKeys()).WithdrawalValues(*s.WithdrawalValues()).Proof(*s.Proof()).WithdrawalProof(*s.WithdrawalProof()).Action(*s.Action())
	return *ret
}

type ClaimUpdateCotaNFTEntriesBuilder struct {
	hold_keys        HoldCotaNFTKeyVec
	hold_values      HoldCotaNFTValueVec
	claim_keys       ClaimCotaNFTKeyVec
	claim_infos      ClaimCotaNFTInfoVec
	proof            Bytes
	withdrawal_proof Bytes
	action           Bytes
}

func (s *ClaimUpdateCotaNFTEntriesBuilder) Build() ClaimUpdateCotaNFTEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (7 + 1)
	offsets := make([]uint32, 0, 7)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.hold_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.hold_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claim_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claim_infos.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.hold_keys.AsSlice())
	b.Write(s.hold_values.AsSlice())
	b.Write(s.claim_keys.AsSlice())
	b.Write(s.claim_infos.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.withdrawal_proof.AsSlice())
	b.Write(s.action.AsSlice())
	return ClaimUpdateCotaNFTEntries{inner: b.Bytes()}
}

func (s *ClaimUpdateCotaNFTEntriesBuilder) HoldKeys(v HoldCotaNFTKeyVec) *ClaimUpdateCotaNFTEntriesBuilder {
	s.hold_keys = v
	return s
}

func (s *ClaimUpdateCotaNFTEntriesBuilder) HoldValues(v HoldCotaNFTValueVec) *ClaimUpdateCotaNFTEntriesBuilder {
	s.hold_values = v
	return s
}

func (s *ClaimUpdateCotaNFTEntriesBuilder) ClaimKeys(v ClaimCotaNFTKeyVec) *ClaimUpdateCotaNFTEntriesBuilder {
	s.claim_keys = v
	return s
}

func (s *ClaimUpdateCotaNFTEntriesBuilder) ClaimInfos(v ClaimCotaNFTInfoVec) *ClaimUpdateCotaNFTEntriesBuilder {
	s.claim_infos = v
	return s
}

func (s *ClaimUpdateCotaNFTEntriesBuilder) Proof(v Bytes) *ClaimUpdateCotaNFTEntriesBuilder {
	s.proof = v
	return s
}

func (s *ClaimUpdateCotaNFTEntriesBuilder) WithdrawalProof(v Bytes) *ClaimUpdateCotaNFTEntriesBuilder {
	s.withdrawal_proof = v
	return s
}

func (s *ClaimUpdateCotaNFTEntriesBuilder) Action(v Bytes) *ClaimUpdateCotaNFTEntriesBuilder {
	s.action = v
	return s
}

func NewClaimUpdateCotaNFTEntriesBuilder() *ClaimUpdateCotaNFTEntriesBuilder {
	return &ClaimUpdateCotaNFTEntriesBuilder{hold_keys: HoldCotaNFTKeyVecDefault(), hold_values: HoldCotaNFTValueVecDefault(), claim_keys: ClaimCotaNFTKeyVecDefault(), claim_infos: ClaimCotaNFTInfoVecDefault(), proof: BytesDefault(), withdrawal_proof: BytesDefault(), action: BytesDefault()}
}

type ClaimUpdateCotaNFTEntries struct {
	inner []byte
}

func ClaimUpdateCotaNFTEntriesFromSliceUnchecked(slice []byte) *ClaimUpdateCotaNFTEntries {
	return &ClaimUpdateCotaNFTEntries{inner: slice}
}
func (s *ClaimUpdateCotaNFTEntries) AsSlice() []byte {
	return s.inner
}

func ClaimUpdateCotaNFTEntriesDefault() ClaimUpdateCotaNFTEntries {
	return *ClaimUpdateCotaNFTEntriesFromSliceUnchecked([]byte{60, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ClaimUpdateCotaNFTEntriesFromSlice(slice []byte, compatible bool) (*ClaimUpdateCotaNFTEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimUpdateCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimUpdateCotaNFTEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 7 == 0 {
		return &ClaimUpdateCotaNFTEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimUpdateCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ClaimUpdateCotaNFTEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimUpdateCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 7 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 7 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = HoldCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HoldCotaNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimCotaNFTKeyVecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimCotaNFTInfoVecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	return &ClaimUpdateCotaNFTEntries{inner: slice}, nil
}

func (s *ClaimUpdateCotaNFTEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ClaimUpdateCotaNFTEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ClaimUpdateCotaNFTEntries) Len() uint {
	return s.FieldCount()
}
func (s *ClaimUpdateCotaNFTEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ClaimUpdateCotaNFTEntries) CountExtraFields() uint {
	return s.FieldCount() - 7
}

func (s *ClaimUpdateCotaNFTEntries) HasExtraFields() bool {
	return 7 != s.FieldCount()
}

func (s *ClaimUpdateCotaNFTEntries) HoldKeys() *HoldCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return HoldCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimUpdateCotaNFTEntries) HoldValues() *HoldCotaNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return HoldCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimUpdateCotaNFTEntries) ClaimKeys() *ClaimCotaNFTKeyVec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return ClaimCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimUpdateCotaNFTEntries) ClaimInfos() *ClaimCotaNFTInfoVec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return ClaimCotaNFTInfoVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimUpdateCotaNFTEntries) Proof() *Bytes {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimUpdateCotaNFTEntries) WithdrawalProof() *Bytes {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimUpdateCotaNFTEntries) Action() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[28:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[32:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ClaimUpdateCotaNFTEntries) AsBuilder() ClaimUpdateCotaNFTEntriesBuilder {
	ret := NewClaimUpdateCotaNFTEntriesBuilder().HoldKeys(*s.HoldKeys()).HoldValues(*s.HoldValues()).ClaimKeys(*s.ClaimKeys()).ClaimInfos(*s.ClaimInfos()).Proof(*s.Proof()).WithdrawalProof(*s.WithdrawalProof()).Action(*s.Action())
	return *ret
}

type TransferUpdateCotaNFTEntriesBuilder struct {
	claim_keys        ClaimCotaNFTKeyVec
	claim_infos       ClaimCotaNFTInfoVec
	withdrawal_keys   WithdrawalCotaNFTKeyVec
	withdrawal_values WithdrawalCotaNFTValueVec
	proof             Bytes
	withdrawal_proof  Bytes
	action            Bytes
}

func (s *TransferUpdateCotaNFTEntriesBuilder) Build() TransferUpdateCotaNFTEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (7 + 1)
	offsets := make([]uint32, 0, 7)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claim_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claim_infos.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.claim_keys.AsSlice())
	b.Write(s.claim_infos.AsSlice())
	b.Write(s.withdrawal_keys.AsSlice())
	b.Write(s.withdrawal_values.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.withdrawal_proof.AsSlice())
	b.Write(s.action.AsSlice())
	return TransferUpdateCotaNFTEntries{inner: b.Bytes()}
}

func (s *TransferUpdateCotaNFTEntriesBuilder) ClaimKeys(v ClaimCotaNFTKeyVec) *TransferUpdateCotaNFTEntriesBuilder {
	s.claim_keys = v
	return s
}

func (s *TransferUpdateCotaNFTEntriesBuilder) ClaimInfos(v ClaimCotaNFTInfoVec) *TransferUpdateCotaNFTEntriesBuilder {
	s.claim_infos = v
	return s
}

func (s *TransferUpdateCotaNFTEntriesBuilder) WithdrawalKeys(v WithdrawalCotaNFTKeyVec) *TransferUpdateCotaNFTEntriesBuilder {
	s.withdrawal_keys = v
	return s
}

func (s *TransferUpdateCotaNFTEntriesBuilder) WithdrawalValues(v WithdrawalCotaNFTValueVec) *TransferUpdateCotaNFTEntriesBuilder {
	s.withdrawal_values = v
	return s
}

func (s *TransferUpdateCotaNFTEntriesBuilder) Proof(v Bytes) *TransferUpdateCotaNFTEntriesBuilder {
	s.proof = v
	return s
}

func (s *TransferUpdateCotaNFTEntriesBuilder) WithdrawalProof(v Bytes) *TransferUpdateCotaNFTEntriesBuilder {
	s.withdrawal_proof = v
	return s
}

func (s *TransferUpdateCotaNFTEntriesBuilder) Action(v Bytes) *TransferUpdateCotaNFTEntriesBuilder {
	s.action = v
	return s
}

func NewTransferUpdateCotaNFTEntriesBuilder() *TransferUpdateCotaNFTEntriesBuilder {
	return &TransferUpdateCotaNFTEntriesBuilder{claim_keys: ClaimCotaNFTKeyVecDefault(), claim_infos: ClaimCotaNFTInfoVecDefault(), withdrawal_keys: WithdrawalCotaNFTKeyVecDefault(), withdrawal_values: WithdrawalCotaNFTValueVecDefault(), proof: BytesDefault(), withdrawal_proof: BytesDefault(), action: BytesDefault()}
}

type TransferUpdateCotaNFTEntries struct {
	inner []byte
}

func TransferUpdateCotaNFTEntriesFromSliceUnchecked(slice []byte) *TransferUpdateCotaNFTEntries {
	return &TransferUpdateCotaNFTEntries{inner: slice}
}
func (s *TransferUpdateCotaNFTEntries) AsSlice() []byte {
	return s.inner
}

func TransferUpdateCotaNFTEntriesDefault() TransferUpdateCotaNFTEntries {
	return *TransferUpdateCotaNFTEntriesFromSliceUnchecked([]byte{60, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func TransferUpdateCotaNFTEntriesFromSlice(slice []byte, compatible bool) (*TransferUpdateCotaNFTEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TransferUpdateCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TransferUpdateCotaNFTEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 7 == 0 {
		return &TransferUpdateCotaNFTEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TransferUpdateCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "TransferUpdateCotaNFTEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TransferUpdateCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 7 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 7 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = ClaimCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimCotaNFTInfoVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTKeyVecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTValueVecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	return &TransferUpdateCotaNFTEntries{inner: slice}, nil
}

func (s *TransferUpdateCotaNFTEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *TransferUpdateCotaNFTEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *TransferUpdateCotaNFTEntries) Len() uint {
	return s.FieldCount()
}
func (s *TransferUpdateCotaNFTEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *TransferUpdateCotaNFTEntries) CountExtraFields() uint {
	return s.FieldCount() - 7
}

func (s *TransferUpdateCotaNFTEntries) HasExtraFields() bool {
	return 7 != s.FieldCount()
}

func (s *TransferUpdateCotaNFTEntries) ClaimKeys() *ClaimCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return ClaimCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTEntries) ClaimInfos() *ClaimCotaNFTInfoVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return ClaimCotaNFTInfoVecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTEntries) WithdrawalKeys() *WithdrawalCotaNFTKeyVec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return WithdrawalCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTEntries) WithdrawalValues() *WithdrawalCotaNFTValueVec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return WithdrawalCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTEntries) Proof() *Bytes {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTEntries) WithdrawalProof() *Bytes {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTEntries) Action() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[28:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[32:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *TransferUpdateCotaNFTEntries) AsBuilder() TransferUpdateCotaNFTEntriesBuilder {
	ret := NewTransferUpdateCotaNFTEntriesBuilder().ClaimKeys(*s.ClaimKeys()).ClaimInfos(*s.ClaimInfos()).WithdrawalKeys(*s.WithdrawalKeys()).WithdrawalValues(*s.WithdrawalValues()).Proof(*s.Proof()).WithdrawalProof(*s.WithdrawalProof()).Action(*s.Action())
	return *ret
}

type UpdateCotaNFTEntriesBuilder struct {
	holdKeys      HoldCotaNFTKeyVec
	holdOldValues HoldCotaNFTValueVec
	holdNewValues HoldCotaNFTValueVec
	proof         Bytes
	action        Bytes
}

func (s *UpdateCotaNFTEntriesBuilder) Build() UpdateCotaNFTEntries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (5 + 1)
	offsets := make([]uint32, 0, 5)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.holdKeys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.holdOldValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.holdNewValues.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.holdKeys.AsSlice())
	b.Write(s.holdOldValues.AsSlice())
	b.Write(s.holdNewValues.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.action.AsSlice())
	return UpdateCotaNFTEntries{inner: b.Bytes()}
}

func (s *UpdateCotaNFTEntriesBuilder) HoldKeys(v HoldCotaNFTKeyVec) *UpdateCotaNFTEntriesBuilder {
	s.holdKeys = v
	return s
}

func (s *UpdateCotaNFTEntriesBuilder) HoldOldValues(v HoldCotaNFTValueVec) *UpdateCotaNFTEntriesBuilder {
	s.holdOldValues = v
	return s
}

func (s *UpdateCotaNFTEntriesBuilder) HoldNewValues(v HoldCotaNFTValueVec) *UpdateCotaNFTEntriesBuilder {
	s.holdNewValues = v
	return s
}

func (s *UpdateCotaNFTEntriesBuilder) Proof(v Bytes) *UpdateCotaNFTEntriesBuilder {
	s.proof = v
	return s
}

func (s *UpdateCotaNFTEntriesBuilder) Action(v Bytes) *UpdateCotaNFTEntriesBuilder {
	s.action = v
	return s
}

func NewUpdateCotaNFTEntriesBuilder() *UpdateCotaNFTEntriesBuilder {
	return &UpdateCotaNFTEntriesBuilder{holdKeys: HoldCotaNFTKeyVecDefault(), holdOldValues: HoldCotaNFTValueVecDefault(), holdNewValues: HoldCotaNFTValueVecDefault(), proof: BytesDefault(), action: BytesDefault()}
}

type UpdateCotaNFTEntries struct {
	inner []byte
}

func UpdateCotaNFTEntriesFromSliceUnchecked(slice []byte) *UpdateCotaNFTEntries {
	return &UpdateCotaNFTEntries{inner: slice}
}
func (s *UpdateCotaNFTEntries) AsSlice() []byte {
	return s.inner
}

func UpdateCotaNFTEntriesDefault() UpdateCotaNFTEntries {
	return *UpdateCotaNFTEntriesFromSliceUnchecked([]byte{44, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func UpdateCotaNFTEntriesFromSlice(slice []byte, compatible bool) (*UpdateCotaNFTEntries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "UpdateCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "UpdateCotaNFTEntries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 5 == 0 {
		return &UpdateCotaNFTEntries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "UpdateCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "UpdateCotaNFTEntries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "UpdateCotaNFTEntries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 5 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 5 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = HoldCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HoldCotaNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HoldCotaNFTValueVecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	return &UpdateCotaNFTEntries{inner: slice}, nil
}

func (s *UpdateCotaNFTEntries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *UpdateCotaNFTEntries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *UpdateCotaNFTEntries) Len() uint {
	return s.FieldCount()
}
func (s *UpdateCotaNFTEntries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *UpdateCotaNFTEntries) CountExtraFields() uint {
	return s.FieldCount() - 5
}

func (s *UpdateCotaNFTEntries) HasExtraFields() bool {
	return 5 != s.FieldCount()
}

func (s *UpdateCotaNFTEntries) HoldKeys() *HoldCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return HoldCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *UpdateCotaNFTEntries) HoldOldValues() *HoldCotaNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return HoldCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *UpdateCotaNFTEntries) HoldNewValues() *HoldCotaNFTValueVec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return HoldCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *UpdateCotaNFTEntries) Proof() *Bytes {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *UpdateCotaNFTEntries) Action() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[20:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[24:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *UpdateCotaNFTEntries) AsBuilder() UpdateCotaNFTEntriesBuilder {
	ret := NewUpdateCotaNFTEntriesBuilder().HoldKeys(*s.HoldKeys()).HoldOldValues(*s.HoldOldValues()).HoldNewValues(*s.HoldNewValues()).Proof(*s.Proof()).Action(*s.Action())
	return *ret
}

type WithdrawalCotaNFTKeyV1Builder struct {
	nft_id    CotaNFTId
	out_point OutPointSlice
}

func (s *WithdrawalCotaNFTKeyV1Builder) Build() WithdrawalCotaNFTKeyV1 {
	b := new(bytes.Buffer)
	b.Write(s.nft_id.AsSlice())
	b.Write(s.out_point.AsSlice())
	return WithdrawalCotaNFTKeyV1{inner: b.Bytes()}
}

func (s *WithdrawalCotaNFTKeyV1Builder) NftId(v CotaNFTId) *WithdrawalCotaNFTKeyV1Builder {
	s.nft_id = v
	return s
}

func (s *WithdrawalCotaNFTKeyV1Builder) OutPoint(v OutPointSlice) *WithdrawalCotaNFTKeyV1Builder {
	s.out_point = v
	return s
}

func NewWithdrawalCotaNFTKeyV1Builder() *WithdrawalCotaNFTKeyV1Builder {
	return &WithdrawalCotaNFTKeyV1Builder{nft_id: CotaNFTIdDefault(), out_point: OutPointSliceDefault()}
}

type WithdrawalCotaNFTKeyV1 struct {
	inner []byte
}

func WithdrawalCotaNFTKeyV1FromSliceUnchecked(slice []byte) *WithdrawalCotaNFTKeyV1 {
	return &WithdrawalCotaNFTKeyV1{inner: slice}
}
func (s *WithdrawalCotaNFTKeyV1) AsSlice() []byte {
	return s.inner
}

func WithdrawalCotaNFTKeyV1Default() WithdrawalCotaNFTKeyV1 {
	return *WithdrawalCotaNFTKeyV1FromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func WithdrawalCotaNFTKeyV1FromSlice(slice []byte, _compatible bool) (*WithdrawalCotaNFTKeyV1, error) {
	sliceLen := len(slice)
	if sliceLen != 50 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTKeyV1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(50)}, " ")
		return nil, errors.New(errMsg)
	}
	return &WithdrawalCotaNFTKeyV1{inner: slice}, nil
}

func (s *WithdrawalCotaNFTKeyV1) NftId() *CotaNFTId {
	ret := CotaNFTIdFromSliceUnchecked(s.inner[0:26])
	return ret
}

func (s *WithdrawalCotaNFTKeyV1) OutPoint() *OutPointSlice {
	ret := OutPointSliceFromSliceUnchecked(s.inner[26:50])
	return ret
}

func (s *WithdrawalCotaNFTKeyV1) AsBuilder() WithdrawalCotaNFTKeyV1Builder {
	ret := NewWithdrawalCotaNFTKeyV1Builder().NftId(*s.NftId()).OutPoint(*s.OutPoint())
	return *ret
}

type WithdrawalCotaNFTKeyV1VecBuilder struct {
	inner []WithdrawalCotaNFTKeyV1
}

func (s *WithdrawalCotaNFTKeyV1VecBuilder) Build() WithdrawalCotaNFTKeyV1Vec {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := WithdrawalCotaNFTKeyV1Vec{inner: b.Bytes()}

	return sb
}

func (s *WithdrawalCotaNFTKeyV1VecBuilder) Set(v []WithdrawalCotaNFTKeyV1) *WithdrawalCotaNFTKeyV1VecBuilder {
	s.inner = v
	return s
}
func (s *WithdrawalCotaNFTKeyV1VecBuilder) Push(v WithdrawalCotaNFTKeyV1) *WithdrawalCotaNFTKeyV1VecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *WithdrawalCotaNFTKeyV1VecBuilder) Extend(iter []WithdrawalCotaNFTKeyV1) *WithdrawalCotaNFTKeyV1VecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *WithdrawalCotaNFTKeyV1VecBuilder) Replace(index uint, v WithdrawalCotaNFTKeyV1) *WithdrawalCotaNFTKeyV1 {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewWithdrawalCotaNFTKeyV1VecBuilder() *WithdrawalCotaNFTKeyV1VecBuilder {
	return &WithdrawalCotaNFTKeyV1VecBuilder{[]WithdrawalCotaNFTKeyV1{}}
}

type WithdrawalCotaNFTKeyV1Vec struct {
	inner []byte
}

func WithdrawalCotaNFTKeyV1VecFromSliceUnchecked(slice []byte) *WithdrawalCotaNFTKeyV1Vec {
	return &WithdrawalCotaNFTKeyV1Vec{inner: slice}
}
func (s *WithdrawalCotaNFTKeyV1Vec) AsSlice() []byte {
	return s.inner
}

func WithdrawalCotaNFTKeyV1VecDefault() WithdrawalCotaNFTKeyV1Vec {
	return *WithdrawalCotaNFTKeyV1VecFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func WithdrawalCotaNFTKeyV1VecFromSlice(slice []byte, _compatible bool) (*WithdrawalCotaNFTKeyV1Vec, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTKeyV1Vec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTKeyV1Vec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &WithdrawalCotaNFTKeyV1Vec{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(50*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTKeyV1Vec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &WithdrawalCotaNFTKeyV1Vec{inner: slice}, nil
}

func (s *WithdrawalCotaNFTKeyV1Vec) TotalSize() uint {
	return uint(HeaderSizeUint) + 50*s.ItemCount()
}
func (s *WithdrawalCotaNFTKeyV1Vec) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *WithdrawalCotaNFTKeyV1Vec) Len() uint {
	return s.ItemCount()
}
func (s *WithdrawalCotaNFTKeyV1Vec) IsEmpty() bool {
	return s.Len() == 0
}

// if *WithdrawalCotaNFTKeyV1 is nil, index is out of bounds
func (s *WithdrawalCotaNFTKeyV1Vec) Get(index uint) *WithdrawalCotaNFTKeyV1 {
	var re *WithdrawalCotaNFTKeyV1
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 50*index
		end := start + 50
		re = WithdrawalCotaNFTKeyV1FromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *WithdrawalCotaNFTKeyV1Vec) AsBuilder() WithdrawalCotaNFTKeyV1VecBuilder {
	size := s.ItemCount()
	t := NewWithdrawalCotaNFTKeyV1VecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type WithdrawalCotaNFTValueV1Builder struct {
	nft_info CotaNFTInfo
	to_lock  Bytes
}

func (s *WithdrawalCotaNFTValueV1Builder) Build() WithdrawalCotaNFTValueV1 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.nft_info.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.to_lock.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.nft_info.AsSlice())
	b.Write(s.to_lock.AsSlice())
	return WithdrawalCotaNFTValueV1{inner: b.Bytes()}
}

func (s *WithdrawalCotaNFTValueV1Builder) NftInfo(v CotaNFTInfo) *WithdrawalCotaNFTValueV1Builder {
	s.nft_info = v
	return s
}

func (s *WithdrawalCotaNFTValueV1Builder) ToLock(v Bytes) *WithdrawalCotaNFTValueV1Builder {
	s.to_lock = v
	return s
}

func NewWithdrawalCotaNFTValueV1Builder() *WithdrawalCotaNFTValueV1Builder {
	return &WithdrawalCotaNFTValueV1Builder{nft_info: CotaNFTInfoDefault(), to_lock: BytesDefault()}
}

type WithdrawalCotaNFTValueV1 struct {
	inner []byte
}

func WithdrawalCotaNFTValueV1FromSliceUnchecked(slice []byte) *WithdrawalCotaNFTValueV1 {
	return &WithdrawalCotaNFTValueV1{inner: slice}
}
func (s *WithdrawalCotaNFTValueV1) AsSlice() []byte {
	return s.inner
}

func WithdrawalCotaNFTValueV1Default() WithdrawalCotaNFTValueV1 {
	return *WithdrawalCotaNFTValueV1FromSliceUnchecked([]byte{38, 0, 0, 0, 12, 0, 0, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func WithdrawalCotaNFTValueV1FromSlice(slice []byte, compatible bool) (*WithdrawalCotaNFTValueV1, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTValueV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTValueV1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
		return &WithdrawalCotaNFTValueV1{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTValueV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "WithdrawalCotaNFTValueV1", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTValueV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = CotaNFTInfoFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &WithdrawalCotaNFTValueV1{inner: slice}, nil
}

func (s *WithdrawalCotaNFTValueV1) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *WithdrawalCotaNFTValueV1) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *WithdrawalCotaNFTValueV1) Len() uint {
	return s.FieldCount()
}
func (s *WithdrawalCotaNFTValueV1) IsEmpty() bool {
	return s.Len() == 0
}
func (s *WithdrawalCotaNFTValueV1) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *WithdrawalCotaNFTValueV1) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *WithdrawalCotaNFTValueV1) NftInfo() *CotaNFTInfo {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return CotaNFTInfoFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawalCotaNFTValueV1) ToLock() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *WithdrawalCotaNFTValueV1) AsBuilder() WithdrawalCotaNFTValueV1Builder {
	ret := NewWithdrawalCotaNFTValueV1Builder().NftInfo(*s.NftInfo()).ToLock(*s.ToLock())
	return *ret
}

type WithdrawalCotaNFTValueV1VecBuilder struct {
	inner []WithdrawalCotaNFTValueV1
}

func (s *WithdrawalCotaNFTValueV1VecBuilder) Build() WithdrawalCotaNFTValueV1Vec {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return WithdrawalCotaNFTValueV1Vec{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return WithdrawalCotaNFTValueV1Vec{inner: b.Bytes()}
}

func (s *WithdrawalCotaNFTValueV1VecBuilder) Set(v []WithdrawalCotaNFTValueV1) *WithdrawalCotaNFTValueV1VecBuilder {
	s.inner = v
	return s
}
func (s *WithdrawalCotaNFTValueV1VecBuilder) Push(v WithdrawalCotaNFTValueV1) *WithdrawalCotaNFTValueV1VecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *WithdrawalCotaNFTValueV1VecBuilder) Extend(iter []WithdrawalCotaNFTValueV1) *WithdrawalCotaNFTValueV1VecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *WithdrawalCotaNFTValueV1VecBuilder) Replace(index uint, v WithdrawalCotaNFTValueV1) *WithdrawalCotaNFTValueV1 {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewWithdrawalCotaNFTValueV1VecBuilder() *WithdrawalCotaNFTValueV1VecBuilder {
	return &WithdrawalCotaNFTValueV1VecBuilder{[]WithdrawalCotaNFTValueV1{}}
}

type WithdrawalCotaNFTValueV1Vec struct {
	inner []byte
}

func WithdrawalCotaNFTValueV1VecFromSliceUnchecked(slice []byte) *WithdrawalCotaNFTValueV1Vec {
	return &WithdrawalCotaNFTValueV1Vec{inner: slice}
}
func (s *WithdrawalCotaNFTValueV1Vec) AsSlice() []byte {
	return s.inner
}

func WithdrawalCotaNFTValueV1VecDefault() WithdrawalCotaNFTValueV1Vec {
	return *WithdrawalCotaNFTValueV1VecFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func WithdrawalCotaNFTValueV1VecFromSlice(slice []byte, compatible bool) (*WithdrawalCotaNFTValueV1Vec, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTValueV1Vec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTValueV1Vec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &WithdrawalCotaNFTValueV1Vec{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTValueV1Vec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "WithdrawalCotaNFTValueV1Vec", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTValueV1Vec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "WithdrawalCotaNFTValueV1Vec"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := WithdrawalCotaNFTValueV1FromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &WithdrawalCotaNFTValueV1Vec{inner: slice}, nil
}

func (s *WithdrawalCotaNFTValueV1Vec) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *WithdrawalCotaNFTValueV1Vec) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *WithdrawalCotaNFTValueV1Vec) Len() uint {
	return s.ItemCount()
}
func (s *WithdrawalCotaNFTValueV1Vec) IsEmpty() bool {
	return s.Len() == 0
}

// if *WithdrawalCotaNFTValueV1 is nil, index is out of bounds
func (s *WithdrawalCotaNFTValueV1Vec) Get(index uint) *WithdrawalCotaNFTValueV1 {
	var b *WithdrawalCotaNFTValueV1
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = WithdrawalCotaNFTValueV1FromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = WithdrawalCotaNFTValueV1FromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *WithdrawalCotaNFTValueV1Vec) AsBuilder() WithdrawalCotaNFTValueV1VecBuilder {
	size := s.ItemCount()
	t := NewWithdrawalCotaNFTValueV1VecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type MintCotaNFTV1EntriesBuilder struct {
	define_keys       DefineCotaNFTKeyVec
	define_old_values DefineCotaNFTValueVec
	define_new_values DefineCotaNFTValueVec
	withdrawal_keys   WithdrawalCotaNFTKeyV1Vec
	withdrawal_values WithdrawalCotaNFTValueV1Vec
	proof             Bytes
	action            Bytes
}

func (s *MintCotaNFTV1EntriesBuilder) Build() MintCotaNFTV1Entries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (7 + 1)
	offsets := make([]uint32, 0, 7)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.define_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.define_old_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.define_new_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.define_keys.AsSlice())
	b.Write(s.define_old_values.AsSlice())
	b.Write(s.define_new_values.AsSlice())
	b.Write(s.withdrawal_keys.AsSlice())
	b.Write(s.withdrawal_values.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.action.AsSlice())
	return MintCotaNFTV1Entries{inner: b.Bytes()}
}

func (s *MintCotaNFTV1EntriesBuilder) DefineKeys(v DefineCotaNFTKeyVec) *MintCotaNFTV1EntriesBuilder {
	s.define_keys = v
	return s
}

func (s *MintCotaNFTV1EntriesBuilder) DefineOldValues(v DefineCotaNFTValueVec) *MintCotaNFTV1EntriesBuilder {
	s.define_old_values = v
	return s
}

func (s *MintCotaNFTV1EntriesBuilder) DefineNewValues(v DefineCotaNFTValueVec) *MintCotaNFTV1EntriesBuilder {
	s.define_new_values = v
	return s
}

func (s *MintCotaNFTV1EntriesBuilder) WithdrawalKeys(v WithdrawalCotaNFTKeyV1Vec) *MintCotaNFTV1EntriesBuilder {
	s.withdrawal_keys = v
	return s
}

func (s *MintCotaNFTV1EntriesBuilder) WithdrawalValues(v WithdrawalCotaNFTValueV1Vec) *MintCotaNFTV1EntriesBuilder {
	s.withdrawal_values = v
	return s
}

func (s *MintCotaNFTV1EntriesBuilder) Proof(v Bytes) *MintCotaNFTV1EntriesBuilder {
	s.proof = v
	return s
}

func (s *MintCotaNFTV1EntriesBuilder) Action(v Bytes) *MintCotaNFTV1EntriesBuilder {
	s.action = v
	return s
}

func NewMintCotaNFTV1EntriesBuilder() *MintCotaNFTV1EntriesBuilder {
	return &MintCotaNFTV1EntriesBuilder{define_keys: DefineCotaNFTKeyVecDefault(), define_old_values: DefineCotaNFTValueVecDefault(), define_new_values: DefineCotaNFTValueVecDefault(), withdrawal_keys: WithdrawalCotaNFTKeyV1VecDefault(), withdrawal_values: WithdrawalCotaNFTValueV1VecDefault(), proof: BytesDefault(), action: BytesDefault()}
}

type MintCotaNFTV1Entries struct {
	inner []byte
}

func MintCotaNFTV1EntriesFromSliceUnchecked(slice []byte) *MintCotaNFTV1Entries {
	return &MintCotaNFTV1Entries{inner: slice}
}
func (s *MintCotaNFTV1Entries) AsSlice() []byte {
	return s.inner
}

func MintCotaNFTV1EntriesDefault() MintCotaNFTV1Entries {
	return *MintCotaNFTV1EntriesFromSliceUnchecked([]byte{60, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func MintCotaNFTV1EntriesFromSlice(slice []byte, compatible bool) (*MintCotaNFTV1Entries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "MintCotaNFTV1Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "MintCotaNFTV1Entries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 7 == 0 {
		return &MintCotaNFTV1Entries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "MintCotaNFTV1Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "MintCotaNFTV1Entries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "MintCotaNFTV1Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 7 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 7 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = DefineCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = DefineCotaNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = DefineCotaNFTValueVecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTKeyV1VecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTValueV1VecFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	return &MintCotaNFTV1Entries{inner: slice}, nil
}

func (s *MintCotaNFTV1Entries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *MintCotaNFTV1Entries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *MintCotaNFTV1Entries) Len() uint {
	return s.FieldCount()
}
func (s *MintCotaNFTV1Entries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *MintCotaNFTV1Entries) CountExtraFields() uint {
	return s.FieldCount() - 7
}

func (s *MintCotaNFTV1Entries) HasExtraFields() bool {
	return 7 != s.FieldCount()
}

func (s *MintCotaNFTV1Entries) DefineKeys() *DefineCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return DefineCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCotaNFTV1Entries) DefineOldValues() *DefineCotaNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return DefineCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCotaNFTV1Entries) DefineNewValues() *DefineCotaNFTValueVec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return DefineCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCotaNFTV1Entries) WithdrawalKeys() *WithdrawalCotaNFTKeyV1Vec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return WithdrawalCotaNFTKeyV1VecFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCotaNFTV1Entries) WithdrawalValues() *WithdrawalCotaNFTValueV1Vec {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return WithdrawalCotaNFTValueV1VecFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCotaNFTV1Entries) Proof() *Bytes {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *MintCotaNFTV1Entries) Action() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[28:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[32:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *MintCotaNFTV1Entries) AsBuilder() MintCotaNFTV1EntriesBuilder {
	ret := NewMintCotaNFTV1EntriesBuilder().DefineKeys(*s.DefineKeys()).DefineOldValues(*s.DefineOldValues()).DefineNewValues(*s.DefineNewValues()).WithdrawalKeys(*s.WithdrawalKeys()).WithdrawalValues(*s.WithdrawalValues()).Proof(*s.Proof()).Action(*s.Action())
	return *ret
}

type WithdrawalCotaNFTV1EntriesBuilder struct {
	hold_keys         HoldCotaNFTKeyVec
	hold_values       HoldCotaNFTValueVec
	withdrawal_keys   WithdrawalCotaNFTKeyV1Vec
	withdrawal_values WithdrawalCotaNFTValueV1Vec
	proof             Bytes
	action            Bytes
}

func (s *WithdrawalCotaNFTV1EntriesBuilder) Build() WithdrawalCotaNFTV1Entries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (6 + 1)
	offsets := make([]uint32, 0, 6)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.hold_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.hold_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.hold_keys.AsSlice())
	b.Write(s.hold_values.AsSlice())
	b.Write(s.withdrawal_keys.AsSlice())
	b.Write(s.withdrawal_values.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.action.AsSlice())
	return WithdrawalCotaNFTV1Entries{inner: b.Bytes()}
}

func (s *WithdrawalCotaNFTV1EntriesBuilder) HoldKeys(v HoldCotaNFTKeyVec) *WithdrawalCotaNFTV1EntriesBuilder {
	s.hold_keys = v
	return s
}

func (s *WithdrawalCotaNFTV1EntriesBuilder) HoldValues(v HoldCotaNFTValueVec) *WithdrawalCotaNFTV1EntriesBuilder {
	s.hold_values = v
	return s
}

func (s *WithdrawalCotaNFTV1EntriesBuilder) WithdrawalKeys(v WithdrawalCotaNFTKeyV1Vec) *WithdrawalCotaNFTV1EntriesBuilder {
	s.withdrawal_keys = v
	return s
}

func (s *WithdrawalCotaNFTV1EntriesBuilder) WithdrawalValues(v WithdrawalCotaNFTValueV1Vec) *WithdrawalCotaNFTV1EntriesBuilder {
	s.withdrawal_values = v
	return s
}

func (s *WithdrawalCotaNFTV1EntriesBuilder) Proof(v Bytes) *WithdrawalCotaNFTV1EntriesBuilder {
	s.proof = v
	return s
}

func (s *WithdrawalCotaNFTV1EntriesBuilder) Action(v Bytes) *WithdrawalCotaNFTV1EntriesBuilder {
	s.action = v
	return s
}

func NewWithdrawalCotaNFTV1EntriesBuilder() *WithdrawalCotaNFTV1EntriesBuilder {
	return &WithdrawalCotaNFTV1EntriesBuilder{hold_keys: HoldCotaNFTKeyVecDefault(), hold_values: HoldCotaNFTValueVecDefault(), withdrawal_keys: WithdrawalCotaNFTKeyV1VecDefault(), withdrawal_values: WithdrawalCotaNFTValueV1VecDefault(), proof: BytesDefault(), action: BytesDefault()}
}

type WithdrawalCotaNFTV1Entries struct {
	inner []byte
}

func WithdrawalCotaNFTV1EntriesFromSliceUnchecked(slice []byte) *WithdrawalCotaNFTV1Entries {
	return &WithdrawalCotaNFTV1Entries{inner: slice}
}
func (s *WithdrawalCotaNFTV1Entries) AsSlice() []byte {
	return s.inner
}

func WithdrawalCotaNFTV1EntriesDefault() WithdrawalCotaNFTV1Entries {
	return *WithdrawalCotaNFTV1EntriesFromSliceUnchecked([]byte{52, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func WithdrawalCotaNFTV1EntriesFromSlice(slice []byte, compatible bool) (*WithdrawalCotaNFTV1Entries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTV1Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTV1Entries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 6 == 0 {
		return &WithdrawalCotaNFTV1Entries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "WithdrawalCotaNFTV1Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "WithdrawalCotaNFTV1Entries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "WithdrawalCotaNFTV1Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 6 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 6 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = HoldCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HoldCotaNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTKeyV1VecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTValueV1VecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	return &WithdrawalCotaNFTV1Entries{inner: slice}, nil
}

func (s *WithdrawalCotaNFTV1Entries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *WithdrawalCotaNFTV1Entries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *WithdrawalCotaNFTV1Entries) Len() uint {
	return s.FieldCount()
}
func (s *WithdrawalCotaNFTV1Entries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *WithdrawalCotaNFTV1Entries) CountExtraFields() uint {
	return s.FieldCount() - 6
}

func (s *WithdrawalCotaNFTV1Entries) HasExtraFields() bool {
	return 6 != s.FieldCount()
}

func (s *WithdrawalCotaNFTV1Entries) HoldKeys() *HoldCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return HoldCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawalCotaNFTV1Entries) HoldValues() *HoldCotaNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return HoldCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawalCotaNFTV1Entries) WithdrawalKeys() *WithdrawalCotaNFTKeyV1Vec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return WithdrawalCotaNFTKeyV1VecFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawalCotaNFTV1Entries) WithdrawalValues() *WithdrawalCotaNFTValueV1Vec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return WithdrawalCotaNFTValueV1VecFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawalCotaNFTV1Entries) Proof() *Bytes {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *WithdrawalCotaNFTV1Entries) Action() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[24:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[28:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *WithdrawalCotaNFTV1Entries) AsBuilder() WithdrawalCotaNFTV1EntriesBuilder {
	ret := NewWithdrawalCotaNFTV1EntriesBuilder().HoldKeys(*s.HoldKeys()).HoldValues(*s.HoldValues()).WithdrawalKeys(*s.WithdrawalKeys()).WithdrawalValues(*s.WithdrawalValues()).Proof(*s.Proof()).Action(*s.Action())
	return *ret
}

type TransferCotaNFTV1EntriesBuilder struct {
	claim_keys        ClaimCotaNFTKeyVec
	claim_values      ClaimCotaNFTValueVec
	withdrawal_keys   WithdrawalCotaNFTKeyV1Vec
	withdrawal_values WithdrawalCotaNFTValueV1Vec
	proof             Bytes
	withdrawal_proof  Bytes
	action            Bytes
}

func (s *TransferCotaNFTV1EntriesBuilder) Build() TransferCotaNFTV1Entries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (7 + 1)
	offsets := make([]uint32, 0, 7)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claim_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claim_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.claim_keys.AsSlice())
	b.Write(s.claim_values.AsSlice())
	b.Write(s.withdrawal_keys.AsSlice())
	b.Write(s.withdrawal_values.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.withdrawal_proof.AsSlice())
	b.Write(s.action.AsSlice())
	return TransferCotaNFTV1Entries{inner: b.Bytes()}
}

func (s *TransferCotaNFTV1EntriesBuilder) ClaimKeys(v ClaimCotaNFTKeyVec) *TransferCotaNFTV1EntriesBuilder {
	s.claim_keys = v
	return s
}

func (s *TransferCotaNFTV1EntriesBuilder) ClaimValues(v ClaimCotaNFTValueVec) *TransferCotaNFTV1EntriesBuilder {
	s.claim_values = v
	return s
}

func (s *TransferCotaNFTV1EntriesBuilder) WithdrawalKeys(v WithdrawalCotaNFTKeyV1Vec) *TransferCotaNFTV1EntriesBuilder {
	s.withdrawal_keys = v
	return s
}

func (s *TransferCotaNFTV1EntriesBuilder) WithdrawalValues(v WithdrawalCotaNFTValueV1Vec) *TransferCotaNFTV1EntriesBuilder {
	s.withdrawal_values = v
	return s
}

func (s *TransferCotaNFTV1EntriesBuilder) Proof(v Bytes) *TransferCotaNFTV1EntriesBuilder {
	s.proof = v
	return s
}

func (s *TransferCotaNFTV1EntriesBuilder) WithdrawalProof(v Bytes) *TransferCotaNFTV1EntriesBuilder {
	s.withdrawal_proof = v
	return s
}

func (s *TransferCotaNFTV1EntriesBuilder) Action(v Bytes) *TransferCotaNFTV1EntriesBuilder {
	s.action = v
	return s
}

func NewTransferCotaNFTV1EntriesBuilder() *TransferCotaNFTV1EntriesBuilder {
	return &TransferCotaNFTV1EntriesBuilder{claim_keys: ClaimCotaNFTKeyVecDefault(), claim_values: ClaimCotaNFTValueVecDefault(), withdrawal_keys: WithdrawalCotaNFTKeyV1VecDefault(), withdrawal_values: WithdrawalCotaNFTValueV1VecDefault(), proof: BytesDefault(), withdrawal_proof: BytesDefault(), action: BytesDefault()}
}

type TransferCotaNFTV1Entries struct {
	inner []byte
}

func TransferCotaNFTV1EntriesFromSliceUnchecked(slice []byte) *TransferCotaNFTV1Entries {
	return &TransferCotaNFTV1Entries{inner: slice}
}
func (s *TransferCotaNFTV1Entries) AsSlice() []byte {
	return s.inner
}

func TransferCotaNFTV1EntriesDefault() TransferCotaNFTV1Entries {
	return *TransferCotaNFTV1EntriesFromSliceUnchecked([]byte{60, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func TransferCotaNFTV1EntriesFromSlice(slice []byte, compatible bool) (*TransferCotaNFTV1Entries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TransferCotaNFTV1Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TransferCotaNFTV1Entries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 7 == 0 {
		return &TransferCotaNFTV1Entries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TransferCotaNFTV1Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "TransferCotaNFTV1Entries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TransferCotaNFTV1Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 7 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 7 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = ClaimCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimCotaNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTKeyV1VecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTValueV1VecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	return &TransferCotaNFTV1Entries{inner: slice}, nil
}

func (s *TransferCotaNFTV1Entries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *TransferCotaNFTV1Entries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *TransferCotaNFTV1Entries) Len() uint {
	return s.FieldCount()
}
func (s *TransferCotaNFTV1Entries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *TransferCotaNFTV1Entries) CountExtraFields() uint {
	return s.FieldCount() - 7
}

func (s *TransferCotaNFTV1Entries) HasExtraFields() bool {
	return 7 != s.FieldCount()
}

func (s *TransferCotaNFTV1Entries) ClaimKeys() *ClaimCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return ClaimCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTV1Entries) ClaimValues() *ClaimCotaNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return ClaimCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTV1Entries) WithdrawalKeys() *WithdrawalCotaNFTKeyV1Vec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return WithdrawalCotaNFTKeyV1VecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTV1Entries) WithdrawalValues() *WithdrawalCotaNFTValueV1Vec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return WithdrawalCotaNFTValueV1VecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTV1Entries) Proof() *Bytes {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTV1Entries) WithdrawalProof() *Bytes {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTV1Entries) Action() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[28:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[32:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *TransferCotaNFTV1Entries) AsBuilder() TransferCotaNFTV1EntriesBuilder {
	ret := NewTransferCotaNFTV1EntriesBuilder().ClaimKeys(*s.ClaimKeys()).ClaimValues(*s.ClaimValues()).WithdrawalKeys(*s.WithdrawalKeys()).WithdrawalValues(*s.WithdrawalValues()).Proof(*s.Proof()).WithdrawalProof(*s.WithdrawalProof()).Action(*s.Action())
	return *ret
}

type TransferUpdateCotaNFTV1EntriesBuilder struct {
	claim_keys        ClaimCotaNFTKeyVec
	claim_infos       ClaimCotaNFTInfoVec
	withdrawal_keys   WithdrawalCotaNFTKeyV1Vec
	withdrawal_values WithdrawalCotaNFTValueV1Vec
	proof             Bytes
	withdrawal_proof  Bytes
	action            Bytes
}

func (s *TransferUpdateCotaNFTV1EntriesBuilder) Build() TransferUpdateCotaNFTV1Entries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (7 + 1)
	offsets := make([]uint32, 0, 7)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claim_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claim_infos.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.claim_keys.AsSlice())
	b.Write(s.claim_infos.AsSlice())
	b.Write(s.withdrawal_keys.AsSlice())
	b.Write(s.withdrawal_values.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.withdrawal_proof.AsSlice())
	b.Write(s.action.AsSlice())
	return TransferUpdateCotaNFTV1Entries{inner: b.Bytes()}
}

func (s *TransferUpdateCotaNFTV1EntriesBuilder) ClaimKeys(v ClaimCotaNFTKeyVec) *TransferUpdateCotaNFTV1EntriesBuilder {
	s.claim_keys = v
	return s
}

func (s *TransferUpdateCotaNFTV1EntriesBuilder) ClaimInfos(v ClaimCotaNFTInfoVec) *TransferUpdateCotaNFTV1EntriesBuilder {
	s.claim_infos = v
	return s
}

func (s *TransferUpdateCotaNFTV1EntriesBuilder) WithdrawalKeys(v WithdrawalCotaNFTKeyV1Vec) *TransferUpdateCotaNFTV1EntriesBuilder {
	s.withdrawal_keys = v
	return s
}

func (s *TransferUpdateCotaNFTV1EntriesBuilder) WithdrawalValues(v WithdrawalCotaNFTValueV1Vec) *TransferUpdateCotaNFTV1EntriesBuilder {
	s.withdrawal_values = v
	return s
}

func (s *TransferUpdateCotaNFTV1EntriesBuilder) Proof(v Bytes) *TransferUpdateCotaNFTV1EntriesBuilder {
	s.proof = v
	return s
}

func (s *TransferUpdateCotaNFTV1EntriesBuilder) WithdrawalProof(v Bytes) *TransferUpdateCotaNFTV1EntriesBuilder {
	s.withdrawal_proof = v
	return s
}

func (s *TransferUpdateCotaNFTV1EntriesBuilder) Action(v Bytes) *TransferUpdateCotaNFTV1EntriesBuilder {
	s.action = v
	return s
}

func NewTransferUpdateCotaNFTV1EntriesBuilder() *TransferUpdateCotaNFTV1EntriesBuilder {
	return &TransferUpdateCotaNFTV1EntriesBuilder{claim_keys: ClaimCotaNFTKeyVecDefault(), claim_infos: ClaimCotaNFTInfoVecDefault(), withdrawal_keys: WithdrawalCotaNFTKeyV1VecDefault(), withdrawal_values: WithdrawalCotaNFTValueV1VecDefault(), proof: BytesDefault(), withdrawal_proof: BytesDefault(), action: BytesDefault()}
}

type TransferUpdateCotaNFTV1Entries struct {
	inner []byte
}

func TransferUpdateCotaNFTV1EntriesFromSliceUnchecked(slice []byte) *TransferUpdateCotaNFTV1Entries {
	return &TransferUpdateCotaNFTV1Entries{inner: slice}
}
func (s *TransferUpdateCotaNFTV1Entries) AsSlice() []byte {
	return s.inner
}

func TransferUpdateCotaNFTV1EntriesDefault() TransferUpdateCotaNFTV1Entries {
	return *TransferUpdateCotaNFTV1EntriesFromSliceUnchecked([]byte{60, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func TransferUpdateCotaNFTV1EntriesFromSlice(slice []byte, compatible bool) (*TransferUpdateCotaNFTV1Entries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TransferUpdateCotaNFTV1Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TransferUpdateCotaNFTV1Entries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 7 == 0 {
		return &TransferUpdateCotaNFTV1Entries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TransferUpdateCotaNFTV1Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "TransferUpdateCotaNFTV1Entries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TransferUpdateCotaNFTV1Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 7 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 7 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = ClaimCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimCotaNFTInfoVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTKeyV1VecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTValueV1VecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	return &TransferUpdateCotaNFTV1Entries{inner: slice}, nil
}

func (s *TransferUpdateCotaNFTV1Entries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *TransferUpdateCotaNFTV1Entries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *TransferUpdateCotaNFTV1Entries) Len() uint {
	return s.FieldCount()
}
func (s *TransferUpdateCotaNFTV1Entries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *TransferUpdateCotaNFTV1Entries) CountExtraFields() uint {
	return s.FieldCount() - 7
}

func (s *TransferUpdateCotaNFTV1Entries) HasExtraFields() bool {
	return 7 != s.FieldCount()
}

func (s *TransferUpdateCotaNFTV1Entries) ClaimKeys() *ClaimCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return ClaimCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTV1Entries) ClaimInfos() *ClaimCotaNFTInfoVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return ClaimCotaNFTInfoVecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTV1Entries) WithdrawalKeys() *WithdrawalCotaNFTKeyV1Vec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return WithdrawalCotaNFTKeyV1VecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTV1Entries) WithdrawalValues() *WithdrawalCotaNFTValueV1Vec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return WithdrawalCotaNFTValueV1VecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTV1Entries) Proof() *Bytes {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTV1Entries) WithdrawalProof() *Bytes {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTV1Entries) Action() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[28:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[32:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *TransferUpdateCotaNFTV1Entries) AsBuilder() TransferUpdateCotaNFTV1EntriesBuilder {
	ret := NewTransferUpdateCotaNFTV1EntriesBuilder().ClaimKeys(*s.ClaimKeys()).ClaimInfos(*s.ClaimInfos()).WithdrawalKeys(*s.WithdrawalKeys()).WithdrawalValues(*s.WithdrawalValues()).Proof(*s.Proof()).WithdrawalProof(*s.WithdrawalProof()).Action(*s.Action())
	return *ret
}

type ClaimCotaNFTV2EntriesBuilder struct {
	hold_keys        HoldCotaNFTKeyVec
	hold_values      HoldCotaNFTValueVec
	claim_keys       ClaimCotaNFTKeyVec
	claim_values     ClaimCotaNFTValueVec
	proof            Bytes
	action           Bytes
	leaf_keys        Byte32Vec
	leaf_values      Byte32Vec
	withdrawal_proof Bytes
	raw_tx           Bytes
	tx_proof         TransactionProof
}

func (s *ClaimCotaNFTV2EntriesBuilder) Build() ClaimCotaNFTV2Entries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (11 + 1)
	offsets := make([]uint32, 0, 11)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.hold_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.hold_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claim_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claim_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.leaf_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.leaf_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.raw_tx.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.tx_proof.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.hold_keys.AsSlice())
	b.Write(s.hold_values.AsSlice())
	b.Write(s.claim_keys.AsSlice())
	b.Write(s.claim_values.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.action.AsSlice())
	b.Write(s.leaf_keys.AsSlice())
	b.Write(s.leaf_values.AsSlice())
	b.Write(s.withdrawal_proof.AsSlice())
	b.Write(s.raw_tx.AsSlice())
	b.Write(s.tx_proof.AsSlice())
	return ClaimCotaNFTV2Entries{inner: b.Bytes()}
}

func (s *ClaimCotaNFTV2EntriesBuilder) HoldKeys(v HoldCotaNFTKeyVec) *ClaimCotaNFTV2EntriesBuilder {
	s.hold_keys = v
	return s
}

func (s *ClaimCotaNFTV2EntriesBuilder) HoldValues(v HoldCotaNFTValueVec) *ClaimCotaNFTV2EntriesBuilder {
	s.hold_values = v
	return s
}

func (s *ClaimCotaNFTV2EntriesBuilder) ClaimKeys(v ClaimCotaNFTKeyVec) *ClaimCotaNFTV2EntriesBuilder {
	s.claim_keys = v
	return s
}

func (s *ClaimCotaNFTV2EntriesBuilder) ClaimValues(v ClaimCotaNFTValueVec) *ClaimCotaNFTV2EntriesBuilder {
	s.claim_values = v
	return s
}

func (s *ClaimCotaNFTV2EntriesBuilder) Proof(v Bytes) *ClaimCotaNFTV2EntriesBuilder {
	s.proof = v
	return s
}

func (s *ClaimCotaNFTV2EntriesBuilder) Action(v Bytes) *ClaimCotaNFTV2EntriesBuilder {
	s.action = v
	return s
}

func (s *ClaimCotaNFTV2EntriesBuilder) LeafKeys(v Byte32Vec) *ClaimCotaNFTV2EntriesBuilder {
	s.leaf_keys = v
	return s
}

func (s *ClaimCotaNFTV2EntriesBuilder) LeafValues(v Byte32Vec) *ClaimCotaNFTV2EntriesBuilder {
	s.leaf_values = v
	return s
}

func (s *ClaimCotaNFTV2EntriesBuilder) WithdrawalProof(v Bytes) *ClaimCotaNFTV2EntriesBuilder {
	s.withdrawal_proof = v
	return s
}

func (s *ClaimCotaNFTV2EntriesBuilder) RawTx(v Bytes) *ClaimCotaNFTV2EntriesBuilder {
	s.raw_tx = v
	return s
}

func (s *ClaimCotaNFTV2EntriesBuilder) TxProof(v TransactionProof) *ClaimCotaNFTV2EntriesBuilder {
	s.tx_proof = v
	return s
}

func NewClaimCotaNFTV2EntriesBuilder() *ClaimCotaNFTV2EntriesBuilder {
	return &ClaimCotaNFTV2EntriesBuilder{hold_keys: HoldCotaNFTKeyVecDefault(), hold_values: HoldCotaNFTValueVecDefault(), claim_keys: ClaimCotaNFTKeyVecDefault(), claim_values: ClaimCotaNFTValueVecDefault(), proof: BytesDefault(), action: BytesDefault(), leaf_keys: Byte32VecDefault(), leaf_values: Byte32VecDefault(), withdrawal_proof: BytesDefault(), raw_tx: BytesDefault(), tx_proof: TransactionProofDefault()}
}

type ClaimCotaNFTV2Entries struct {
	inner []byte
}

func ClaimCotaNFTV2EntriesFromSliceUnchecked(slice []byte) *ClaimCotaNFTV2Entries {
	return &ClaimCotaNFTV2Entries{inner: slice}
}
func (s *ClaimCotaNFTV2Entries) AsSlice() []byte {
	return s.inner
}

func ClaimCotaNFTV2EntriesDefault() ClaimCotaNFTV2Entries {
	return *ClaimCotaNFTV2EntriesFromSliceUnchecked([]byte{152, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 60, 0, 0, 0, 64, 0, 0, 0, 68, 0, 0, 0, 72, 0, 0, 0, 76, 0, 0, 0, 80, 0, 0, 0, 84, 0, 0, 0, 88, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ClaimCotaNFTV2EntriesFromSlice(slice []byte, compatible bool) (*ClaimCotaNFTV2Entries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimCotaNFTV2Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimCotaNFTV2Entries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 11 == 0 {
		return &ClaimCotaNFTV2Entries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimCotaNFTV2Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ClaimCotaNFTV2Entries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimCotaNFTV2Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 11 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 11 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = HoldCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HoldCotaNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimCotaNFTKeyVecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimCotaNFTValueVecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Byte32VecFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Byte32VecFromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[8]:offsets[9]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[9]:offsets[10]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TransactionProofFromSlice(slice[offsets[10]:offsets[11]], compatible)
	if err != nil {
		return nil, err
	}

	return &ClaimCotaNFTV2Entries{inner: slice}, nil
}

func (s *ClaimCotaNFTV2Entries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ClaimCotaNFTV2Entries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ClaimCotaNFTV2Entries) Len() uint {
	return s.FieldCount()
}
func (s *ClaimCotaNFTV2Entries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ClaimCotaNFTV2Entries) CountExtraFields() uint {
	return s.FieldCount() - 11
}

func (s *ClaimCotaNFTV2Entries) HasExtraFields() bool {
	return 11 != s.FieldCount()
}

func (s *ClaimCotaNFTV2Entries) HoldKeys() *HoldCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return HoldCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTV2Entries) HoldValues() *HoldCotaNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return HoldCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTV2Entries) ClaimKeys() *ClaimCotaNFTKeyVec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return ClaimCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTV2Entries) ClaimValues() *ClaimCotaNFTValueVec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return ClaimCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTV2Entries) Proof() *Bytes {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTV2Entries) Action() *Bytes {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTV2Entries) LeafKeys() *Byte32Vec {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return Byte32VecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTV2Entries) LeafValues() *Byte32Vec {
	start := unpackNumber(s.inner[32:])
	end := unpackNumber(s.inner[36:])
	return Byte32VecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTV2Entries) WithdrawalProof() *Bytes {
	start := unpackNumber(s.inner[36:])
	end := unpackNumber(s.inner[40:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTV2Entries) RawTx() *Bytes {
	start := unpackNumber(s.inner[40:])
	end := unpackNumber(s.inner[44:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimCotaNFTV2Entries) TxProof() *TransactionProof {
	var ret *TransactionProof
	start := unpackNumber(s.inner[44:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[48:])
		ret = TransactionProofFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = TransactionProofFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ClaimCotaNFTV2Entries) AsBuilder() ClaimCotaNFTV2EntriesBuilder {
	ret := NewClaimCotaNFTV2EntriesBuilder().HoldKeys(*s.HoldKeys()).HoldValues(*s.HoldValues()).ClaimKeys(*s.ClaimKeys()).ClaimValues(*s.ClaimValues()).Proof(*s.Proof()).Action(*s.Action()).LeafKeys(*s.LeafKeys()).LeafValues(*s.LeafValues()).WithdrawalProof(*s.WithdrawalProof()).RawTx(*s.RawTx()).TxProof(*s.TxProof())
	return *ret
}

type TransferCotaNFTV2EntriesBuilder struct {
	claim_keys        ClaimCotaNFTKeyVec
	claim_values      ClaimCotaNFTValueVec
	withdrawal_keys   WithdrawalCotaNFTKeyV1Vec
	withdrawal_values WithdrawalCotaNFTValueV1Vec
	proof             Bytes
	action            Bytes
	leaf_keys         Byte32Vec
	leaf_values       Byte32Vec
	withdrawal_proof  Bytes
	raw_tx            Bytes
	tx_proof          TransactionProof
}

func (s *TransferCotaNFTV2EntriesBuilder) Build() TransferCotaNFTV2Entries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (11 + 1)
	offsets := make([]uint32, 0, 11)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claim_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claim_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.leaf_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.leaf_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.raw_tx.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.tx_proof.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.claim_keys.AsSlice())
	b.Write(s.claim_values.AsSlice())
	b.Write(s.withdrawal_keys.AsSlice())
	b.Write(s.withdrawal_values.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.action.AsSlice())
	b.Write(s.leaf_keys.AsSlice())
	b.Write(s.leaf_values.AsSlice())
	b.Write(s.withdrawal_proof.AsSlice())
	b.Write(s.raw_tx.AsSlice())
	b.Write(s.tx_proof.AsSlice())
	return TransferCotaNFTV2Entries{inner: b.Bytes()}
}

func (s *TransferCotaNFTV2EntriesBuilder) ClaimKeys(v ClaimCotaNFTKeyVec) *TransferCotaNFTV2EntriesBuilder {
	s.claim_keys = v
	return s
}

func (s *TransferCotaNFTV2EntriesBuilder) ClaimValues(v ClaimCotaNFTValueVec) *TransferCotaNFTV2EntriesBuilder {
	s.claim_values = v
	return s
}

func (s *TransferCotaNFTV2EntriesBuilder) WithdrawalKeys(v WithdrawalCotaNFTKeyV1Vec) *TransferCotaNFTV2EntriesBuilder {
	s.withdrawal_keys = v
	return s
}

func (s *TransferCotaNFTV2EntriesBuilder) WithdrawalValues(v WithdrawalCotaNFTValueV1Vec) *TransferCotaNFTV2EntriesBuilder {
	s.withdrawal_values = v
	return s
}

func (s *TransferCotaNFTV2EntriesBuilder) Proof(v Bytes) *TransferCotaNFTV2EntriesBuilder {
	s.proof = v
	return s
}

func (s *TransferCotaNFTV2EntriesBuilder) Action(v Bytes) *TransferCotaNFTV2EntriesBuilder {
	s.action = v
	return s
}

func (s *TransferCotaNFTV2EntriesBuilder) LeafKeys(v Byte32Vec) *TransferCotaNFTV2EntriesBuilder {
	s.leaf_keys = v
	return s
}

func (s *TransferCotaNFTV2EntriesBuilder) LeafValues(v Byte32Vec) *TransferCotaNFTV2EntriesBuilder {
	s.leaf_values = v
	return s
}

func (s *TransferCotaNFTV2EntriesBuilder) WithdrawalProof(v Bytes) *TransferCotaNFTV2EntriesBuilder {
	s.withdrawal_proof = v
	return s
}

func (s *TransferCotaNFTV2EntriesBuilder) RawTx(v Bytes) *TransferCotaNFTV2EntriesBuilder {
	s.raw_tx = v
	return s
}

func (s *TransferCotaNFTV2EntriesBuilder) TxProof(v TransactionProof) *TransferCotaNFTV2EntriesBuilder {
	s.tx_proof = v
	return s
}

func NewTransferCotaNFTV2EntriesBuilder() *TransferCotaNFTV2EntriesBuilder {
	return &TransferCotaNFTV2EntriesBuilder{claim_keys: ClaimCotaNFTKeyVecDefault(), claim_values: ClaimCotaNFTValueVecDefault(), withdrawal_keys: WithdrawalCotaNFTKeyV1VecDefault(), withdrawal_values: WithdrawalCotaNFTValueV1VecDefault(), proof: BytesDefault(), action: BytesDefault(), leaf_keys: Byte32VecDefault(), leaf_values: Byte32VecDefault(), withdrawal_proof: BytesDefault(), raw_tx: BytesDefault(), tx_proof: TransactionProofDefault()}
}

type TransferCotaNFTV2Entries struct {
	inner []byte
}

func TransferCotaNFTV2EntriesFromSliceUnchecked(slice []byte) *TransferCotaNFTV2Entries {
	return &TransferCotaNFTV2Entries{inner: slice}
}
func (s *TransferCotaNFTV2Entries) AsSlice() []byte {
	return s.inner
}

func TransferCotaNFTV2EntriesDefault() TransferCotaNFTV2Entries {
	return *TransferCotaNFTV2EntriesFromSliceUnchecked([]byte{152, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 60, 0, 0, 0, 64, 0, 0, 0, 68, 0, 0, 0, 72, 0, 0, 0, 76, 0, 0, 0, 80, 0, 0, 0, 84, 0, 0, 0, 88, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func TransferCotaNFTV2EntriesFromSlice(slice []byte, compatible bool) (*TransferCotaNFTV2Entries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TransferCotaNFTV2Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TransferCotaNFTV2Entries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 11 == 0 {
		return &TransferCotaNFTV2Entries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TransferCotaNFTV2Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "TransferCotaNFTV2Entries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TransferCotaNFTV2Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 11 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 11 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = ClaimCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimCotaNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTKeyV1VecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTValueV1VecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Byte32VecFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Byte32VecFromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[8]:offsets[9]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[9]:offsets[10]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TransactionProofFromSlice(slice[offsets[10]:offsets[11]], compatible)
	if err != nil {
		return nil, err
	}

	return &TransferCotaNFTV2Entries{inner: slice}, nil
}

func (s *TransferCotaNFTV2Entries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *TransferCotaNFTV2Entries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *TransferCotaNFTV2Entries) Len() uint {
	return s.FieldCount()
}
func (s *TransferCotaNFTV2Entries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *TransferCotaNFTV2Entries) CountExtraFields() uint {
	return s.FieldCount() - 11
}

func (s *TransferCotaNFTV2Entries) HasExtraFields() bool {
	return 11 != s.FieldCount()
}

func (s *TransferCotaNFTV2Entries) ClaimKeys() *ClaimCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return ClaimCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTV2Entries) ClaimValues() *ClaimCotaNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return ClaimCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTV2Entries) WithdrawalKeys() *WithdrawalCotaNFTKeyV1Vec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return WithdrawalCotaNFTKeyV1VecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTV2Entries) WithdrawalValues() *WithdrawalCotaNFTValueV1Vec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return WithdrawalCotaNFTValueV1VecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTV2Entries) Proof() *Bytes {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTV2Entries) Action() *Bytes {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTV2Entries) LeafKeys() *Byte32Vec {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return Byte32VecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTV2Entries) LeafValues() *Byte32Vec {
	start := unpackNumber(s.inner[32:])
	end := unpackNumber(s.inner[36:])
	return Byte32VecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTV2Entries) WithdrawalProof() *Bytes {
	start := unpackNumber(s.inner[36:])
	end := unpackNumber(s.inner[40:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTV2Entries) RawTx() *Bytes {
	start := unpackNumber(s.inner[40:])
	end := unpackNumber(s.inner[44:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferCotaNFTV2Entries) TxProof() *TransactionProof {
	var ret *TransactionProof
	start := unpackNumber(s.inner[44:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[48:])
		ret = TransactionProofFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = TransactionProofFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *TransferCotaNFTV2Entries) AsBuilder() TransferCotaNFTV2EntriesBuilder {
	ret := NewTransferCotaNFTV2EntriesBuilder().ClaimKeys(*s.ClaimKeys()).ClaimValues(*s.ClaimValues()).WithdrawalKeys(*s.WithdrawalKeys()).WithdrawalValues(*s.WithdrawalValues()).Proof(*s.Proof()).Action(*s.Action()).LeafKeys(*s.LeafKeys()).LeafValues(*s.LeafValues()).WithdrawalProof(*s.WithdrawalProof()).RawTx(*s.RawTx()).TxProof(*s.TxProof())
	return *ret
}

type ClaimUpdateCotaNFTV2EntriesBuilder struct {
	hold_keys        HoldCotaNFTKeyVec
	hold_values      HoldCotaNFTValueVec
	claim_keys       ClaimCotaNFTKeyVec
	claim_infos      ClaimCotaNFTInfoVec
	proof            Bytes
	action           Bytes
	leaf_keys        Byte32Vec
	leaf_values      Byte32Vec
	withdrawal_proof Bytes
	raw_tx           Bytes
	tx_proof         TransactionProof
}

func (s *ClaimUpdateCotaNFTV2EntriesBuilder) Build() ClaimUpdateCotaNFTV2Entries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (11 + 1)
	offsets := make([]uint32, 0, 11)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.hold_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.hold_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claim_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claim_infos.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.leaf_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.leaf_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.raw_tx.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.tx_proof.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.hold_keys.AsSlice())
	b.Write(s.hold_values.AsSlice())
	b.Write(s.claim_keys.AsSlice())
	b.Write(s.claim_infos.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.action.AsSlice())
	b.Write(s.leaf_keys.AsSlice())
	b.Write(s.leaf_values.AsSlice())
	b.Write(s.withdrawal_proof.AsSlice())
	b.Write(s.raw_tx.AsSlice())
	b.Write(s.tx_proof.AsSlice())
	return ClaimUpdateCotaNFTV2Entries{inner: b.Bytes()}
}

func (s *ClaimUpdateCotaNFTV2EntriesBuilder) HoldKeys(v HoldCotaNFTKeyVec) *ClaimUpdateCotaNFTV2EntriesBuilder {
	s.hold_keys = v
	return s
}

func (s *ClaimUpdateCotaNFTV2EntriesBuilder) HoldValues(v HoldCotaNFTValueVec) *ClaimUpdateCotaNFTV2EntriesBuilder {
	s.hold_values = v
	return s
}

func (s *ClaimUpdateCotaNFTV2EntriesBuilder) ClaimKeys(v ClaimCotaNFTKeyVec) *ClaimUpdateCotaNFTV2EntriesBuilder {
	s.claim_keys = v
	return s
}

func (s *ClaimUpdateCotaNFTV2EntriesBuilder) ClaimInfos(v ClaimCotaNFTInfoVec) *ClaimUpdateCotaNFTV2EntriesBuilder {
	s.claim_infos = v
	return s
}

func (s *ClaimUpdateCotaNFTV2EntriesBuilder) Proof(v Bytes) *ClaimUpdateCotaNFTV2EntriesBuilder {
	s.proof = v
	return s
}

func (s *ClaimUpdateCotaNFTV2EntriesBuilder) Action(v Bytes) *ClaimUpdateCotaNFTV2EntriesBuilder {
	s.action = v
	return s
}

func (s *ClaimUpdateCotaNFTV2EntriesBuilder) LeafKeys(v Byte32Vec) *ClaimUpdateCotaNFTV2EntriesBuilder {
	s.leaf_keys = v
	return s
}

func (s *ClaimUpdateCotaNFTV2EntriesBuilder) LeafValues(v Byte32Vec) *ClaimUpdateCotaNFTV2EntriesBuilder {
	s.leaf_values = v
	return s
}

func (s *ClaimUpdateCotaNFTV2EntriesBuilder) WithdrawalProof(v Bytes) *ClaimUpdateCotaNFTV2EntriesBuilder {
	s.withdrawal_proof = v
	return s
}

func (s *ClaimUpdateCotaNFTV2EntriesBuilder) RawTx(v Bytes) *ClaimUpdateCotaNFTV2EntriesBuilder {
	s.raw_tx = v
	return s
}

func (s *ClaimUpdateCotaNFTV2EntriesBuilder) TxProof(v TransactionProof) *ClaimUpdateCotaNFTV2EntriesBuilder {
	s.tx_proof = v
	return s
}

func NewClaimUpdateCotaNFTV2EntriesBuilder() *ClaimUpdateCotaNFTV2EntriesBuilder {
	return &ClaimUpdateCotaNFTV2EntriesBuilder{hold_keys: HoldCotaNFTKeyVecDefault(), hold_values: HoldCotaNFTValueVecDefault(), claim_keys: ClaimCotaNFTKeyVecDefault(), claim_infos: ClaimCotaNFTInfoVecDefault(), proof: BytesDefault(), action: BytesDefault(), leaf_keys: Byte32VecDefault(), leaf_values: Byte32VecDefault(), withdrawal_proof: BytesDefault(), raw_tx: BytesDefault(), tx_proof: TransactionProofDefault()}
}

type ClaimUpdateCotaNFTV2Entries struct {
	inner []byte
}

func ClaimUpdateCotaNFTV2EntriesFromSliceUnchecked(slice []byte) *ClaimUpdateCotaNFTV2Entries {
	return &ClaimUpdateCotaNFTV2Entries{inner: slice}
}
func (s *ClaimUpdateCotaNFTV2Entries) AsSlice() []byte {
	return s.inner
}

func ClaimUpdateCotaNFTV2EntriesDefault() ClaimUpdateCotaNFTV2Entries {
	return *ClaimUpdateCotaNFTV2EntriesFromSliceUnchecked([]byte{152, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 60, 0, 0, 0, 64, 0, 0, 0, 68, 0, 0, 0, 72, 0, 0, 0, 76, 0, 0, 0, 80, 0, 0, 0, 84, 0, 0, 0, 88, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ClaimUpdateCotaNFTV2EntriesFromSlice(slice []byte, compatible bool) (*ClaimUpdateCotaNFTV2Entries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimUpdateCotaNFTV2Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimUpdateCotaNFTV2Entries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 11 == 0 {
		return &ClaimUpdateCotaNFTV2Entries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ClaimUpdateCotaNFTV2Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ClaimUpdateCotaNFTV2Entries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ClaimUpdateCotaNFTV2Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 11 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 11 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = HoldCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HoldCotaNFTValueVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimCotaNFTKeyVecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimCotaNFTInfoVecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Byte32VecFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Byte32VecFromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[8]:offsets[9]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[9]:offsets[10]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TransactionProofFromSlice(slice[offsets[10]:offsets[11]], compatible)
	if err != nil {
		return nil, err
	}

	return &ClaimUpdateCotaNFTV2Entries{inner: slice}, nil
}

func (s *ClaimUpdateCotaNFTV2Entries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ClaimUpdateCotaNFTV2Entries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ClaimUpdateCotaNFTV2Entries) Len() uint {
	return s.FieldCount()
}
func (s *ClaimUpdateCotaNFTV2Entries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ClaimUpdateCotaNFTV2Entries) CountExtraFields() uint {
	return s.FieldCount() - 11
}

func (s *ClaimUpdateCotaNFTV2Entries) HasExtraFields() bool {
	return 11 != s.FieldCount()
}

func (s *ClaimUpdateCotaNFTV2Entries) HoldKeys() *HoldCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return HoldCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimUpdateCotaNFTV2Entries) HoldValues() *HoldCotaNFTValueVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return HoldCotaNFTValueVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimUpdateCotaNFTV2Entries) ClaimKeys() *ClaimCotaNFTKeyVec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return ClaimCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimUpdateCotaNFTV2Entries) ClaimInfos() *ClaimCotaNFTInfoVec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return ClaimCotaNFTInfoVecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimUpdateCotaNFTV2Entries) Proof() *Bytes {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimUpdateCotaNFTV2Entries) Action() *Bytes {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimUpdateCotaNFTV2Entries) LeafKeys() *Byte32Vec {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return Byte32VecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimUpdateCotaNFTV2Entries) LeafValues() *Byte32Vec {
	start := unpackNumber(s.inner[32:])
	end := unpackNumber(s.inner[36:])
	return Byte32VecFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimUpdateCotaNFTV2Entries) WithdrawalProof() *Bytes {
	start := unpackNumber(s.inner[36:])
	end := unpackNumber(s.inner[40:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimUpdateCotaNFTV2Entries) RawTx() *Bytes {
	start := unpackNumber(s.inner[40:])
	end := unpackNumber(s.inner[44:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *ClaimUpdateCotaNFTV2Entries) TxProof() *TransactionProof {
	var ret *TransactionProof
	start := unpackNumber(s.inner[44:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[48:])
		ret = TransactionProofFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = TransactionProofFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ClaimUpdateCotaNFTV2Entries) AsBuilder() ClaimUpdateCotaNFTV2EntriesBuilder {
	ret := NewClaimUpdateCotaNFTV2EntriesBuilder().HoldKeys(*s.HoldKeys()).HoldValues(*s.HoldValues()).ClaimKeys(*s.ClaimKeys()).ClaimInfos(*s.ClaimInfos()).Proof(*s.Proof()).Action(*s.Action()).LeafKeys(*s.LeafKeys()).LeafValues(*s.LeafValues()).WithdrawalProof(*s.WithdrawalProof()).RawTx(*s.RawTx()).TxProof(*s.TxProof())
	return *ret
}

type TransferUpdateCotaNFTV2EntriesBuilder struct {
	claim_keys        ClaimCotaNFTKeyVec
	claim_infos       ClaimCotaNFTInfoVec
	withdrawal_keys   WithdrawalCotaNFTKeyV1Vec
	withdrawal_values WithdrawalCotaNFTValueV1Vec
	proof             Bytes
	action            Bytes
	leaf_keys         Byte32Vec
	leaf_values       Byte32Vec
	withdrawal_proof  Bytes
	raw_tx            Bytes
	tx_proof          TransactionProof
}

func (s *TransferUpdateCotaNFTV2EntriesBuilder) Build() TransferUpdateCotaNFTV2Entries {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (11 + 1)
	offsets := make([]uint32, 0, 11)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claim_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.claim_infos.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.leaf_keys.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.leaf_values.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.withdrawal_proof.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.raw_tx.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.tx_proof.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.claim_keys.AsSlice())
	b.Write(s.claim_infos.AsSlice())
	b.Write(s.withdrawal_keys.AsSlice())
	b.Write(s.withdrawal_values.AsSlice())
	b.Write(s.proof.AsSlice())
	b.Write(s.action.AsSlice())
	b.Write(s.leaf_keys.AsSlice())
	b.Write(s.leaf_values.AsSlice())
	b.Write(s.withdrawal_proof.AsSlice())
	b.Write(s.raw_tx.AsSlice())
	b.Write(s.tx_proof.AsSlice())
	return TransferUpdateCotaNFTV2Entries{inner: b.Bytes()}
}

func (s *TransferUpdateCotaNFTV2EntriesBuilder) ClaimKeys(v ClaimCotaNFTKeyVec) *TransferUpdateCotaNFTV2EntriesBuilder {
	s.claim_keys = v
	return s
}

func (s *TransferUpdateCotaNFTV2EntriesBuilder) ClaimInfos(v ClaimCotaNFTInfoVec) *TransferUpdateCotaNFTV2EntriesBuilder {
	s.claim_infos = v
	return s
}

func (s *TransferUpdateCotaNFTV2EntriesBuilder) WithdrawalKeys(v WithdrawalCotaNFTKeyV1Vec) *TransferUpdateCotaNFTV2EntriesBuilder {
	s.withdrawal_keys = v
	return s
}

func (s *TransferUpdateCotaNFTV2EntriesBuilder) WithdrawalValues(v WithdrawalCotaNFTValueV1Vec) *TransferUpdateCotaNFTV2EntriesBuilder {
	s.withdrawal_values = v
	return s
}

func (s *TransferUpdateCotaNFTV2EntriesBuilder) Proof(v Bytes) *TransferUpdateCotaNFTV2EntriesBuilder {
	s.proof = v
	return s
}

func (s *TransferUpdateCotaNFTV2EntriesBuilder) Action(v Bytes) *TransferUpdateCotaNFTV2EntriesBuilder {
	s.action = v
	return s
}

func (s *TransferUpdateCotaNFTV2EntriesBuilder) LeafKeys(v Byte32Vec) *TransferUpdateCotaNFTV2EntriesBuilder {
	s.leaf_keys = v
	return s
}

func (s *TransferUpdateCotaNFTV2EntriesBuilder) LeafValues(v Byte32Vec) *TransferUpdateCotaNFTV2EntriesBuilder {
	s.leaf_values = v
	return s
}

func (s *TransferUpdateCotaNFTV2EntriesBuilder) WithdrawalProof(v Bytes) *TransferUpdateCotaNFTV2EntriesBuilder {
	s.withdrawal_proof = v
	return s
}

func (s *TransferUpdateCotaNFTV2EntriesBuilder) RawTx(v Bytes) *TransferUpdateCotaNFTV2EntriesBuilder {
	s.raw_tx = v
	return s
}

func (s *TransferUpdateCotaNFTV2EntriesBuilder) TxProof(v TransactionProof) *TransferUpdateCotaNFTV2EntriesBuilder {
	s.tx_proof = v
	return s
}

func NewTransferUpdateCotaNFTV2EntriesBuilder() *TransferUpdateCotaNFTV2EntriesBuilder {
	return &TransferUpdateCotaNFTV2EntriesBuilder{claim_keys: ClaimCotaNFTKeyVecDefault(), claim_infos: ClaimCotaNFTInfoVecDefault(), withdrawal_keys: WithdrawalCotaNFTKeyV1VecDefault(), withdrawal_values: WithdrawalCotaNFTValueV1VecDefault(), proof: BytesDefault(), action: BytesDefault(), leaf_keys: Byte32VecDefault(), leaf_values: Byte32VecDefault(), withdrawal_proof: BytesDefault(), raw_tx: BytesDefault(), tx_proof: TransactionProofDefault()}
}

type TransferUpdateCotaNFTV2Entries struct {
	inner []byte
}

func TransferUpdateCotaNFTV2EntriesFromSliceUnchecked(slice []byte) *TransferUpdateCotaNFTV2Entries {
	return &TransferUpdateCotaNFTV2Entries{inner: slice}
}
func (s *TransferUpdateCotaNFTV2Entries) AsSlice() []byte {
	return s.inner
}

func TransferUpdateCotaNFTV2EntriesDefault() TransferUpdateCotaNFTV2Entries {
	return *TransferUpdateCotaNFTV2EntriesFromSliceUnchecked([]byte{152, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 60, 0, 0, 0, 64, 0, 0, 0, 68, 0, 0, 0, 72, 0, 0, 0, 76, 0, 0, 0, 80, 0, 0, 0, 84, 0, 0, 0, 88, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func TransferUpdateCotaNFTV2EntriesFromSlice(slice []byte, compatible bool) (*TransferUpdateCotaNFTV2Entries, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TransferUpdateCotaNFTV2Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TransferUpdateCotaNFTV2Entries", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 11 == 0 {
		return &TransferUpdateCotaNFTV2Entries{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TransferUpdateCotaNFTV2Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "TransferUpdateCotaNFTV2Entries", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TransferUpdateCotaNFTV2Entries", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 11 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 11 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = ClaimCotaNFTKeyVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ClaimCotaNFTInfoVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTKeyV1VecFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = WithdrawalCotaNFTValueV1VecFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Byte32VecFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Byte32VecFromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[8]:offsets[9]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[9]:offsets[10]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TransactionProofFromSlice(slice[offsets[10]:offsets[11]], compatible)
	if err != nil {
		return nil, err
	}

	return &TransferUpdateCotaNFTV2Entries{inner: slice}, nil
}

func (s *TransferUpdateCotaNFTV2Entries) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *TransferUpdateCotaNFTV2Entries) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *TransferUpdateCotaNFTV2Entries) Len() uint {
	return s.FieldCount()
}
func (s *TransferUpdateCotaNFTV2Entries) IsEmpty() bool {
	return s.Len() == 0
}
func (s *TransferUpdateCotaNFTV2Entries) CountExtraFields() uint {
	return s.FieldCount() - 11
}

func (s *TransferUpdateCotaNFTV2Entries) HasExtraFields() bool {
	return 11 != s.FieldCount()
}

func (s *TransferUpdateCotaNFTV2Entries) ClaimKeys() *ClaimCotaNFTKeyVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return ClaimCotaNFTKeyVecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTV2Entries) ClaimInfos() *ClaimCotaNFTInfoVec {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return ClaimCotaNFTInfoVecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTV2Entries) WithdrawalKeys() *WithdrawalCotaNFTKeyV1Vec {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return WithdrawalCotaNFTKeyV1VecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTV2Entries) WithdrawalValues() *WithdrawalCotaNFTValueV1Vec {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return WithdrawalCotaNFTValueV1VecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTV2Entries) Proof() *Bytes {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTV2Entries) Action() *Bytes {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTV2Entries) LeafKeys() *Byte32Vec {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return Byte32VecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTV2Entries) LeafValues() *Byte32Vec {
	start := unpackNumber(s.inner[32:])
	end := unpackNumber(s.inner[36:])
	return Byte32VecFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTV2Entries) WithdrawalProof() *Bytes {
	start := unpackNumber(s.inner[36:])
	end := unpackNumber(s.inner[40:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTV2Entries) RawTx() *Bytes {
	start := unpackNumber(s.inner[40:])
	end := unpackNumber(s.inner[44:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *TransferUpdateCotaNFTV2Entries) TxProof() *TransactionProof {
	var ret *TransactionProof
	start := unpackNumber(s.inner[44:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[48:])
		ret = TransactionProofFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = TransactionProofFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *TransferUpdateCotaNFTV2Entries) AsBuilder() TransferUpdateCotaNFTV2EntriesBuilder {
	ret := NewTransferUpdateCotaNFTV2EntriesBuilder().ClaimKeys(*s.ClaimKeys()).ClaimInfos(*s.ClaimInfos()).WithdrawalKeys(*s.WithdrawalKeys()).WithdrawalValues(*s.WithdrawalValues()).Proof(*s.Proof()).Action(*s.Action()).LeafKeys(*s.LeafKeys()).LeafValues(*s.LeafValues()).WithdrawalProof(*s.WithdrawalProof()).RawTx(*s.RawTx()).TxProof(*s.TxProof())
	return *ret
}
